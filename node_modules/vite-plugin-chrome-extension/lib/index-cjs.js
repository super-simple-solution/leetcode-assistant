'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var path = require('path');
var fs = require('fs-extra');
require('array-flat-polyfill');
var slash = require('slash');
var cheerio = require('cheerio');
var prettier = require('prettier');
var cosmiconfig = require('cosmiconfig');
var jsonpathPlus = require('jsonpath-plus');
var memoize = require('mem');
var glob = require('glob');
var get = require('lodash.get');
var diff = require('lodash.difference');
var Ajv = require('ajv');
var chalk = require('chalk');
var rollup = require('rollup');
var fs$1 = require('fs');
var flatten = require('lodash.flatten');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var slash__default = /*#__PURE__*/_interopDefaultLegacy(slash);
var cheerio__default = /*#__PURE__*/_interopDefaultLegacy(cheerio);
var prettier__default = /*#__PURE__*/_interopDefaultLegacy(prettier);
var memoize__default = /*#__PURE__*/_interopDefaultLegacy(memoize);
var glob__default = /*#__PURE__*/_interopDefaultLegacy(glob);
var get__default = /*#__PURE__*/_interopDefaultLegacy(get);
var diff__default = /*#__PURE__*/_interopDefaultLegacy(diff);
var Ajv__default = /*#__PURE__*/_interopDefaultLegacy(Ajv);
var chalk__default = /*#__PURE__*/_interopDefaultLegacy(chalk);
var flatten__default = /*#__PURE__*/_interopDefaultLegacy(flatten);

function _optionalChain$2(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }



const not = (fn) => (x) => !fn(x);

function isChunk(
    x,
) {
    return x && x.type === "chunk";
}

function isAsset(
    x,
) {
    return x.type === "asset";
}

function isString(x) {
    return typeof x === "string";
}

function isJsonFilePath(x) {
    return isString(x) && x.endsWith("json");
}

function getOutputFilenameFromChunk(sourceFileName, chunks) {
    const chunk = chunks.find(c => c.facadeModuleId && slash__default['default'](c.facadeModuleId) === slash__default['default'](sourceFileName));
    return slash__default['default'](_optionalChain$2([chunk, 'optionalAccess', _ => _.fileName]) || "");
}
function findChunkByName(name, bundle) {
    return Object.values(bundle).find(b => b.name && slash__default['default'](b.name) === slash__default['default'](name) && b.type === "chunk") ;
}
function findAssetByName(name, bundle) {
    return Object.values(bundle).find(b => b.name && slash__default['default'](b.name) === slash__default['default'](name) && b.type === "asset") ;
}
function findChunk(sourceFileName, chunks) {
    return Object.values(chunks).find(c => c.facadeModuleId && slash__default['default'](c.facadeModuleId) === slash__default['default'](sourceFileName));
}

/**
 * Update the manifest source in the output bundle
 */
const updateManifest = (
    updater

,
    bundle,
    handleError,
) => {
    try {
        const manifestKey = "manifest.json";
        const manifestAsset = bundle[manifestKey] ;

        if (!manifestAsset) {
            throw new Error(
                "No manifest.json in the rollup output bundle.",
            );
        }

        const manifest = JSON.parse(
            manifestAsset.source ,
        ) ;

        const result = updater(manifest);

        manifestAsset.source = JSON.stringify(result, undefined, 2);
    } catch (error) {
        if (handleError) {
            handleError(error.message);
        } else {
            throw error;
        }
    }

    return bundle;
};

const formatHtml = ($) =>
    prettier__default['default'].format($.html(), { parser: "html" });

const loadHtml = (rootPath) => (
    filePath,
) => {
    const htmlCode = fs__default['default'].readFileSync(filePath, "utf8");
    const $ = cheerio__default['default'].load(htmlCode);

    return Object.assign($, { filePath, rootPath });
};

const getRelativePath = ({
    filePath,
    rootPath,
}) => (p) => {
    const htmlFileDir = path__default['default'].dirname(filePath);

    let relDir;
    if (p.startsWith("/")) {
        relDir = path__default['default'].relative(process.cwd(), rootPath);
    } else {
        relDir = path__default['default'].relative(process.cwd(), htmlFileDir);
    }

    return path__default['default'].join(relDir, p);
};

/* -------------------- SCRIPTS -------------------- */

const getScriptElems = ($) =>
    $("script")
        .not("[data-rollup-asset]")
        .not('[src^="http:"]')
        .not('[src^="https:"]')
        .not('[src^="data:"]')
        .not('[src^="/"]');

const getScripts = ($) =>
    getScriptElems($).toArray();

const getScriptSrc = ($) =>
    getScripts($)
        .map((elem) => $(elem).attr("src"))
        .filter(isString)
        .map(getRelativePath($));

/* ----------------- ASSET SCRIPTS ----------------- */

const getAssets$1 = ($) =>
    $("script")
        .filter('[data-rollup-asset="true"]')
        .not('[src^="http:"]')
        .not('[src^="https:"]')
        .not('[src^="data:"]')
        .not('[src^="/"]')
        .toArray();

const getJsAssets = ($) =>
    getAssets$1($)
        .map((elem) => $(elem).attr("src"))
        .filter(isString)
        .map(getRelativePath($));

/* -------------------- css ------------------- */

const getCss = ($) =>
    $("link")
        .filter('[rel="stylesheet"]')
        .not('[href^="http:"]')
        .not('[href^="https:"]')
        .not('[href^="data:"]')
        .not('[href^="/"]')
        .toArray();

const getCssHrefs = ($) =>
    getCss($)
        .map((elem) => $(elem).attr("href"))
        .filter(isString)
        .map(getRelativePath($));

/* -------------------- img ------------------- */

const getImgs = ($) =>
    $("img")
        .not('[src^="http://"]')
        .not('[src^="https://"]')
        .not('[src^="data:"]')
        .toArray();

const getFavicons = ($) =>
    $('link[rel="icon"]')
        .not('[href^="http:"]')
        .not('[href^="https:"]')
        .not('[href^="data:"]')
        .toArray();

const getImgSrcs = ($) => {
    return [
        ...getImgs($).map((elem) => $(elem).attr("src")),
        ...getFavicons($).map((elem) => $(elem).attr("href")),
    ]
        .filter(isString)
        .map(getRelativePath($));
};

function generateHtml(
    context,
    htmls,
    chunks,
    options,
    srcDir,
) {
    htmls.map($ => replaceImportScriptPath($, chunks, srcDir, options.browserPolyfill))
        .map($ => {
            const source = formatHtml($);
            const fileName = path.relative(srcDir, $.filePath);
            context.emitFile({
                type: "asset",
                source, // String
                fileName,
        });
    });
}

function replaceImportScriptPath(
    $,
    chunks,
    srcDir,
    browserPolyfill,
) {
    getScriptElems($)
        .attr("type", "module")
        .attr("src", (i, value) => {
            const basePath = path.dirname($.filePath);
            const chunkName = getOutputFilenameFromChunk(path.resolve(basePath, value ), chunks);
            return path.relative(basePath, path.resolve(srcDir, chunkName));
        });

    if (browserPolyfill) {
        const head = $("head");
        if (
            browserPolyfill === true ||
            (typeof browserPolyfill === "object" &&
                browserPolyfill.executeScript)
        ) {
            head.prepend(
                '<script src="/assets/browser-polyfill-executeScript.js"></script>',
            );
        }

        head.prepend(
            '<script src="/assets/browser-polyfill.js"></script>',
        );
    }

    return $;
}

const name$1 = "html-inputs";

/* ============================================ */
/*                  HTML-INPUTS                 */
/* ============================================ */

function htmlInputs(
    htmlInputsOptions,
    /** Used for testing */
    cache = {
        scripts: [],
        html: [],
        html$: [],
        js: [],
        css: [],
        img: [],
        input: [],
    } ,
) {
    return {
        name: name$1,
        cache,

        generateBundle(options, bundle) {
            if (!cache.srcDir) {
                throw new TypeError("cache.srcDir not initialized");
            }
            const chunks = Object.values(bundle).filter(isChunk);
            generateHtml(this, cache.html$, chunks, htmlInputsOptions, cache.srcDir);
        },
    };
}

const cloneObject = (obj) => JSON.parse(JSON.stringify(obj));

const manifestName = "manifest.json";

function generateManifest(
    context,
    manifest,
) {
    const manifestJson = JSON.stringify(manifest, null, 4)
        // SMELL: is this necessary?
        .replace(/\.[jt]sx?"/g, '.js"');
    // Emit manifest.json
    context.emitFile({
        type: "asset",
        fileName: manifestName,
        source: manifestJson,
    });
}

const combinePerms = (
  ...permissions
) => {
  const { perms, xperms } = (permissions.flat(
    Infinity,
  ) )
    .filter((perm) => typeof perm !== "undefined")
    .reduce(
      ({ perms, xperms }, perm) => {
        if (perm.startsWith("!")) {
          xperms.add(perm.slice(1));
        } else {
          perms.add(perm);
        }

        return { perms, xperms };
      },
      { perms: new Set(), xperms: new Set() },
    );

  return [...perms].filter((p) => !xperms.has(p));
};

// /* ============================================ */
// /*                DERIVE MANIFEST               */
// /* ============================================ */

// export function deriveManifest(
//   manifest: ChromeExtensionManifest, // manifest.json
//   ...permissions: string[] | string[][] // will be combined with manifest.permissions
// ): ChromeExtensionManifest {
//   return validateManifest({
//     // SMELL: Is this necessary?
//     manifest_version: 2,
//     ...manifest,
//     permissions: combinePerms(permissions, manifest.permissions),
//   })
// }

/* -------------------------------------------- */
/*                 DERIVE FILES                 */
/* -------------------------------------------- */

function deriveFiles$1(
    manifest,
    srcDir,
) {
    // get resources from section web_accessible_resources
    const web_accessible_resources = get__default['default'](
        manifest,
        "web_accessible_resources",
        [] ,
    ).reduce((resource_paths, web_accessible_resource) =>
        web_accessible_resource.resources.reduce((r, x) => {
            if (glob__default['default'].hasMagic(x)) {
                const files = glob__default['default'].sync(x, { cwd: srcDir });
                return [...r, ...files.map((f) => f.replace(srcDir, ""))];
            } else {
                return [...r, x];
            }
        }, resource_paths),
    [] );

    /**
     * js files come from:
     *  - web_accessible_resources
     *  - background.service_worker
     *  - content_scripts
     */
    const js = [
        ...web_accessible_resources.filter((f) => /\.[jt]sx?$/.test(f)),
        get__default['default'](manifest, "background.service_worker"),
        ...get__default['default'](
            manifest,
            "content_scripts",
            [] ,
        ).reduce((r, { js = [] }) => [...r, ...js], [] ),
    ];

    /**
     * html files come from:
     *  - web_accessible_resources
     *  - options_page
     *  - options_ui.page
     *  - devtools_page
     *  - action.default_popup
     *  - chrome_url_overrides
     */
    const html = [
        ...web_accessible_resources.filter((f) => /\.html?$/.test(f)),
        get__default['default'](manifest, "options_page"),
        get__default['default'](manifest, "options_ui.page"),
        get__default['default'](manifest, "devtools_page"),
        get__default['default'](manifest, "action.default_popup"),
        ...Object.values(get__default['default'](manifest, "chrome_url_overrides", {})),
    ];

    /**
     * css files come from:
     *  - web_accessible_resources
     *  - content_scripts
     */
    const css = [
        ...web_accessible_resources.filter((f) => f.endsWith(".css")),
        ...get__default['default'](
            manifest,
            "content_scripts",
            [] ,
        ).reduce(
            (r, { css = [] }) => [...r, ...css],
            [] ,
        ),
    ];

    /**
     * action icons come from:
     *  - web_accessible_resources
     *  - content_scripts
     */
    const actionIconSet = new Set();
    const default_icons = get__default['default'](
        manifest,
        "action.default_icon",
        {} ,
    );
    if (typeof default_icons === "string") {
        actionIconSet.add(default_icons);
    } else {
        Object.values(default_icons).forEach((x) => actionIconSet.add(x));
    }

    /**
     * image files come from:
     *  - web_accessible_resources
     *  - action.default_icon
     *  - icons
     */
    const img = [
        ...actionIconSet,
        ...web_accessible_resources.filter((f) =>
            /\.(jpe?g|png|svg|tiff?|gif|webp|bmp|ico)$/i.test(f),
        ),
        ...Object.values(get__default['default'](manifest, "icons", {})),
    ];

    // Files like fonts, things that are not expected
    const others = diff__default['default'](web_accessible_resources, css, js, html, img);

    return {
        css: validate(css),
        js: validate(js),
        html: validate(html),
        img: validate(img),
        others: validate(others),
    };

    function validate(ary) {
        return [...new Set(ary.filter(isString))].map((x) =>
            path.join(srcDir, x),
        );
    }

    function isString(x) {
        return typeof x === "string";
    }
}

var id = "http://json-schema.org/draft-04/schema#";
var $schema$1 = "http://json-schema.org/draft-04/schema#";
var description = "Core schema meta-schema";
var definitions$1 = {
	schemaArray: {
		type: "array",
		minItems: 1,
		items: {
			$ref: "#"
		}
	},
	positiveInteger: {
		type: "integer",
		minimum: 0
	},
	positiveIntegerDefault0: {
		allOf: [
			{
				$ref: "#/definitions/positiveInteger"
			},
			{
				"default": 0
			}
		]
	},
	simpleTypes: {
		"enum": [
			"array",
			"boolean",
			"integer",
			"null",
			"number",
			"object",
			"string"
		]
	},
	stringArray: {
		type: "array",
		items: {
			type: "string"
		},
		minItems: 1,
		uniqueItems: true
	}
};
var type$1 = "object";
var properties$1 = {
	id: {
		type: "string"
	},
	$schema: {
		type: "string"
	},
	title: {
		type: "string"
	},
	description: {
		type: "string"
	},
	"default": {
	},
	multipleOf: {
		type: "number",
		minimum: 0,
		exclusiveMinimum: true
	},
	maximum: {
		type: "number"
	},
	exclusiveMaximum: {
		type: "boolean",
		"default": false
	},
	minimum: {
		type: "number"
	},
	exclusiveMinimum: {
		type: "boolean",
		"default": false
	},
	maxLength: {
		$ref: "#/definitions/positiveInteger"
	},
	minLength: {
		$ref: "#/definitions/positiveIntegerDefault0"
	},
	pattern: {
		type: "string",
		format: "regex"
	},
	additionalItems: {
		anyOf: [
			{
				type: "boolean"
			},
			{
				$ref: "#"
			}
		],
		"default": {
		}
	},
	items: {
		anyOf: [
			{
				$ref: "#"
			},
			{
				$ref: "#/definitions/schemaArray"
			}
		],
		"default": {
		}
	},
	maxItems: {
		$ref: "#/definitions/positiveInteger"
	},
	minItems: {
		$ref: "#/definitions/positiveIntegerDefault0"
	},
	uniqueItems: {
		type: "boolean",
		"default": false
	},
	maxProperties: {
		$ref: "#/definitions/positiveInteger"
	},
	minProperties: {
		$ref: "#/definitions/positiveIntegerDefault0"
	},
	required: {
		$ref: "#/definitions/stringArray"
	},
	additionalProperties: {
		anyOf: [
			{
				type: "boolean"
			},
			{
				$ref: "#"
			}
		],
		"default": {
		}
	},
	definitions: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	properties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	patternProperties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	dependencies: {
		type: "object",
		additionalProperties: {
			anyOf: [
				{
					$ref: "#"
				},
				{
					$ref: "#/definitions/stringArray"
				}
			]
		}
	},
	"enum": {
		type: "array",
		minItems: 1,
		uniqueItems: true
	},
	type: {
		anyOf: [
			{
				$ref: "#/definitions/simpleTypes"
			},
			{
				type: "array",
				items: {
					$ref: "#/definitions/simpleTypes"
				},
				minItems: 1,
				uniqueItems: true
			}
		]
	},
	format: {
		type: "string"
	},
	allOf: {
		$ref: "#/definitions/schemaArray"
	},
	anyOf: {
		$ref: "#/definitions/schemaArray"
	},
	oneOf: {
		$ref: "#/definitions/schemaArray"
	},
	not: {
		$ref: "#"
	}
};
var dependencies$1 = {
	exclusiveMaximum: [
		"maximum"
	],
	exclusiveMinimum: [
		"minimum"
	]
};
var jsonSchema = {
	id: id,
	$schema: $schema$1,
	description: description,
	definitions: definitions$1,
	type: type$1,
	properties: properties$1,
	dependencies: dependencies$1,
	"default": {
}
};

var title = "JSON schema for Google Chrome extension manifest files";
var $schema = "http://json-schema.org/draft-04/schema#";
var type = "object";
var additionalProperties = true;
var required = [
	"manifest_version",
	"name",
	"version"
];
var properties = {
	manifest_version: {
		type: "number",
		description: "One integer specifying the version of the manifest file format your package requires.",
		"enum": [
			3
		],
		minimum: 3,
		maximum: 3
	},
	name: {
		type: "string",
		description: "The name of the extension",
		maxLength: 45
	},
	version: {
		description: "One to four dot-separated integers identifying the version of this extension.",
		$ref: "#/definitions/version_string"
	},
	default_locale: {
		type: "string",
		description: "Specifies the subdirectory of _locales that contains the default strings for this extension.",
		"default": "en"
	},
	description: {
		type: "string",
		description: "A plain text description of the extension",
		maxLength: 132
	},
	icons: {
		type: "object",
		description: "One or more icons that represent the extension, app, or theme. Recommended format: PNG; also BMP, GIF, ICO, JPEG.",
		minProperties: 1,
		properties: {
			"16": {
				$ref: "#/definitions/icon",
				description: "Used as the favicon for an extension's pages and infobar."
			},
			"48": {
				$ref: "#/definitions/icon",
				description: "Used on the extension management page (chrome://extensions)."
			},
			"128": {
				$ref: "#/definitions/icon",
				description: "Used during installation and in the Chrome Web Store."
			},
			"256": {
				$ref: "#/definitions/icon",
				description: "Used during installation and in the Chrome Web Store."
			}
		}
	},
	browser_action: {
		$ref: "#/definitions/action",
		description: "Use browser actions to put icons in the main Google Chrome toolbar, to the right of the address bar. In addition to its icon, a browser action can also have a tooltip, a badge, and a popup."
	},
	page_action: {
		$ref: "#/definitions/action",
		description: "Use the chrome.pageAction API to put icons inside the address bar. Page actions represent actions that can be taken on the current page, but that aren't applicable to all pages."
	},
	background: {
		type: "object",
		description: "The background page is an HTML page that runs in the extension process. It exists for the lifetime of your extension, and only one instance of it at a time is active.",
		properties: {
			persistent: {
				type: "boolean",
				description: "When false, makes the background page an event page (loaded only when needed).",
				"default": true
			},
			page: {
				$ref: "#/definitions/page",
				description: "Specify the HTML of the background page.",
				"default": "background.html"
			},
			scripts: {
				$ref: "#/definitions/scripts",
				description: "A background page will be generated by the extension system that includes each of the files listed in the scripts property.",
				"default": [
					"background.js"
				]
			}
		},
		dependencies: {
			page: {
				not: {
					required: [
						"scripts"
					]
				}
			},
			scripts: {
				not: {
					required: [
						"page"
					]
				}
			}
		}
	},
	chrome_url_overrides: {
		type: "object",
		description: "Override pages are a way to substitute an HTML file from your extension for a page that Google Chrome normally provides.",
		additionalProperties: false,
		maxProperties: 1,
		properties: {
			bookmarks: {
				$ref: "#/definitions/page",
				description: "The page that appears when the user chooses the Bookmark Manager menu item from the Chrome menu or, on Mac, the Bookmark Manager item from the Bookmarks menu. You can also get to this page by entering the URL chrome://bookmarks.",
				"default": "bookmarks.html"
			},
			history: {
				$ref: "#/definitions/page",
				description: "The page that appears when the user chooses the History menu item from the Chrome menu or, on Mac, the Show Full History item from the History menu. You can also get to this page by entering the URL chrome://history.",
				"default": "history.html"
			},
			newtab: {
				$ref: "#/definitions/page",
				description: "The page that appears when the user creates a new tab or window. You can also get to this page by entering the URL chrome://newtab.",
				"default": "newtab.html"
			}
		}
	},
	commands: {
		type: "object",
		description: "Use the commands API to add keyboard shortcuts that trigger actions in your extension, for example, an action to open the browser action or send a command to the extension.",
		patternProperties: {
			".*": {
				$ref: "#/definitions/command"
			},
			"^_execute_browser_action$": {
				$ref: "#/definitions/command"
			},
			"^_execute_page_action$": {
				$ref: "#/definitions/command"
			}
		}
	},
	content_scripts: {
		type: "array",
		description: "Content scripts are JavaScript files that run in the context of web pages.",
		minItems: 1,
		uniqueItems: true,
		items: {
			type: "object",
			required: [
				"matches"
			],
			additionalProperties: false,
			properties: {
				matches: {
					type: "array",
					description: "Specifies which pages this content script will be injected into.",
					minItems: 1,
					uniqueItems: true,
					items: {
						$ref: "#/definitions/match_pattern"
					}
				},
				exclude_matches: {
					type: "array",
					description: "Excludes pages that this content script would otherwise be injected into.",
					uniqueItems: true,
					items: {
						$ref: "#/definitions/match_pattern"
					}
				},
				css: {
					type: "array",
					description: "The list of CSS files to be injected into matching pages. These are injected in the order they appear in this array, before any DOM is constructed or displayed for the page.",
					uniqueItems: true,
					items: {
						$ref: "#/definitions/uri"
					}
				},
				js: {
					$ref: "#/definitions/scripts",
					description: "The list of JavaScript files to be injected into matching pages. These are injected in the order they appear in this array."
				},
				run_at: {
					type: "string",
					description: "Controls when the files in js are injected.",
					"enum": [
						"document_start",
						"document_end",
						"document_idle"
					],
					"default": "document_idle"
				},
				all_frames: {
					type: "boolean",
					description: "Controls whether the content script runs in all frames of the matching page, or only the top frame.",
					"default": false
				},
				include_globs: {
					type: "array",
					description: "Applied after matches to include only those URLs that also match this glob. Intended to emulate the @include Greasemonkey keyword.",
					uniqueItems: true,
					items: {
						$ref: "#/definitions/glob_pattern"
					}
				},
				exclude_globs: {
					type: "array",
					description: "Applied after matches to exclude URLs that match this glob. Intended to emulate the @exclude Greasemonkey keyword.",
					uniqueItems: true,
					items: {
						$ref: "#/definitions/glob_pattern"
					}
				},
				match_about_blank: {
					type: "boolean",
					description: "Whether to insert the content script on about:blank and about:srcdoc.",
					"default": false
				}
			}
		}
	},
	content_security_policy: {
		$ref: "#/definitions/content_security_policy"
	},
	devtools_page: {
		$ref: "#/definitions/page",
		description: "A DevTools extension adds functionality to the Chrome DevTools. It can add new UI panels and sidebars, interact with the inspected page, get information about network requests, and more."
	},
	externally_connectable: {
		type: "object",
		description: "Declares which extensions, apps, and web pages can connect to your extension via runtime.connect and runtime.sendMessage.",
		items: {
			type: "object",
			additionalProperties: false,
			properties: {
				ids: {
					type: "array",
					items: {
						type: "string",
						description: "The IDs of extensions or apps that are allowed to connect. If left empty or unspecified, no extensions or apps can connect."
					}
				},
				matches: {
					type: "array",
					items: {
						type: "string",
						description: "The URL patterns for web pages that are allowed to connect. This does not affect content scripts. If left empty or unspecified, no web pages can connect."
					}
				},
				accepts_tls_channel_id: {
					type: "boolean",
					"default": false,
					description: "Indicates that the extension would like to make use of the TLS channel ID of the web page connecting to it. The web page must also opt to send the TLS channel ID to the extension via setting includeTlsChannelId to true in runtime.connect's connectInfo or runtime.sendMessage's options."
				}
			}
		}
	},
	file_browser_handlers: {
		type: "array",
		description: "You can use this API to enable users to upload files to your website.",
		minItems: 1,
		items: {
			type: "object",
			required: [
				"id",
				"default_title",
				"file_filters"
			],
			additionalProperties: false,
			properties: {
				id: {
					type: "string",
					description: "Used by event handling code to differentiate between multiple file handlers"
				},
				default_title: {
					type: "string",
					description: "What the button will display."
				},
				file_filters: {
					type: "array",
					description: "Filetypes to match.",
					minItems: 1,
					items: {
						type: "string"
					}
				}
			}
		}
	},
	homepage_url: {
		$ref: "#/definitions/uri",
		description: "The URL of the homepage for this extension."
	},
	incognito: {
		type: "string",
		description: "Specify how this extension will behave if allowed to run in incognito mode.",
		"enum": [
			"spanning",
			"split"
		],
		"default": "spanning"
	},
	input_components: {
		type: "array",
		description: "Allows your extension to handle keystrokes, set the composition, and manage the candidate window.",
		items: {
			type: "object",
			required: [
				"name",
				"type",
				"id",
				"description",
				"language",
				"layouts"
			],
			additionalProperties: false,
			properties: {
				name: {
					type: "string"
				},
				type: {
					type: "string"
				},
				id: {
					type: "string"
				},
				description: {
					type: "string"
				},
				language: {
					type: "string"
				},
				layouts: {
					type: "array"
				}
			}
		}
	},
	key: {
		type: "string",
		description: "This value can be used to control the unique ID of an extension, app, or theme when it is loaded during development."
	},
	minimum_chrome_version: {
		$ref: "#/definitions/version_string",
		description: "The version of Chrome that your extension, app, or theme requires, if any."
	},
	nacl_modules: {
		type: "array",
		description: "One or more mappings from MIME types to the Native Client module that handles each type.",
		minItems: 1,
		uniqueItems: true,
		items: {
			type: "object",
			required: [
				"path",
				"mime_type"
			],
			additionalProperties: false,
			properties: {
				path: {
					$ref: "#/definitions/uri",
					description: "The location of a Native Client manifest (a .nmf file) within the extension directory."
				},
				mime_type: {
					$ref: "#/definitions/mime_type",
					description: "The MIME type for which the Native Client module will be registered as content handler."
				}
			}
		}
	},
	oauth2: {
		type: "object",
		description: "Use the Chrome Identity API to authenticate users: the getAuthToken for users logged into their Google Account and the launchWebAuthFlow for users logged into a non-Google account.",
		required: [
			"client_id",
			"scopes"
		],
		additionalProperties: false,
		properties: {
			client_id: {
				type: "string",
				description: "You need to register your app in the Google APIs Console to get the client ID."
			},
			scopes: {
				type: "array",
				minItems: 1,
				items: {
					type: "string"
				}
			}
		}
	},
	offline_enabled: {
		type: "boolean",
		description: "Whether the app or extension is expected to work offline. When Chrome detects that it is offline, apps with this field set to true will be highlighted on the New Tab page."
	},
	omnibox: {
		type: "object",
		description: "The omnibox API allows you to register a keyword with Google Chrome's address bar, which is also known as the omnibox.",
		required: [
			"keyword"
		],
		additionalProperties: false,
		properties: {
			keyword: {
				type: "string",
				description: "The keyward that will trigger your extension."
			}
		}
	},
	optional_permissions: {
		$ref: "#/definitions/permissions",
		description: "Use the chrome.permissions API to request declared optional permissions at run time rather than install time, so users understand why the permissions are needed and grant only those that are necessary."
	},
	options_page: {
		$ref: "#/definitions/page",
		description: "To allow users to customize the behavior of your extension, you may wish to provide an options page. If you do, a link to it will be provided from the extensions management page at chrome://extensions. Clicking the Options link opens a new tab pointing at your options page.",
		"default": "options.html"
	},
	options_ui: {
		type: "object",
		description: "To allow users to customize the behavior of your extension, you may wish to provide an options page. If you do, an Options link will be shown on the extensions management page at chrome://extensions which opens a dialogue containing your options page.",
		required: [
			"page"
		],
		properties: {
			page: {
				type: "string",
				description: "The path to your options page, relative to your extension's root."
			},
			chrome_style: {
				type: "boolean",
				"default": true,
				description: "If true, a Chrome user agent stylesheet will be applied to your options page. The default value is false, but we recommend you enable it for a consistent UI with Chrome."
			},
			open_in_tab: {
				type: "boolean",
				"default": false,
				description: "If true, your extension's options page will be opened in a new tab rather than embedded in chrome://extensions. The default is false, and we recommend that you don't change it. This is only useful to delay the inevitable deprecation of the old options UI! It will be removed soon, so try not to use it. It will break."
			}
		}
	},
	permissions: {
		$ref: "#/definitions/permissions",
		description: "Permissions help to limit damage if your extension or app is compromised by malware. Some permissions are also displayed to users before installation, as detailed in Permission Warnings."
	},
	host_permissions: {
		type: "array",
		items: {
			type: "string"
		}
	},
	requirements: {
		type: "object",
		description: "Technologies required by the app or extension. Hosting sites such as the Chrome Web Store may use this list to dissuade users from installing apps or extensions that will not work on their computer.",
		additionalProperties: false,
		properties: {
			"3D": {
				type: "object",
				description: "The '3D' requirement denotes GPU hardware acceleration.",
				required: [
					"features"
				],
				additionalProperties: false,
				properties: {
					features: {
						type: "array",
						description: "List of the 3D-related features your app requires.",
						minItems: 1,
						uniqueItems: true,
						items: {
							type: "string",
							"enum": [
								"webgl"
							]
						}
					}
				}
			},
			plugins: {
				type: "object",
				description: "Indicates if an app or extension requires NPAPI to run. This requirement is enabled by default when the manifest includes the 'plugins' field.",
				required: [
					"npapi"
				],
				additionalProperties: false,
				properties: {
					npapi: {
						type: "boolean",
						"default": true
					}
				}
			}
		}
	},
	sandbox: {
		type: "object",
		description: "Defines an collection of app or extension pages that are to be served in a sandboxed unique origin, and optionally a Content Security Policy to use with them.",
		required: [
			"pages"
		],
		additionalProperties: false,
		properties: {
			pages: {
				type: "array",
				minItems: 1,
				uniqueItems: true,
				items: {
					$ref: "#/definitions/page"
				}
			},
			content_security_policy: {
				$ref: "#/definitions/content_security_policy",
				"default": "sandbox allow-scripts allow-forms"
			}
		}
	},
	short_name: {
		type: "string",
		description: "The short name is typically used where there is insufficient space to display the full name.",
		maxLength: 12
	},
	update_url: {
		$ref: "#/definitions/uri",
		description: "If you publish using the Chrome Developer Dashboard, ignore this field. If you bridge your own extension or app: URL to an update manifest XML file."
	},
	tts_engine: {
		type: "object",
		description: "Register itself as a speech engine.",
		required: [
			"voices"
		],
		additionalProperties: false,
		properties: {
			voices: {
				type: "array",
				description: "Voices the extension can synthesize.",
				minItems: 1,
				uniqueItems: true,
				items: {
					type: "object",
					required: [
						"voice_name",
						"event_types"
					],
					additionalProperties: false,
					properties: {
						voice_name: {
							type: "string",
							description: "Identifies the name of the voice and the engine used."
						},
						lang: {
							type: "string",
							description: "Almost always, a voice can synthesize speech in just a single language. When an engine supports more than one language, it can easily register a separate voice for each language."
						},
						gender: {
							type: "string",
							description: "If your voice corresponds to a male or female voice, you can use this parameter to help clients choose the most appropriate voice for their application."
						},
						event_types: {
							type: "array",
							description: "Events sent to update the client on the progress of speech synthesis.",
							minItems: 1,
							uniqueItems: true,
							items: {
								type: "string",
								description: "",
								"enum": [
									"start",
									"word",
									"sentence",
									"marker",
									"end",
									"error"
								]
							}
						}
					}
				}
			}
		}
	},
	version_name: {
		type: "string",
		description: "In addition to the version field, which is used for update purposes, version_name can be set to a descriptive version string and will be used for display purposes if present."
	},
	web_accessible_resources: {
		type: "array",
		description: "An array of strings specifying the paths (relative to the package root) of packaged resources that are expected to be usable in the context of a web page.",
		minItems: 1,
		uniqueItems: true,
		items: {
			type: "object",
			additionalProperties: false,
			properties: {
				resources: {
					type: "array",
					description: "",
					items: {
						type: "string"
					}
				},
				matches: {
					type: "array",
					description: "",
					items: {
						type: "string"
					}
				},
				extension_ids: {
					type: "array",
					description: "",
					items: {
						type: "string"
					}
				},
				use_dynamic_url: {
					type: "boolean",
					description: ""
				}
			}
		}
	},
	chrome_settings_overrides: {
	},
	content_pack: {
	},
	current_locale: {
	},
	"import": {
	},
	platforms: {
	},
	signature: {
	},
	spellcheck: {
	},
	storage: {
	},
	system_indicator: {
	}
};
var dependencies = {
	page_action: {
		not: {
			required: [
				"browser_action"
			]
		}
	},
	browser_action: {
		not: {
			required: [
				"page_action"
			]
		}
	},
	content_scripts: {
		not: {
			required: [
				"script_badge"
			]
		}
	},
	script_badge: {
		not: {
			required: [
				"content_scripts"
			]
		}
	}
};
var definitions = {
	action: {
		type: "object",
		properties: {
			default_title: {
				type: "string",
				description: "Tooltip for the main toolbar icon."
			},
			default_popup: {
				$ref: "#/definitions/uri",
				description: "The popup appears when the user clicks the icon."
			},
			default_icon: {
				anyOf: [
					{
						type: "string",
						description: "FIXME: String form is deprecated."
					},
					{
						type: "object",
						description: "Icon for the main toolbar.",
						properties: {
							"19": {
								$ref: "#/definitions/icon"
							},
							"38": {
								$ref: "#/definitions/icon"
							}
						}
					}
				]
			}
		},
		dependencies: {
			name: {
				not: {
					required: [
						"name"
					]
				}
			},
			icons: {
				not: {
					required: [
						"icons"
					]
				}
			},
			popup: {
				not: {
					required: [
						"popup"
					]
				}
			}
		}
	},
	command: {
		type: "object",
		additionalProperties: false,
		properties: {
			description: {
				type: "string"
			},
			suggested_key: {
				type: "object",
				additionalProperties: false,
				patternProperties: {
					"^(default|mac|windows|linux|chromeos)$": {
						type: "string",
						pattern: "^(Ctrl|Command|MacCtrl|Alt|Option)\\+(Shift\\+)?[A-Z]"
					}
				}
			}
		}
	},
	content_security_policy: {
		type: "string",
		description: "This introduces some fairly strict policies that will make extensions more secure by default, and provides you with the ability to create and enforce rules governing the types of content that can be loaded and executed by your extensions and applications.",
		"default": "script-src 'self'; object-src 'self'"
	},
	glob_pattern: {
		type: "string"
	},
	icon: {
		$ref: "#/definitions/uri"
	},
	match_pattern: {
		type: "string",
		pattern: "^((\\*|http|https|file|ftp|chrome-extension):\\/\\/(\\*|\\*\\.[^\\/\\*]+|[^\\/\\*]+)?(\\/.*))|<all_urls>$"
	},
	mime_type: {
		type: "string",
		pattern: "^(?:application|audio|image|message|model|multipart|text|video)\\/[-+.\\w]+$"
	},
	page: {
		$ref: "#/definitions/uri"
	},
	permissions: {
		type: "array",
		uniqueItems: true,
		items: {
			type: "string"
		}
	},
	scripts: {
		type: "array",
		minItems: 1,
		uniqueItems: true,
		items: {
			$ref: "#/definitions/uri"
		}
	},
	uri: {
		type: "string"
	},
	version_string: {
		type: "string",
		pattern: "^(?:\\d{1,5}\\.){0,3}\\d{1,5}$"
	}
};
var manifestSchema = {
	title: title,
	$schema: $schema,
	type: type,
	additionalProperties: additionalProperties,
	required: required,
	properties: properties,
	dependencies: dependencies,
	definitions: definitions
};

class ValidationError extends Error {
    constructor(msg, errors) {
        super(msg);
        this.name = "ValidationError";
        this.errors = errors;
    }
    
}

// const jsonSchema = readJSONSync(
//   resolve(__dirname, 'json-schema-draft-04.json'),
// )

// const manifestSchema = readJSONSync(
//   resolve(__dirname, 'schema-web-ext-manifest-v3.json'),
// )

const ajv = new Ajv__default['default']({
    verbose: true,
    schemaId: "auto",
    schemas: {
        "http://json-schema.org/draft-04/schema#": jsonSchema,
    },
    strictDefaults: true,
});

// ajv.addMetaSchema(jsonSchema)

const validator = ajv.compile(manifestSchema);

const validateManifest = (
    manifest,
) => {
    if (validator(manifest)) { return manifest; }
    const { errors } = validator;
    const msg = "There were problems with the extension manifest.";
    console.error(errors);
    throw new ValidationError(msg, errors);
};

function reduceToRecord(srcDir) {
    if (srcDir === null || typeof srcDir === "undefined") {
        // This would be a config error, so should throw
        throw new TypeError("srcDir is null or undefined");
    }

    return (
        inputRecord,
        filename,
    ) => {
        const name = path.relative(srcDir, filename)
            .split(".")
            .slice(0, -1)
            .join(".");

        if (name in inputRecord) {
            throw new Error(
                `Script files with different extensions should not share names:\n\n"${filename}"\nwill overwrite\n"${inputRecord[name]}"`,
            );
        }

        return { ...inputRecord, [name]: filename };
    };
}

function getChunk(bundle) {
    return Object.keys(bundle)
        .filter(key => isChunk(bundle[key]))
        .reduce((b, k) => {
            b[k] = bundle[k] ;
            return b;
        }, {} );
}

function getAssets(bundle) {
    return Object.keys(bundle)
        .filter(key => isAsset(bundle[key]))
        .reduce((b, k) => {
            b[k] = bundle[k] ;
            return b;
        }, {} );
}

const explorer$1 = cosmiconfig.cosmiconfigSync("manifest", {
    cache: false,
});

const name = "manifest-input";

const npmPkgDetails =
    process.env.npm_package_name &&
        process.env.npm_package_version &&
        process.env.npm_package_description
        ? {
            name: process.env.npm_package_name,
            version: process.env.npm_package_version,
            description: process.env.npm_package_description,
        }
        : {
            name: "",
            version: "",
            description: "",
        };

/* ============================================ */
/*                MANIFEST-INPUT                */
/* ============================================ */

function manifestInput(
    {
        browserPolyfill = false,
        contentScriptWrapper = true,
        crossBrowser = false,
        dynamicImportWrapper = {},
        extendManifest = {},
        firstClassManifest = true,
        iifeJsonPaths = [],
        pkg = npmPkgDetails,
        publicKey,
        cache = {
            assetChanged: false,
            assets: [],
            iife: [],
            input: [],
            inputAry: [],
            inputObj: {},
            permsHash: "",
            readFile: new Map(),
            srcDir: null,
        } ,
    } = {} ,
) {

    /* ----------- HOOKS CLOSURES START ----------- */
    let manifestPath;
    /* ------------ HOOKS CLOSURES END ------------ */

    /* --------------- plugin object -------------- */
    return {
        name,

        browserPolyfill,
        crossBrowser,

        get srcDir() {
            return cache.srcDir;
        },

        get formatMap() {
            return { iife: cache.iife };
        },

        /* ============================================ */
        /*                 OPTIONS HOOK                 */
        /* ============================================ */

        options(options) {
            // Do not reload manifest without changes
            if (!cache.manifest) {
                /* ----------- LOAD AND PROCESS MANIFEST ----------- */
                let inputManifestPath;
                if (Array.isArray(options.input)) {
                    const manifestIndex = options.input.findIndex(
                        isJsonFilePath,
                    );
                    inputManifestPath = options.input[manifestIndex];
                    cache.inputAry = [
                        ...options.input.slice(0, manifestIndex),
                        ...options.input.slice(manifestIndex + 1),
                    ];
                } else if (typeof options.input === "object") {
                    inputManifestPath = options.input.manifest;
                    cache.inputObj = cloneObject(options.input);
                    delete cache.inputObj["manifest"];
                } else {
                    inputManifestPath = options.input;
                }

                if (!isJsonFilePath(inputManifestPath)) {
                    throw new TypeError(
                        "RollupOptions.input must be a single Chrome extension manifest.",
                    );
                }

                // Load content of manifest.json
                const configResult = explorer$1.load(
                    inputManifestPath,
                ) 



;
                if (configResult.isEmpty) {
                    throw new Error(`${options.input} is an empty file.`);
                }

                const { options_page, options_ui } = configResult.config;
                if (
                    options_page !== undefined &&
                    options_ui !== undefined
                ) {
                    throw new Error(
                        "options_ui and options_page cannot both be defined in manifest.json.",
                    );
                }

                manifestPath = configResult.filepath;

                if (typeof extendManifest === "function") {
                    cache.manifest = extendManifest(configResult.config);
                } else if (typeof extendManifest === "object") {
                    cache.manifest = {
                        ...configResult.config,
                        ...extendManifest,
                    };
                } else {
                    cache.manifest = configResult.config;
                }

                cache.srcDir = path__default['default'].dirname(manifestPath);

                if (firstClassManifest) {
                    cache.iife = iifeJsonPaths
                        .map((jsonPath) => {
                            const result = jsonpathPlus.JSONPath({
                                path: jsonPath,
                                json: cache.manifest,
                            });

                            return result;
                        })
                        .flat(Infinity);

                    // Derive entry paths from manifest
                    const { js, html, css, img, others } = deriveFiles$1(
                        cache.manifest,
                        cache.srcDir,
                    );

                    // Cache derived inputs
                    cache.input = [...cache.inputAry, ...js, ...html];

                    cache.assets = [
                        // Dedupe assets
                        ...new Set([...css, ...img, ...others]),
                    ];
                }

                /* --------------- END LOAD MANIFEST --------------- */
            }
            const finalInput = cache.input.reduce(
                reduceToRecord(cache.srcDir),
                cache.inputObj,
            );
            return { ...options, input: finalInput };
        },

        /* ============================================ */
        /*                GENERATEBUNDLE                */
        /* ============================================ */

        generateBundle(options, bundle) {
            /* ----------------- GET CHUNKS -----------------*/
            const chunks = getChunk(bundle);
            const assets = getAssets(bundle);

            if (Object.keys(bundle).length === 0) {
                throw new Error(
                    "The manifest must have at least one asset (html or css) or script file.",
                );
            }

            try {
                // Clone cache.manifest
                if (!cache.manifest)
                    // This is a programming error, so it should throw
                    throw new TypeError(`cache.manifest is ${typeof cache.manifest}`);

                const clonedManifest = cloneObject(cache.manifest);

                const manifestBody = validateManifest({
                    description: pkg.description,
                    ...clonedManifest,
                    permissions: combinePerms(
                        clonedManifest.permissions || [],
                    ),
                } );

                const {
                    content_scripts: cts = [],
                    web_accessible_resources: war = [],
                    background: { service_worker: sw = "" } = {},
                } = manifestBody;
                /* ------------- SETUP CONTENT SCRIPTS ------------- */
                manifestBody.content_scripts = cts.map(
                    ({ js, ...rest }) => typeof js === "undefined"
                        ? rest
                        : {
                            js: js
                                .map(filename => getOutputFilenameFromChunk(path.join(cache.srcDir, filename), Object.values(chunks)))
                                .filter(filename => !!filename)
                                .map((p) => slash__default['default'](p)),
                            ...rest,
                        },
                );
                /* ------------ SETUP BACKGROUND SCRIPTS ----------- */
                if (sw && manifestBody.background && manifestBody.background.service_worker) {
                    // make background chunk output in the same directory as manifest.json
                    const chunk = findChunk(path.join(cache.srcDir, manifestBody.background.service_worker), chunks);
                    if (chunk) {
                        // remove original chunk
                        delete bundle[chunk.fileName];
                        // change background chunk output in the same directory as manifest.json
                        chunk.fileName = chunk.fileName.replace(/assets\//, "");
                        bundle[chunk.fileName] = chunk;
                        manifestBody.background.service_worker = chunk.fileName;
                    }
                }
                /* ------------ SETUP ASSETS IN WEB ACCESSIBLE RESOURCES ----------- */
                manifestBody.web_accessible_resources = [
                    ...war, {
                    resources: Object.keys(assets),
                    matches: ["<all_urls>"]
                }];
                /* --------- STABLE EXTENSION ID -------- */
                if (publicKey) manifestBody.key = publicKey;
                /* ----------- OUTPUT MANIFEST.JSON ---------- */
                generateManifest(this, manifestBody);
            } catch (error) {
                // Catch here because we need the validated result in scope
                if (error.name !== "ValidationError") throw error;
                const errors = error.errors ;
                if (errors) {
                    errors.forEach((err) => {
                        // FIXME: make a better validation error message
                        // https://github.com/atlassian/better-ajv-errors
                        this.warn(JSON.stringify(err, undefined, 2));
                    });
                }
                this.error(error.message);
            }
        },
    };
}

function logInputFiles(entries) {
    console.log("\x1B[36m%s", "\nFind entry files");
    if (!entries) {
        console.log("\x1B[33m%s\x1B[0m", "Empty entry files.");
    }
    if (typeof entries === "string") {
        console.log("\x1B[32m%s\x1B[0m", entries);
    } else if (Array.isArray(entries)) {
        entries.forEach(input => {
            console.log("\x1B[32m%s\x1B[0m", input);
        });
    } else {
        for (const alias in entries) {
            if (Object.prototype.hasOwnProperty.call(entries, alias)) {
                console.log("\x1B[0m%s: \x1B[32m%s\x1B[0m", alias, entries[alias]);
            }
        }
    }
    console.log();
}


const logger = {
    info: (msg) => console.log("\x1B[32m%s\x1B[0m", msg),
    error: (msg) => console.log("\x1B[31m%s\x1B[0m", msg),
    warn: (msg) => console.log("\x1B[33m%s\x1B[0m", msg),
    logInputFiles,
};

const validateNames = () => ({
    name: "validate-names",

    generateBundle(options, bundle) {
        const chunks = Object.values(bundle).filter(
            (x) => x.type === "chunk",
        );

        // Files cannot start with "_" in Chrome Extensions
        // Loop through each file and check for "_" in filename
        Object.keys(bundle)
            .filter((fileName) => fileName.startsWith("_"))
            .forEach((fileName) => {
                // Only replace first instance
                const regex = new RegExp(fileName);
                const fixed = fileName.slice(1);

                // Fix manifest
                const manifest = bundle["manifest.json"] ;
                manifest.source = manifest.source.replace(regex, fixed);

                // Change bundle key
                const chunk = bundle[fileName];
                delete bundle[fileName];
                bundle[fixed] = chunk;

                // Fix chunk
                chunk.fileName = fixed;

                // Find imports and fix
                chunks
                    .filter(({ imports }) => imports.includes(fileName))
                    .forEach((chunk) => {
                        // Fix imports list
                        chunk.imports = chunk.imports.map((i) =>
                            i === fileName ? fixed : i,
                        );
                        // Fix imports in code
                        chunk.code = chunk.code.replace(regex, fixed);
                    });
            });
    },
});

// /* ============================================ */
// /*                DERIVE MANIFEST               */
// /* ============================================ */

// export function deriveManifest(
//   manifest: ChromeExtensionManifest, // manifest.json
//   ...permissions: string[] | string[][] // will be combined with manifest.permissions
// ): ChromeExtensionManifest {
//   return validateManifest({
//     // SMELL: Is this necessary?
//     manifest_version: 2,
//     ...manifest,
//     permissions: combinePerms(permissions, manifest.permissions),
//   })
// }

/* -------------------------------------------- */
/*                 DERIVE FILES                 */
/* -------------------------------------------- */

function deriveFiles(
    manifest,
    srcDir,
) {
    // get resources from section web_accessible_resources
    const web_accessible_resources = get__default['default'](
        manifest,
        "web_accessible_resources",
        [] ,
    ).reduce((resource_paths, web_accessible_resource) =>
        web_accessible_resource.resources.reduce((r, x) => {
            if (glob__default['default'].hasMagic(x)) {
                const files = glob__default['default'].sync(x, { cwd: srcDir });
                return [...r, ...files.map((f) => f.replace(srcDir, ""))];
            } else {
                return [...r, x];
            }
        }, resource_paths),
    [] );

    /**
     * js files come from:
     *  - web_accessible_resources
     *  - background.service_worker
     *  - content_scripts
     */
    const js = [
        ...web_accessible_resources.filter((f) => /\.[jt]sx?$/.test(f)),
        get__default['default'](manifest, "background.service_worker"),
        ...get__default['default'](
            manifest,
            "content_scripts",
            [] ,
        ).reduce((r, { js = [] }) => [...r, ...js], [] ),
    ];

    /**
     * html files come from:
     *  - web_accessible_resources
     *  - options_page
     *  - options_ui.page
     *  - devtools_page
     *  - action.default_popup
     *  - chrome_url_overrides
     */
    const html = [
        ...web_accessible_resources.filter((f) => /\.html?$/.test(f)),
        get__default['default'](manifest, "options_page"),
        get__default['default'](manifest, "options_ui.page"),
        get__default['default'](manifest, "devtools_page"),
        get__default['default'](manifest, "action.default_popup"),
        ...Object.values(get__default['default'](manifest, "chrome_url_overrides", {})),
    ];

    /**
     * css files come from:
     *  - web_accessible_resources
     *  - content_scripts
     */
    const css = [
        ...web_accessible_resources.filter((f) => f.endsWith(".css")),
        ...get__default['default'](
            manifest,
            "content_scripts",
            [] ,
        ).reduce(
            (r, { css = [] }) => [...r, ...css],
            [] ,
        ),
    ];

    /**
     * action icons come from:
     *  - web_accessible_resources
     *  - content_scripts
     */
    const actionIconSet = new Set();
    const default_icons = get__default['default'](
        manifest,
        "action.default_icon",
        {} ,
    );
    if (typeof default_icons === "string") {
        actionIconSet.add(default_icons);
    } else {
        Object.values(default_icons).forEach((x) => actionIconSet.add(x));
    }

    /**
     * image files come from:
     *  - web_accessible_resources
     *  - action.default_icon
     *  - icons
     */
    const img = [
        ...actionIconSet,
        ...web_accessible_resources.filter((f) =>
            /\.(jpe?g|png|svg|tiff?|gif|webp|bmp|ico)$/i.test(f),
        ),
        ...Object.values(get__default['default'](manifest, "icons", {})),
    ];

    // Files like fonts, things that are not expected
    const others = diff__default['default'](web_accessible_resources, css, js, html, img);

    return {
        css: validate(css),
        js: validate(js),
        html: validate(html),
        img: validate(img),
        others: validate(others),
    };

    function validate(ary) {
        return [...new Set(ary.filter(isString))].map((x) =>
            path.join(srcDir, x),
        );
    }

    function isString(x) {
        return typeof x === "string";
    }
}

function removeFileExtension(filePath) {
    const index = filePath.lastIndexOf(".");
    return index > -1 ? filePath.substring(0, index) : filePath;
}

function flattenRollupInput(input) {
    let inputArray;
    if (typeof input === "string") {
        inputArray = [input];
    } else if (Array.isArray(input)) {
        inputArray = [...input];
    } else if (typeof input === "object") {
        inputArray = Object.values(input);
    } else {
        throw new TypeError(
            `options.input cannot be ${typeof input}`,
        );
    }
    return inputArray;
}

const cssUrlRE = /((?<=url *\( *' *)[^(data:)][^']+(?= *' *\))|(?<=url *\( *" *)[^(data:)][^"]+(?= *" *\))|(?<=url *\( *)[^(data:)][^'")]+(?= *\)))/g;

function replaceCssUrl(code) {
    const resources = new Set();
    const updatedCode = code.replace(cssUrlRE, (substring) => {
        const url = substring.trim();
        if (url) {
            resources.add(url);
            return "chrome-extension://" + slash__default['default'](path.join("__MSG_@@extension_id__", substring.trim()));
        } else {
            return "";
        }
    });
    return resources.size > 0
        ? { code: updatedCode, resources: Array.from(resources) }
        : { code: updatedCode };
}

function updateCss(asset) {
    if (typeof asset.source === "string") {
        // update url() in css
        const { code, resources } = replaceCssUrl(asset.source);
        asset.source = code;
        return { asset, resources };
    }
    return { asset };
}

function mixinPlugin(
    bundle,
) {
    return {
        name: "mixin",
        resolveId(source, importer) {
            try {
                if (typeof importer === "undefined") {
                    return source;
                } else {
                    const dir = path.dirname(importer);
                    const resolved = path.join(dir, source);
                    return resolved in bundle ? resolved : false;
                }
            } catch (error) {
                console.log("resolveId", error);
                return null;
            }
        },
        load(id) {
            const chunk = bundle[id] ;
            if (chunk) {
                // remove chunk from bundle
                if (Object.values(bundle).filter(c => c.type === "chunk" && c.imports.includes(chunk.fileName)).length < 1) {
                    delete bundle[id];
                }
                return {
                    code: chunk.code,
                    map: chunk.map,
                };
            } else {
                return null;
            }
        },
    }
}

/**
 * bundle entry chunk and its dependences into one IIFE chunk
 * this function will replace the entry chunk
 * @param context: context of parent rollup process
 * @param entry: chunk as entry point
 * @param bundle: chunks bundled by parent rollup process
 * @returns
 */
async function mixinChunksForIIFE(
    context,
    entry,
    bundle
) {
    const build = await rollup.rollup({
        input: entry.fileName,
        plugins: [mixinPlugin(bundle)]
    });
    const outputs = (await build.generate({ format: "iife" })).output;
    if (outputs.length < 1) {
        throw new Error("");
    } else if (outputs.length > 1) {
        throw new Error("mix content script chunks error: output must contain only one chunk.");
    }
    const outputChunk = outputs[0];
    const referenceId = context.emitFile({
        type: "asset",
        source: outputChunk.code,
        fileName: entry.fileName
    });
    return context.getFileName(referenceId);
}

class ContentScriptProcessor {
    constructor( options) {this.options = options;}
     async generateBundle(
        context,
        bundle,
        manifest,
    ) {
        for (const content_script of manifest.content_scripts || []) {
            const {js, css, ...rest} = content_script;
            if (typeof js === "undefined") { continue; }
            // process related css
            js.map(name => findAssetByName(`${removeFileExtension(name)}.css`, bundle) )
                .filter(asset => !!asset)
                .map(asset => {
                    const { asset: ast, resources } = updateCss(asset);
                    // add resource to web_accessible_resources
                    if (resources) {
                        const web_accessible_resources = {
                            resources,
                            matches: rest.matches
                        };
                        if (!manifest.web_accessible_resources) {
                            manifest.web_accessible_resources = [web_accessible_resources];
                        } else {
                            manifest.web_accessible_resources.push(web_accessible_resources);
                        }
                    }
                    return ast;
                })
                .forEach(asset => {
                    const cssFileName = slash__default['default'](asset.fileName);
                    if (css) {
                        css.push(cssFileName);
                    } else {
                        content_script.css = [cssFileName];
                    }
                });
            // mixin related js
            content_script.js = [];
            for (const jsName of js) {
                const chunk = findChunkByName(removeFileExtension(jsName), bundle);
                if (chunk) {
                    content_script.js.push(slash__default['default'](await mixinChunksForIIFE(context, chunk, bundle)));
                }
            }
        }
    }

     async generateBundleFromDynamicImports(
        context,
        bundle,
        dynamicImports,
    ) {
        for (const dynamicImport of dynamicImports) {
            const filename = context.getFileName(dynamicImport);
            const chunk = bundle[filename];
            if (chunk && chunk.type === "chunk") {
                await mixinChunksForIIFE(context, chunk, bundle);
            }
        }
    }
}

/* ============================================ */
/*               CHECK PERMISSIONS              */
/* ============================================ */

// export const debugger = s => /((chromep?)|(browser))[\s\n]*\.[\s\n]*debugger/.test(s)
// export const enterprise.deviceAttributes = s => /((chromep?)|(browser))[\s\n]*\.[\s\n]*enterprise\.deviceAttributes/.test(s)
// export const enterprise.hardwarePlatform = s => /((chromep?)|(browser))[\s\n]*\.[\s\n]*enterprise\.hardwarePlatform/.test(s)
// export const enterprise.platformKeys = s => /((chromep?)|(browser))[\s\n]*\.[\s\n]*enterprise\.platformKeys/.test(s)
// export const networking.config = s => /((chromep?)|(browser))[\s\n]*\.[\s\n]*networking\.config/.test(s)
// export const system.cpu = s => /((chromep?)|(browser))[\s\n]*\.[\s\n]*system\.cpu/.test(s)
// export const system.display = s => /((chromep?)|(browser))[\s\n]*\.[\s\n]*system\.display/.test(s)
// export const system.memory = s => /((chromep?)|(browser))[\s\n]*\.[\s\n]*system\.memory/.test(s)
// export const system.storage = s => /((chromep?)|(browser))[\s\n]*\.[\s\n]*system\.storage/.test(s)

const alarms = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*alarms/.test(s);

const bookmarks = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*bookmarks/.test(s);

const contentSettings = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*contentSettings/.test(s);

const contextMenus = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*contextMenus/.test(s);

const cookies = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*cookies/.test(s);

const declarativeContent = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*declarativeContent/.test(s);
const declarativeNetRequest = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*declarativeNetRequest/.test(s);
const declarativeWebRequest = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*declarativeWebRequest/.test(s);
const desktopCapture = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*desktopCapture/.test(s);
const displaySource = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*displaySource/.test(s);
const dns = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*dns/.test(s);
const documentScan = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*documentScan/.test(s);
const downloads = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*downloads/.test(s);
const experimental = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*experimental/.test(s);
const fileBrowserHandler = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*fileBrowserHandler/.test(s);
const fileSystemProvider = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*fileSystemProvider/.test(s);
const fontSettings = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*fontSettings/.test(s);
const gcm = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*gcm/.test(s);
const geolocation = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*geolocation/.test(s);
const history = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*history/.test(s);
const identity = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*identity/.test(s);
const idle = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*idle/.test(s);
const idltest = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*idltest/.test(s);
const management = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*management/.test(s);
const nativeMessaging = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*nativeMessaging/.test(s);
const notifications = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*notifications/.test(s);
const pageCapture = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*pageCapture/.test(s);
const platformKeys = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*platformKeys/.test(s);
const power = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*power/.test(s);
const printerProvider = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*printerProvider/.test(s);
const privacy = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*privacy/.test(s);
const processes = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*processes/.test(s);
const proxy = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*proxy/.test(s);
const sessions = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*sessions/.test(s);
const signedInDevices = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*signedInDevices/.test(s);
const storage = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*storage/.test(s);
const tabCapture = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*tabCapture/.test(s);
// export const tabs = s => /((chromep?)|(browser))[\s\n]*\.[\s\n]*tabs/.test(s)
const topSites = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*topSites/.test(s);
const tts = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*tts/.test(s);
const ttsEngine = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*ttsEngine/.test(s);
const unlimitedStorage = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*unlimitedStorage/.test(s);
const vpnProvider = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*vpnProvider/.test(s);
const wallpaper = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*wallpaper/.test(s);
const webNavigation = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*webNavigation/.test(s);
const webRequest = (s) =>
    /((chromep?)|(browser))[\s\n]*\.[\s\n]*webRequest/.test(s);
const webRequestBlocking = (s) =>
    webRequest(s) && s.includes("'blocking'");

// TODO: add readClipboard
// TODO: add writeClipboard

var permissions = /*#__PURE__*/Object.freeze({
    __proto__: null,
    alarms: alarms,
    bookmarks: bookmarks,
    contentSettings: contentSettings,
    contextMenus: contextMenus,
    cookies: cookies,
    declarativeContent: declarativeContent,
    declarativeNetRequest: declarativeNetRequest,
    declarativeWebRequest: declarativeWebRequest,
    desktopCapture: desktopCapture,
    displaySource: displaySource,
    dns: dns,
    documentScan: documentScan,
    downloads: downloads,
    experimental: experimental,
    fileBrowserHandler: fileBrowserHandler,
    fileSystemProvider: fileSystemProvider,
    fontSettings: fontSettings,
    gcm: gcm,
    geolocation: geolocation,
    history: history,
    identity: identity,
    idle: idle,
    idltest: idltest,
    management: management,
    nativeMessaging: nativeMessaging,
    notifications: notifications,
    pageCapture: pageCapture,
    platformKeys: platformKeys,
    power: power,
    printerProvider: printerProvider,
    privacy: privacy,
    processes: processes,
    proxy: proxy,
    sessions: sessions,
    signedInDevices: signedInDevices,
    storage: storage,
    tabCapture: tabCapture,
    topSites: topSites,
    tts: tts,
    ttsEngine: ttsEngine,
    unlimitedStorage: unlimitedStorage,
    vpnProvider: vpnProvider,
    wallpaper: wallpaper,
    webNavigation: webNavigation,
    webRequest: webRequest,
    webRequestBlocking: webRequestBlocking
});

/* ============================================ */
/*              DERIVE PERMISSIONS              */
/* ============================================ */
const derivePermissions = (
    set,
    { code },
) =>
    Object.entries(permissions)
        .filter(([, fn]) => fn(code))
        .map(([key]) => key)
        .reduce((s, p) => s.add(p), set);

class PermissionProcessorCache {constructor() { PermissionProcessorCache.prototype.__init.call(this);PermissionProcessorCache.prototype.__init2.call(this); }
     __init() {this.permsHash = "";}
     __init2() {this.assetChanged = false;}
}

class PermissionProcessorOptions {constructor() { PermissionProcessorOptions.prototype.__init3.call(this); }
     __init3() {this.verbose = true;}
}

class PermissionProcessor {
     __init4() {this.cache = new PermissionProcessorCache();}

     constructor( options) {this.options = options;PermissionProcessor.prototype.__init4.call(this);}

     derivePermissions(
        context,
        chunks,
        manifest,
    ) {
        let permissions;
        if (this.cache.assetChanged && this.cache.permsHash) {
            // Permissions did not change
            permissions = JSON.parse(this.cache.permsHash) ;
            this.cache.assetChanged = false;
        } else {
            // Permissions may have changed
            permissions = Array.from(
                Object.values(chunks).reduce(derivePermissions, new Set()));
            const permsHash = JSON.stringify(permissions);
            if (this.options.verbose && permissions.length) {
                if (!this.cache.permsHash) {
                    context.warn(
                        `Detected permissions: ${permissions.toString()}`,
                    );
                } else if (permsHash !== this.cache.permsHash) {
                    context.warn(
                        `Detected new permissions: ${permissions.toString()}`,
                    );
                }
            }
            this.cache.permsHash = permsHash;
        }
        // update permissions in manifest.json
        const updatedPermissions = new Set([...manifest.permissions || [], ...permissions]);
        if (updatedPermissions.size > 0) {
            manifest.permissions = Array.from(updatedPermissions);
        } else {
            delete manifest["permissions"];
        }
    }
}

function _optionalChain$1(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }


const dynamicImportAssetRex = /(?<=chrome.scripting.insertCSS\()[\s\S]*?(?=\))/gm;
const dynamicImportScriptRex = /(?<=chrome.scripting.executeScript\()[\s\S]*?(?=\))/gm;






class BackgroundProcesser {
    constructor( options) {this.options = options;}

     resolveDynamicImports(context, code) {
        if (!this.options.srcDir) {
            throw new TypeError("BackgroundProcesser: options.srcDir is not initialized");
        }
        /* ----------------- PROCESS DYNAMICALLY IMPORTED ASSETS -----------------*/
        _optionalChain$1([code, 'access', _ => _.match, 'call', _2 => _2(dynamicImportAssetRex)
, 'optionalAccess', _3 => _3.map, 'call', _4 => _4(m => m.match(/(?<=(files:\[)?\")[\s\S]*?(?=\]?\")/gm))
, 'access', _5 => _5.reduce, 'call', _6 => _6((f, m) => f.concat(...(m || [])) || [], [] )
, 'access', _7 => _7.map, 'call', _8 => _8(m => { console.log("resolveDynamicImports", m); return m; })
, 'access', _9 => _9.forEach, 'call', _10 => _10(m => {
                const filePath = path.resolve(this.options.srcDir, m);
                if (fs$1.existsSync(filePath)) {
                    context.emitFile({
                        type: "asset",
                        fileName: m,
                        source: fs$1.readFileSync(filePath),
                    });
                }
            })]);
        /* ----------------- PROCESS DYNAMICALLY IMPORTED SCRIPTS -----------------*/
        // dynamicImports collects files used by chrome.scripting.executeScript
        const dynamicImports = [];
        const updatedCode = code.replace(
            dynamicImportScriptRex,
            match => match.replace(/(?<=(files:\[)?)\"[\s\S]*?\"(?=\]?)/gm, fileStr => {
                const file = path.parse(fileStr.replace(/\"/g, "").trim());
                const filePath = path.resolve(this.options.srcDir, file.dir, file.base);
                if (fs$1.existsSync(filePath)) {
                    const referenceId = context.emitFile({
                        id: filePath,
                        type: "chunk",
                        name: path.join(file.dir, file.name)
                    });
                    dynamicImports.push(referenceId);
                    return `import.meta.ROLLUP_FILE_URL_${referenceId}`;
                } else {
                    return fileStr;
                }
            })
        );
        return { code: updatedCode, imports: dynamicImports };
    }

     async generateBundle(
        context,
        bundle,
        manifest
    ) {
        if (_optionalChain$1([manifest, 'access', _11 => _11.background, 'optionalAccess', _12 => _12.service_worker])) {
            // make background chunk output in the same directory as manifest.json
            const chunk = findChunkByName(removeFileExtension(manifest.background.service_worker), bundle);
            if (chunk) {
                // mixin all dependent chunks
                // change background chunk output in the same directory as manifest.json
                chunk.fileName = chunk.fileName.replace(/assets\//, "");
                manifest.background.service_worker = slash__default['default'](await mixinChunksForIIFE(context, chunk, bundle));
            }
        }
    }
}

const explorer = cosmiconfig.cosmiconfigSync("manifest", {
    cache: false,
});











class ManifestProcessor {
     __init() {this.cache = {
        assetChanged: false,
        assets: [],
        iife: [],
        input: [],
        inputAry: [],
        inputObj: {},
        dynamicImportContentScripts: [],
        permsHash: "",
        readFile: new Map(),
        srcDir: null,
    }; }
    
    
    
    

     constructor( options = {} ) {this.options = options;ManifestProcessor.prototype.__init.call(this);ManifestProcessor.prototype.__init2.call(this);
        this.contentScriptProcessor = new ContentScriptProcessor(options);
        this.permissionProcessor = new PermissionProcessor(new PermissionProcessorOptions());
        this.backgroundProcessor = new BackgroundProcesser(options);
    }

    /**
     * Load content from manifest.json
     * @param options: rollup input options
     */
     load(options) {
        /* --------------- GET MANIFEST.JSON PATH --------------- */
        const inputManifestPath = this.resolveManifestPath(options);
        /* --------------- LOAD CONTENT FROM MANIFEST.JSON --------------- */
        const configResult = explorer.load(inputManifestPath) ;
        /* --------------- VALIDATE MANIFEST.JSON CONTENT --------------- */
        this.validateManifestContent(configResult);
        /* --------------- APPLY USER CUSTOM CONFIG --------------- */
        this.manifest = this.applyExternalManifestConfiguration(configResult);
        /* --------------- RECORD OPTIONS --------------- */
        this.options.manifestPath = configResult.filepath;
        this.options.srcDir = path.dirname(this.options.manifestPath);
        return this.manifest;
    }

    /**
     * Resolve input files for rollup
     * @param input: Input not in manifest.json but specify by user
     * @returns
     */
     resolveInput(input)

 {
        if (!this.manifest || !this.options.srcDir) {
            throw new TypeError("manifest and options.srcDir not initialized");
        }
        // Derive all static resources from manifest
        // Dynamic entries will emit in transform hook
        const { js, html, css, img, others } = deriveFiles(
            this.manifest,
            this.options.srcDir,
        );
        // Cache derived inputs
        this.cache.input = [...this.cache.inputAry, ...js, ...html];
        this.cache.assets = [...new Set([...css, ...img, ...others])];
        const inputs = this.cache.input.reduce(
            reduceToRecord(this.options.srcDir),
            this.cache.inputObj);
        return inputs;
    }

     transform(context, code, id, ssr) {
        const { code:updatedCode, imports } = this.backgroundProcessor.resolveDynamicImports(context, code);
        this.cache.dynamicImportContentScripts.push(...imports);
        return updatedCode;
    }

     isDynamicImportedContentScript(referenceId) {
        return this.cache.dynamicImportContentScripts.includes(referenceId);
    }

    /**
     * Add watch files
     * @param context Rollup Plugin Context
     */
     addWatchFiles(context) {
        // watch manifest.json file
        context.addWatchFile(this.options.manifestPath);
        // watch asset files
        this.cache.assets.forEach(srcPath => context.addWatchFile(srcPath));
    }

     async emitFiles(context) {
        // Copy asset files
        const assets = await Promise.all(
            this.cache.assets.map(async (srcPath) => {
                const source = await this.readAssetAsBuffer(srcPath);
                return {
                    type: "asset" ,
                    source,
                    fileName: path.relative(this.options.srcDir, srcPath),
                };
            }),
        );
        assets.forEach((asset) => {
            context.emitFile(asset);
        });
    }

     clearCacheById(id) {
        if (id.endsWith(manifestName)) {
            // Dump cache.manifest if manifest changes
            delete this.manifest;
            this.cache.assetChanged = false;
        } else {
            // Force new read of changed asset
            this.cache.assetChanged = this.cache.readFile.delete(id);
        }
    }

     async generateBundle(context, bundle) {
        if (!this.manifest) { throw new Error("[generate bundle] Manifest cannot be empty"); }
        /* ----------------- GET CHUNKS -----------------*/
        const chunks = getChunk(bundle);
        getAssets(bundle);
        /* ----------------- UPDATE PERMISSIONS ----------------- */
        this.permissionProcessor.derivePermissions(context, chunks, this.manifest);
        /* ----------------- UPDATE CONTENT SCRIPTS ----------------- */
        await this.contentScriptProcessor.generateBundle(context, bundle, this.manifest);
        await this.contentScriptProcessor.generateBundleFromDynamicImports(context, bundle, this.cache.dynamicImportContentScripts);
        /* ----------------- SETUP BACKGROUND SCRIPTS ----------------- */
        await this.backgroundProcessor.generateBundle(context, bundle, this.manifest);
        /* ----------------- SETUP ASSETS IN WEB ACCESSIBLE RESOURCES ----------------- */

        /* ----------------- STABLE EXTENSION ID ----------------- */
        /* ----------------- OUTPUT MANIFEST.JSON ----------------- */
        /* ----------- OUTPUT MANIFEST.JSON ---------- */
        this.generateManifest(context, this.manifest);
        // validate manifest
        this.validateManifest();
    }

     resolveManifestPath(options) {
        if (!options.input) {
            console.log(chalk__default['default'].red("No input is provided."));
            throw new Error("No input is provided.")
        }
        let inputManifestPath;
        if (Array.isArray(options.input)) {
            const manifestIndex = options.input.findIndex(i => path.basename(i) === "manifest.json");
            if (manifestIndex > -1) {
                inputManifestPath = options.input[manifestIndex];
                this.cache.inputAry = options.input.splice(manifestIndex, 1);
            } else {
                console.log(chalk__default['default'].red("RollupOptions.input array must contain a Chrome extension manifest with filename 'manifest.json'."));
                throw new Error("RollupOptions.input array must contain a Chrome extension manifest with filename 'manifest.json'.");
            }
        } else if (typeof options.input === "object") {
            if (options.input.manifest) {
                inputManifestPath = options.input.manifest;
                delete options.input["manifest"];
                this.cache.inputObj = cloneObject(options.input);
            } else {
                console.log(chalk__default['default'].red("RollupOptions.input object must contain a Chrome extension manifest with Key manifest."));
                throw new Error("RollupOptions.input object must contain a Chrome extension manifest with Key manifest.");
            }
        } else {
            inputManifestPath = options.input;
            delete options.input;
        }
        /* --------------- VALIDATE MANIFEST.JSON PATH --------------- */
        if (path.basename(inputManifestPath) !== "manifest.json") {
            throw new TypeError("Input for a Chrome extension manifest must have filename 'manifest.json'.");
        }
        return inputManifestPath;
    }

     validateManifestContent(config) {
        if (config.isEmpty) {
            throw new Error(`${config.filepath} is an empty file.`);
        }
        const { options_page, options_ui } = config.config;
        if (
            options_page !== undefined &&
            options_ui !== undefined
        ) {
            throw new Error(
                "options_ui and options_page cannot both be defined in manifest.json.",
            );
        }
    }

     validateManifest() {
        if (this.manifest) {
            validateManifest(this.manifest);
        } else {
            throw new Error("Manifest cannot be empty");
        }
    }

     applyExternalManifestConfiguration(
        config
    ) {
        if (typeof this.options.extendManifest === "function") {
            return this.options.extendManifest(config.config);
        } else if (typeof this.options.extendManifest === "object") {
            return {
                ...config.config,
                ...this.options.extendManifest,
            };
        } else {
            return config.config;
        }
    }

     __init2() {this.readAssetAsBuffer = memoize__default['default'](
        (filepath) => {
            return fs__default['default'].readFile(filepath);
        },
        {
            cache: this.cache.readFile,
        },
    );}

     generateManifest(
        context,
        manifest,
    ) {
        const manifestJson = JSON.stringify(manifest, null, 4)
            // SMELL: is this necessary?
            .replace(/\.[jt]sx?"/g, '.js"');
        // Emit manifest.json
        context.emitFile({
            type: "asset",
            fileName: manifestName,
            source: manifestJson,
        });
    }
}

const isHtml = (path) => /\.html?$/.test(path);

class HtmlProcessor {
     __init() {this.cache = {
        scripts: [],
        html: [],
        html$: [],
        js: [],
        css: [],
        img: [],
        input: [],
    }; }

    constructor( options) {this.options = options;HtmlProcessor.prototype.__init.call(this); }

     resolveInput(input) {
        // srcDir may be initialized by another plugin
        const { srcDir } = this.options;
        if (srcDir) {
            this.cache.srcDir = srcDir;
        } else {
            throw new TypeError("options.srcDir not initialized");
        }

        // Skip if cache.input exists
        // cache is dumped in watchChange hook

        // Flatten input to array
        const inputArray = flattenRollupInput(input);

        /* ------------------------------------------------- */
        /*                 HANDLE HTML FILES                 */
        /* ------------------------------------------------- */

        // Filter htm and html files
        this.cache.html = inputArray.filter(isHtml);

        // If no html files, do nothing
        if (this.cache.html.length === 0) return input;

        // If the cache has been dumped, reload from files
        if (this.cache.html$.length === 0) {
            // This is all done once
            this.cache.html$ = this.cache.html.map(loadHtml(srcDir));
            this.cache.js = flatten__default['default'](this.cache.html$.map(getScriptSrc));
            this.cache.css = flatten__default['default'](this.cache.html$.map(getCssHrefs));
            this.cache.img = flatten__default['default'](this.cache.html$.map(getImgSrcs));
            this.cache.scripts = flatten__default['default'](this.cache.html$.map(getJsAssets));

            // Remove HTML files from input
            // Cache jsEntries with existing input
            this.cache.input = inputArray.filter(not(isHtml)).concat(this.cache.js);

            if (this.cache.input.length === 0) {
                throw new Error("At least one HTML file must have at least one script.");
            }
        }

        // - Parse HTML and emit chunks and assets in buildStart
        return this.cache.input.reduce(reduceToRecord(srcDir), {});
    }

     addWatchFiles(context) {
        [
            ...this.cache.css,
            ...this.cache.img,
            ...this.cache.scripts,
            ...this.cache.html,
        ].concat(this.cache.html).forEach((asset) => {
            context.addWatchFile(asset);
        });
    }

     generateBundle(context, bundle) {
        if (!this.options.srcDir) { throw new TypeError("[html] options.srcDir not initialized"); }
        const chunks = Object.values(bundle).filter(isChunk);

        this.cache.html$.map($ => this.replaceImportScriptPath($, chunks, this.options.srcDir, this.options.browserPolyfill))
            .map($ => {
                const source = formatHtml($);
                const fileName = path.relative(this.options.srcDir, $.filePath);
                context.emitFile({
                    type: "asset",
                    source,
                    fileName,
            });
        });
    }

    /**
     * Output asset files in html
     * css, img, script(not local import)
     */
     async emitFiles(context) {
        const assets = [
            ...this.cache.css,
            ...this.cache.img,
            ...this.cache.scripts,
        ];
        const emitting = assets.map(async (asset) => {
            // Read these files as Buffers
            const source = await fs.readFile(asset);
            const fileName = path.relative(this.options.srcDir, asset);
            context.emitFile({
                type: "asset",
                source, // Buffer
                fileName,
            });
        });
        await Promise.all(emitting);
    }

     clearCacheById(id) {
        if (id.endsWith(".html") || id.endsWith("manifest.json")) {
            // Dump cache if html file or manifest changes
            this.cache.html$ = [];
        }
    }

     replaceImportScriptPath(
        $,
        chunks,
        srcDir,
        browserPolyfill,
    ) {
        getScriptElems($)
            .attr("type", "module")
            .attr("src", (i, value) => {
                const basePath = path.dirname($.filePath);
                const chunkName = getOutputFilenameFromChunk(path.resolve(basePath, value ), chunks);
                return path.relative(basePath, path.resolve(srcDir, chunkName));
            });

        if (browserPolyfill) {
            const head = $("head");
            if (
                browserPolyfill === true ||
                (typeof browserPolyfill === "object" &&
                    browserPolyfill.executeScript)
            ) {
                head.prepend(
                    '<script src="/assets/browser-polyfill-executeScript.js"></script>',
                );
            }

            head.prepend(
                '<script src="/assets/browser-polyfill.js"></script>',
            );
        }

        return $;
    }
}

const code$1 = "(function () {\n  'use strict';\n\n  /* ------------------- FILENAMES ------------------- */\r\n\r\n  /* ------------------ PLACEHOLDERS ----------------- */\r\n\r\n  const timestampPathPlaceholder = \"%TIMESTAMP_PATH%\";\r\n  const loadMessagePlaceholder = \"%LOAD_MESSAGE%\";\r\n  const ctScriptPathPlaceholder = \"%CONTENT_SCRIPT_PATH%\";\r\n  const unregisterServiceWorkersPlaceholder = \"%UNREGISTER_SERVICE_WORKERS%\";\r\n  const executeScriptPlaceholder = \"%EXECUTE_SCRIPT%\";\n\n  /* eslint-env browser */\r\n\r\n  // Log load message to browser dev console\r\n  console.log(loadMessagePlaceholder.slice(1, -1));\r\n\r\n  const options = {\r\n    executeScript: JSON.parse(executeScriptPlaceholder),\r\n    unregisterServiceWorkers: JSON.parse(\r\n      unregisterServiceWorkersPlaceholder,\r\n    ),\r\n  };\r\n\r\n  /* ---------- POLYFILL TABS.EXECUTESCRIPT ---------- */\r\n\r\n  if (options.executeScript) {\r\n    const markerId =\r\n      'rollup-plugin-chrome-extension-simple-reloader';\r\n\r\n    const addMarker = `{\r\n    const tag = document.createElement('meta');\r\n    tag.id = '${markerId}';\r\n    document.head.append(tag);\r\n  }`;\r\n\r\n    const checkMarker = `\r\n  !!document.head.querySelector('#${markerId}')\r\n  `;\r\n\r\n    // Modify chrome.tabs.executeScript to inject reloader\r\n    const _executeScript = chrome.tabs.executeScript;\r\n    const withP = (...args) =>\r\n      new Promise((resolve, reject) => {\r\n        // eslint-disable-next-line\r\n        // @ts-ignore\r\n        _executeScript(...args, (results) => {\r\n          if (chrome.runtime.lastError) {\r\n            reject(chrome.runtime.lastError.message);\r\n          } else {\r\n            resolve(results);\r\n          }\r\n        });\r\n      });\r\n\r\n    chrome.tabs.executeScript = (...args) => {\r\n  (async () => {\r\n        const tabId = typeof args[0] === 'number' ? args[0] : null;\r\n        const argsBase = (tabId === null ? [] : [tabId]); \r\n\r\n        const [done] = await withP(\r\n          ...(argsBase.concat({ code: checkMarker }) \r\n\r\n\r\n  ),\r\n        );\r\n\r\n        // Don't add reloader if it's already there\r\n        if (!done) {\r\n          await withP(\r\n            ...(argsBase.concat({ code: addMarker }) \r\n\r\n\r\n  ),\r\n          );\r\n\r\n          // execute reloader\r\n          const reloaderArgs = argsBase.concat([\r\n            // TODO: convert to file to get replacements right\r\n            { file: JSON.parse(ctScriptPathPlaceholder) },\r\n          ]); \r\n\r\n          await withP(...reloaderArgs);\r\n        }\r\n\r\n        _executeScript(...(args ));\r\n      })();\r\n    };\r\n  }\r\n\r\n  /* ----------- UNREGISTER SERVICE WORKERS ---------- */\r\n\r\n  if (options.unregisterServiceWorkers) {\r\n    // Modify chrome.runtime.reload to unregister sw's\r\n    const _runtimeReload = chrome.runtime.reload;\r\n    chrome.runtime.reload = () => {\r\n  (async () => {\r\n        await unregisterServiceWorkers();\r\n        _runtimeReload();\r\n      })();\r\n    };\r\n  }\r\n\r\n  async function unregisterServiceWorkers() {\r\n    try {\r\n      const registrations = await navigator.serviceWorker.getRegistrations();\r\n      await Promise.all(registrations.map((r) => r.unregister()));\r\n    } catch (error) {\r\n      console.error(error);\r\n    }\r\n  }\r\n\r\n  /* -------------- CHECK TIMESTAMP.JSON ------------- */\r\n\r\n  let timestamp;\r\n\r\n  const id = setInterval(async () => {\r\n    const t = await fetch(timestampPathPlaceholder)\r\n      .then((res) => {\r\n        localStorage.removeItem('chromeExtensionReloaderErrors');\r\n        return res.json()\r\n      })\r\n      .catch(handleFetchError);\r\n\r\n    if (typeof timestamp === 'undefined') {\r\n      timestamp = t;\r\n    } else if (timestamp !== t) {\r\n      chrome.runtime.reload();\r\n    }\r\n\r\n    function handleFetchError(error) {\r\n      clearInterval(id);\r\n\r\n      const errors =\r\n        localStorage.chromeExtensionReloaderErrors || 0;\r\n\r\n      if (errors < 5) {\r\n        localStorage.chromeExtensionReloaderErrors = errors + 1;\r\n\r\n        // Should reload at least once if fetch fails.\r\n        // The fetch will fail if the timestamp file is absent,\r\n        // thus the new build does not include the reloader\r\n        return 0\r\n      } else {\r\n        console.log(\r\n          'rollup-plugin-chrome-extension simple reloader error:',\r\n        );\r\n        console.error(error);\r\n\r\n        return timestamp\r\n      }\r\n    }\r\n  }, 1000);\n\n}());\n";

const code = "(function () {\n  'use strict';\n\n  /* ------------------- FILENAMES ------------------- */\r\n  const loadMessagePlaceholder = \"%LOAD_MESSAGE%\";\n\n  /* eslint-env browser */\r\n\r\n  // Log load message to browser dev console\r\n  console.log(loadMessagePlaceholder.slice(1, -1));\r\n\r\n  const { name } = chrome.runtime.getManifest();\r\n\r\n  const reload = () => {\r\n    console.log(`${name} has reloaded...`);\r\n\r\n    setTimeout(() => {\r\n      location.reload();\r\n    }, 500);\r\n  };\r\n\r\n  setInterval(() => {\r\n    try {\r\n      chrome.runtime.getManifest();\r\n    } catch (error) {\r\n      if (error.message === \"Extension context invalidated.\") {\r\n        reload();\r\n      }\r\n    }\r\n  }, 1000);\n\n}());\n";

/* ------------------- FILENAMES ------------------- */

const backgroundPageReloader = "background-page-reloader.js";
const contentScriptReloader = "content-script-reloader.js";
const timestampFilename = "timestamp.json";

/* ------------------ PLACEHOLDERS ----------------- */

const timestampPathPlaceholder = "%TIMESTAMP_PATH%";
const loadMessagePlaceholder = "%LOAD_MESSAGE%";
const ctScriptPathPlaceholder = "%CONTENT_SCRIPT_PATH%";
const unregisterServiceWorkersPlaceholder = "%UNREGISTER_SERVICE_WORKERS%";
const executeScriptPlaceholder = "%EXECUTE_SCRIPT%";

function _optionalChain(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }


















// Used for testing
const _internalCache = {};

const simpleReloader = (
    {
        executeScript = true,
        unregisterServiceWorkers = true,
    } = {} ,
    cache = {} ,
) => {
    if (!process.env.ROLLUP_WATCH) {
        return undefined;
    }

    return {
        name: "chrome-extension-simple-reloader",

        generateBundle({ dir }, bundle) {
            const date = new Date();
            const time = `${date
                .getFullYear()
                .toString()
                .padStart(2, "0")}-${(date.getMonth() + 1)
                    .toString()
                    .padStart(2, "0")}-${date
                        .getDate()
                        .toString()
                        .padStart(2, "0")} ${date
                            .getHours()
                            .toString()
                            .padStart(2, "0")}:${date
                                .getMinutes()
                                .toString()
                                .padStart(2, "0")}:${date
                                    .getSeconds()
                                    .toString()
                                    .padStart(2, "0")}`;

            cache.outputDir = dir;
            cache.loadMessage = [
                "DEVELOPMENT build with simple auto-reloader",
                `[${time}] waiting for changes...`,
            ].join("\n");

            /* --------------- EMIT CLIENT FILES --------------- */

            const emit = (
                name,
                source,
                isFileName,
            ) => {
                const id = this.emitFile({
                    type: "asset",
                    [isFileName ? "fileName" : "name"]: name,
                    source,
                });

                return this.getFileName(id);
            };

            cache.timestampPath = emit(
                timestampFilename,
                JSON.stringify(Date.now()),
                true,
            );

            cache.ctScriptPath = emit(
                contentScriptReloader,
                code.replace(
                    loadMessagePlaceholder,
                    JSON.stringify(cache.loadMessage),
                ),
            );

            cache.bgScriptPath = emit(
                backgroundPageReloader,
                code$1
                    .replace(timestampPathPlaceholder, cache.timestampPath)
                    .replace(
                        loadMessagePlaceholder,
                        JSON.stringify(cache.loadMessage),
                    )
                    .replace(
                        ctScriptPathPlaceholder,
                        JSON.stringify(cache.ctScriptPath),
                    )
                    .replace(
                        executeScriptPlaceholder,
                        JSON.stringify(executeScript),
                    )
                    .replace(
                        unregisterServiceWorkersPlaceholder,
                        JSON.stringify(unregisterServiceWorkers),
                    ),
            );

            // Update the exported cache
            Object.assign(_internalCache, cache);

            /* ---------------- UPDATE MANIFEST ---------------- */

            updateManifest(
                (manifest) => {
                    /* ------------------ DESCRIPTION ------------------ */

                    manifest.description = cache.loadMessage;

                    /* ---------------- BACKGROUND PAGE ---------------- */

                    if (!manifest.background) {
                        manifest.background = {};
                    }

                    manifest.background.persistent = true;

                    const { scripts: bgScripts = [] } = manifest.background;

                    if (cache.bgScriptPath) {
                        manifest.background.scripts = [
                            cache.bgScriptPath,
                            ...bgScripts,
                        ];
                    } else {
                        this.error(
                            `cache.bgScriptPath is ${typeof cache.bgScriptPath}`,
                        );
                    }

                    /* ---------------- CONTENT SCRIPTS ---------------- */

                    const { content_scripts: ctScripts } = manifest;

                    if (cache.ctScriptPath) {
                        manifest.content_scripts = _optionalChain([ctScripts, 'optionalAccess', _ => _.map, 'call', _2 => _2(
                            ({ js = [], ...rest }) => ({
                                js: [cache.ctScriptPath, ...js],
                                ...rest,
                            }),
                        )]);
                    } else {
                        this.error(
                            `cache.ctScriptPath is ${typeof cache.ctScriptPath}`,
                        );
                    }

                    return manifest;
                },
                bundle,
                this.error,
            );

            // We'll write this file ourselves, we just need a safe path to write the timestamp
            delete bundle[cache.timestampPath];
        },

        /* -------------- WRITE TIMESTAMP FILE ------------- */
        async writeBundle() {
            try {
                await fs.outputJson(
                    path.join(cache.outputDir, cache.timestampPath),
                    Date.now(),
                );
            } catch (err) {
                if (typeof err.message === "string") {
                    this.error(
                        `Unable to update timestamp file:\n\t${err.message}`,
                    );
                } else {
                    this.error("Unable to update timestamp file");
                }
            }
        },
    };
};

const stubChunkName = "stub__empty-chrome-extension-manifest";

const chromeExtension = (
    options = {} ,
) => {
    /* --------------- LOAD PACKAGE.JSON --------------- */
    try {
        const packageJsonPath = path.join(process.cwd(), "package.json");
        options.pkg = options.pkg || fs.readJSONSync(packageJsonPath);
    } catch (error) { }

    /* ----------------- SETUP PLUGINS ----------------- */
    const normalizedOptions = { ...options } ;
    const manifest2 = manifestInput(options);
    const html2 = htmlInputs(normalizedOptions );
    const manifestProcessor = new ManifestProcessor(normalizedOptions);
    const htmlProcessor = new HtmlProcessor(normalizedOptions);
    const validate = validateNames();

    /* ----------------- RETURN PLUGIN ----------------- */
    return {
        name: "chrome-extension",
        // For testing
        _plugins: { manifest: manifest2, html: html2, validate },
        configResolved(config) {
        },
        async options(options) {
            // Do not reload manifest without changes
            if (!manifestProcessor.manifest) {
                manifestProcessor.load(options);
                options.input = manifestProcessor.resolveInput(options.input);
            }
            // resolve scripts and assets in html
            options.input = htmlProcessor.resolveInput(options.input);
            logger.logInputFiles(options.input);
            return options;
        },
        async buildStart() {
            manifestProcessor.addWatchFiles(this);
            htmlProcessor.addWatchFiles(this);
            await manifestProcessor.emitFiles(this);
            await htmlProcessor.emitFiles(this);
        },
        resolveId(source) {
            if (source === stubChunkName) {
                return source;
            }
            return null;
        },
        load(id) {
            if (id === stubChunkName) {
                return { code: `console.log("${stubChunkName}")` };
            }
            return null;
        },
        transform(code, id, ssr) {
            return manifestProcessor.transform(this, code, id, ssr);
        },
        watchChange(id) {
            manifestProcessor.clearCacheById(id);
            htmlProcessor.clearCacheById(id);
        },
        resolveFileUrl({ referenceId, fileName }) {
            if (manifestProcessor.isDynamicImportedContentScript(referenceId)) {
                return `"${slash__default['default'](fileName)}"`;
            }
            return null;
        },
        outputOptions(options) {
            return {
                ...options,
                chunkFileNames: "[name].[hash].js",
                assetFileNames: "[name].[hash].[ext]",
                entryFileNames: "[name].js"
            };
        },
        async generateBundle(options, bundle, isWrite) {
            await manifestProcessor.generateBundle(this, bundle);
            await htmlProcessor.generateBundle(this, bundle);
            // await validate.generateBundle.call(this, options, bundle, isWrite);
        },
    };
};

exports.chromeExtension = chromeExtension;
exports.simpleReloader = simpleReloader;
exports.stubChunkName = stubChunkName;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXgtY2pzLmpzIiwic291cmNlcyI6WyIuLi9zcmMvdXRpbHMvaGVscGVycy50cyIsIi4uL3NyYy9odG1sLWlucHV0cy9jaGVlcmlvLnRzIiwiLi4vc3JjL2h0bWwtaW5wdXRzL2dlbmVyYXRlQnVuZGxlLnRzIiwiLi4vc3JjL2h0bWwtaW5wdXRzL2luZGV4LnRzIiwiLi4vc3JjL21hbmlmZXN0LWlucHV0L2dlbmVyYXRlQnVuZGxlLnRzIiwiLi4vc3JjL21hbmlmZXN0LWlucHV0L21hbmlmZXN0LXBhcnNlci9jb21iaW5lLnRzIiwiLi4vc3JjL21hbmlmZXN0LWlucHV0L21hbmlmZXN0LXBhcnNlci9pbmRleC50cyIsIi4uL3NyYy9tYW5pZmVzdC1pbnB1dC9tYW5pZmVzdC1wYXJzZXIvdmFsaWRhdGUudHMiLCIuLi9zcmMvbWFuaWZlc3QtaW5wdXQvcmVkdWNlVG9SZWNvcmQudHMiLCIuLi9zcmMvdXRpbHMvYnVuZGxlLnRzIiwiLi4vc3JjL21hbmlmZXN0LWlucHV0L2luZGV4LnRzIiwiLi4vc3JjL3V0aWxzL2xvZ2dlci50cyIsIi4uL3NyYy92YWxpZGF0ZS1uYW1lcy9pbmRleC50cyIsIi4uL3NyYy9tYW5pZmVzdC1pbnB1dC9tYW5pZmVzdC1wYXJzZXIvaW5kZXgudHMiLCIuLi9zcmMvY29tbW9uL3V0aWxzL3BhdGgudHMiLCIuLi9zcmMvY29tbW9uL3V0aWxzL3JvbGx1cC50cyIsIi4uL3NyYy9jb21tb24vdXRpbHMvY3NzLnRzIiwiLi4vc3JjL3Byb2Nlc3NvcnMvbWl4aW4vbWl4aW4ucGx1Z2luLnRzIiwiLi4vc3JjL3Byb2Nlc3NvcnMvbWl4aW4vaW5kZXgudHMiLCIuLi9zcmMvcHJvY2Vzc29ycy9jb250ZW50LXNjcmlwdC9jb250ZW50LXNjcmlwdC50cyIsIi4uL3NyYy9tYW5pZmVzdC1pbnB1dC9tYW5pZmVzdC1wYXJzZXIvcGVybWlzc2lvbnMudHMiLCIuLi9zcmMvcHJvY2Vzc29ycy9wZXJtaXNzaW9uLnRzIiwiLi4vc3JjL3Byb2Nlc3NvcnMvYmFja2dyb3VuZC9iYWNrZ3JvdW5kLnRzIiwiLi4vc3JjL3Byb2Nlc3NvcnMvbWFuaWZlc3QudHMiLCIuLi9zcmMvcHJvY2Vzc29ycy9odG1sLnRzIiwiLi4vc3JjL3BsdWdpbi1yZWxvYWRlci1zaW1wbGUvQ09OU1RBTlRTLnRzIiwiLi4vc3JjL3BsdWdpbi1yZWxvYWRlci1zaW1wbGUvaW5kZXgudHMiLCIuLi9zcmMvaW5kZXgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT3V0cHV0T3B0aW9ucyB9IGZyb20gXCJyb2xsdXBcIjtcclxuaW1wb3J0IHsgT3V0cHV0QXNzZXQsIE91dHB1dENodW5rLCBPdXRwdXRCdW5kbGUgfSBmcm9tIFwicm9sbHVwXCI7XHJcbmltcG9ydCBzbGFzaCBmcm9tIFwic2xhc2hcIjtcclxuaW1wb3J0IHsgT3V0cHV0Q2h1bmtCdW5kbGUgfSBmcm9tIFwiLi4vY29tbW9uL21vZGVsc1wiO1xyXG5pbXBvcnQgeyBDaHJvbWVFeHRlbnNpb25NYW5pZmVzdCB9IGZyb20gXCIuLi9tYW5pZmVzdC52MlwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IG5vdCA9IDxUPihmbjogKHg6IFQpID0+IGJvb2xlYW4pID0+ICh4OiBUKSA9PiAhZm4oeCk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gaXNDaHVuayhcclxuICAgIHg6IE91dHB1dENodW5rIHwgT3V0cHV0QXNzZXQsXHJcbik6IHggaXMgT3V0cHV0Q2h1bmsge1xyXG4gICAgcmV0dXJuIHggJiYgeC50eXBlID09PSBcImNodW5rXCI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc091dHB1dE9wdGlvbnMoeDogYW55KTogeCBpcyBPdXRwdXRPcHRpb25zIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgICAgdHlwZW9mIHggPT09IFwib2JqZWN0XCIgJiZcclxuICAgICAgICAhQXJyYXkuaXNBcnJheSh4KSAmJlxyXG4gICAgICAgIHR5cGVvZiB4LmZvcm1hdCA9PT0gXCJzdHJpbmdcIiAmJlxyXG4gICAgICAgIFtcImlpZmVcIiwgXCJlc1wiXS5pbmNsdWRlcyh4LmZvcm1hdClcclxuICAgICk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0Fzc2V0KFxyXG4gICAgeDogT3V0cHV0Q2h1bmsgfCBPdXRwdXRBc3NldCxcclxuKTogeCBpcyBPdXRwdXRBc3NldCB7XHJcbiAgICByZXR1cm4geC50eXBlID09PSBcImFzc2V0XCI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyh4OiBhbnkpOiB4IGlzIHN0cmluZyB7XHJcbiAgICByZXR1cm4gdHlwZW9mIHggPT09IFwic3RyaW5nXCI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBpc0pzb25GaWxlUGF0aCh4OiBhbnkpOiB4IGlzIHN0cmluZyB7XHJcbiAgICByZXR1cm4gaXNTdHJpbmcoeCkgJiYgeC5lbmRzV2l0aChcImpzb25cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBub3JtYWxpemVGaWxlbmFtZSA9IChwOiBzdHJpbmcpID0+XHJcbiAgICBwLnJlcGxhY2UoL1xcLlt0al1zeD8kLywgXCIuanNcIik7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3V0cHV0RmlsZW5hbWVGcm9tQ2h1bmsoc291cmNlRmlsZU5hbWU6IHN0cmluZywgY2h1bmtzOiBPdXRwdXRDaHVua1tdKSB7XHJcbiAgICBjb25zdCBjaHVuayA9IGNodW5rcy5maW5kKGMgPT4gYy5mYWNhZGVNb2R1bGVJZCAmJiBzbGFzaChjLmZhY2FkZU1vZHVsZUlkKSA9PT0gc2xhc2goc291cmNlRmlsZU5hbWUpKTtcclxuICAgIHJldHVybiBzbGFzaChjaHVuaz8uZmlsZU5hbWUgfHwgXCJcIik7XHJcbn1cclxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRDaHVua0J5TmFtZShuYW1lOiBzdHJpbmcsIGJ1bmRsZTogT3V0cHV0QnVuZGxlKTogT3V0cHV0Q2h1bmsgfCB1bmRlZmluZWQge1xyXG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoYnVuZGxlKS5maW5kKGIgPT4gYi5uYW1lICYmIHNsYXNoKGIubmFtZSkgPT09IHNsYXNoKG5hbWUpICYmIGIudHlwZSA9PT0gXCJjaHVua1wiKSBhcyBPdXRwdXRDaHVuayB8IHVuZGVmaW5lZDtcclxufVxyXG5leHBvcnQgZnVuY3Rpb24gZmluZEFzc2V0QnlOYW1lKG5hbWU6IHN0cmluZywgYnVuZGxlOiBPdXRwdXRCdW5kbGUpOiBPdXRwdXRBc3NldCB8IHVuZGVmaW5lZCB7XHJcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhidW5kbGUpLmZpbmQoYiA9PiBiLm5hbWUgJiYgc2xhc2goYi5uYW1lKSA9PT0gc2xhc2gobmFtZSkgJiYgYi50eXBlID09PSBcImFzc2V0XCIpIGFzIE91dHB1dEFzc2V0IHwgdW5kZWZpbmVkO1xyXG59XHJcbmV4cG9ydCBmdW5jdGlvbiBmaW5kQ2h1bmsoc291cmNlRmlsZU5hbWU6IHN0cmluZywgY2h1bmtzOiBPdXRwdXRDaHVua0J1bmRsZSkge1xyXG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoY2h1bmtzKS5maW5kKGMgPT4gYy5mYWNhZGVNb2R1bGVJZCAmJiBzbGFzaChjLmZhY2FkZU1vZHVsZUlkKSA9PT0gc2xhc2goc291cmNlRmlsZU5hbWUpKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZSB0aGUgbWFuaWZlc3Qgc291cmNlIGluIHRoZSBvdXRwdXQgYnVuZGxlXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgdXBkYXRlTWFuaWZlc3QgPSAoXHJcbiAgICB1cGRhdGVyOiAoXHJcbiAgICAgICAgbWFuaWZlc3Q6IENocm9tZUV4dGVuc2lvbk1hbmlmZXN0LFxyXG4gICAgKSA9PiBDaHJvbWVFeHRlbnNpb25NYW5pZmVzdCxcclxuICAgIGJ1bmRsZTogT3V0cHV0QnVuZGxlLFxyXG4gICAgaGFuZGxlRXJyb3I/OiAobWVzc2FnZTogc3RyaW5nKSA9PiB2b2lkLFxyXG4pOiBPdXRwdXRCdW5kbGUgPT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBjb25zdCBtYW5pZmVzdEtleSA9IFwibWFuaWZlc3QuanNvblwiO1xyXG4gICAgICAgIGNvbnN0IG1hbmlmZXN0QXNzZXQgPSBidW5kbGVbbWFuaWZlc3RLZXldIGFzIE91dHB1dEFzc2V0O1xyXG5cclxuICAgICAgICBpZiAoIW1hbmlmZXN0QXNzZXQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgXCJObyBtYW5pZmVzdC5qc29uIGluIHRoZSByb2xsdXAgb3V0cHV0IGJ1bmRsZS5cIixcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGNvbnN0IG1hbmlmZXN0ID0gSlNPTi5wYXJzZShcclxuICAgICAgICAgICAgbWFuaWZlc3RBc3NldC5zb3VyY2UgYXMgc3RyaW5nLFxyXG4gICAgICAgICkgYXMgQ2hyb21lRXh0ZW5zaW9uTWFuaWZlc3Q7XHJcblxyXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHVwZGF0ZXIobWFuaWZlc3QpO1xyXG5cclxuICAgICAgICBtYW5pZmVzdEFzc2V0LnNvdXJjZSA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCwgdW5kZWZpbmVkLCAyKTtcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgaWYgKGhhbmRsZUVycm9yKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZUVycm9yKGVycm9yLm1lc3NhZ2UpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gYnVuZGxlO1xyXG59O1xyXG4iLCJpbXBvcnQgY2hlZXJpbyBmcm9tIFwiY2hlZXJpb1wiO1xyXG5pbXBvcnQgZnMgZnJvbSBcImZzLWV4dHJhXCI7XHJcbmltcG9ydCBwYXRoIGZyb20gXCJwYXRoXCI7XHJcbmltcG9ydCBwcmV0dGllciBmcm9tIFwicHJldHRpZXJcIjtcclxuXHJcbmltcG9ydCB7IGlzU3RyaW5nIH0gZnJvbSBcIi4uL3V0aWxzL2hlbHBlcnNcIjtcclxuaW1wb3J0IHsgSHRtbElucHV0c09wdGlvbnMgfSBmcm9tIFwiLi4vcGx1Z2luLW9wdGlvbnNcIjtcclxuXHJcbmV4cG9ydCB0eXBlIEh0bWxGaWxlUGF0aERhdGEgPSB7XHJcbiAgICBmaWxlUGF0aDogc3RyaW5nXHJcbiAgICByb290UGF0aDogc3RyaW5nXHJcbn07XHJcblxyXG4vKiogY2hlZXJpby5Sb290IG9iamVjdHMgd2l0aCBhIGZpbGUgcGF0aCAqL1xyXG5leHBvcnQgdHlwZSBDaGVlcmlvRmlsZSA9IGNoZWVyaW8uUm9vdCAmIEh0bWxGaWxlUGF0aERhdGE7XHJcblxyXG5leHBvcnQgY29uc3QgZm9ybWF0SHRtbCA9ICgkOiBDaGVlcmlvRmlsZSkgPT5cclxuICAgIHByZXR0aWVyLmZvcm1hdCgkLmh0bWwoKSwgeyBwYXJzZXI6IFwiaHRtbFwiIH0pO1xyXG5cclxuZXhwb3J0IGNvbnN0IGxvYWRIdG1sID0gKHJvb3RQYXRoOiBzdHJpbmcpID0+IChcclxuICAgIGZpbGVQYXRoOiBzdHJpbmcsXHJcbik6IENoZWVyaW9GaWxlID0+IHtcclxuICAgIGNvbnN0IGh0bWxDb2RlID0gZnMucmVhZEZpbGVTeW5jKGZpbGVQYXRoLCBcInV0ZjhcIik7XHJcbiAgICBjb25zdCAkID0gY2hlZXJpby5sb2FkKGh0bWxDb2RlKTtcclxuXHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbigkLCB7IGZpbGVQYXRoLCByb290UGF0aCB9KTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRSZWxhdGl2ZVBhdGggPSAoe1xyXG4gICAgZmlsZVBhdGgsXHJcbiAgICByb290UGF0aCxcclxufTogSHRtbEZpbGVQYXRoRGF0YSkgPT4gKHA6IHN0cmluZykgPT4ge1xyXG4gICAgY29uc3QgaHRtbEZpbGVEaXIgPSBwYXRoLmRpcm5hbWUoZmlsZVBhdGgpO1xyXG5cclxuICAgIGxldCByZWxEaXI6IHN0cmluZztcclxuICAgIGlmIChwLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XHJcbiAgICAgICAgcmVsRGlyID0gcGF0aC5yZWxhdGl2ZShwcm9jZXNzLmN3ZCgpLCByb290UGF0aCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHJlbERpciA9IHBhdGgucmVsYXRpdmUocHJvY2Vzcy5jd2QoKSwgaHRtbEZpbGVEaXIpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwYXRoLmpvaW4ocmVsRGlyLCBwKTtcclxufTtcclxuXHJcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tIFNDUklQVFMgLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbmV4cG9ydCBjb25zdCBnZXRTY3JpcHRFbGVtcyA9ICgkOiBjaGVlcmlvLlJvb3QpID0+XHJcbiAgICAkKFwic2NyaXB0XCIpXHJcbiAgICAgICAgLm5vdChcIltkYXRhLXJvbGx1cC1hc3NldF1cIilcclxuICAgICAgICAubm90KCdbc3JjXj1cImh0dHA6XCJdJylcclxuICAgICAgICAubm90KCdbc3JjXj1cImh0dHBzOlwiXScpXHJcbiAgICAgICAgLm5vdCgnW3NyY149XCJkYXRhOlwiXScpXHJcbiAgICAgICAgLm5vdCgnW3NyY149XCIvXCJdJyk7XHJcblxyXG4vLyBNdXRhdGl2ZSBhY3Rpb25cclxuZXhwb3J0IGNvbnN0IG11dGF0ZVNjcmlwdEVsZW1zID0gKHtcclxuICAgIGJyb3dzZXJQb2x5ZmlsbCxcclxufTogUGljazxIdG1sSW5wdXRzT3B0aW9ucywgXCJicm93c2VyUG9seWZpbGxcIj4pID0+IChcclxuICAgICQ6IENoZWVyaW9GaWxlLFxyXG4gICAgKSA9PiB7XHJcbiAgICAgICAgZ2V0U2NyaXB0RWxlbXMoJClcclxuICAgICAgICAgICAgLmF0dHIoXCJ0eXBlXCIsIFwibW9kdWxlXCIpXHJcbiAgICAgICAgICAgIC5hdHRyKFwic3JjXCIsIChpLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IEB0eXBlcy9jaGVlcmlvIGlzIHdyb25nIGZvciBBdHRyRnVuY3Rpb246IGluZGV4LmQudHMsIGxpbmUgMTZcclxuICAgICAgICAgICAgICAgIC8vIGRlY2xhcmUgdHlwZSBBdHRyRnVuY3Rpb24gPSAoaTogbnVtYmVyLCBjdXJyZW50VmFsdWU6IHN0cmluZykgPT4gYW55O1xyXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXHJcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXHJcbiAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlZCA9IHZhbHVlLnJlcGxhY2UoL1xcLltqdF1zeD8vZywgXCIuanNcIik7XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcGxhY2VkO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgaWYgKGJyb3dzZXJQb2x5ZmlsbCkge1xyXG4gICAgICAgICAgICBjb25zdCBoZWFkID0gJChcImhlYWRcIik7XHJcbiAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgIGJyb3dzZXJQb2x5ZmlsbCA9PT0gdHJ1ZSB8fFxyXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBicm93c2VyUG9seWZpbGwgPT09IFwib2JqZWN0XCIgJiZcclxuICAgICAgICAgICAgICAgICAgICBicm93c2VyUG9seWZpbGwuZXhlY3V0ZVNjcmlwdClcclxuICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICBoZWFkLnByZXBlbmQoXHJcbiAgICAgICAgICAgICAgICAgICAgJzxzY3JpcHQgc3JjPVwiL2Fzc2V0cy9icm93c2VyLXBvbHlmaWxsLWV4ZWN1dGVTY3JpcHQuanNcIj48L3NjcmlwdD4nLFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgaGVhZC5wcmVwZW5kKFxyXG4gICAgICAgICAgICAgICAgJzxzY3JpcHQgc3JjPVwiL2Fzc2V0cy9icm93c2VyLXBvbHlmaWxsLmpzXCI+PC9zY3JpcHQ+JyxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiAkO1xyXG4gICAgfTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRTY3JpcHRzID0gKCQ6IGNoZWVyaW8uUm9vdCkgPT5cclxuICAgIGdldFNjcmlwdEVsZW1zKCQpLnRvQXJyYXkoKTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRTY3JpcHRTcmMgPSAoJDogQ2hlZXJpb0ZpbGUpID0+XHJcbiAgICBnZXRTY3JpcHRzKCQpXHJcbiAgICAgICAgLm1hcCgoZWxlbSkgPT4gJChlbGVtKS5hdHRyKFwic3JjXCIpKVxyXG4gICAgICAgIC5maWx0ZXIoaXNTdHJpbmcpXHJcbiAgICAgICAgLm1hcChnZXRSZWxhdGl2ZVBhdGgoJCkpO1xyXG5cclxuLyogLS0tLS0tLS0tLS0tLS0tLS0gQVNTRVQgU0NSSVBUUyAtLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuY29uc3QgZ2V0QXNzZXRzID0gKCQ6IGNoZWVyaW8uUm9vdCkgPT5cclxuICAgICQoXCJzY3JpcHRcIilcclxuICAgICAgICAuZmlsdGVyKCdbZGF0YS1yb2xsdXAtYXNzZXQ9XCJ0cnVlXCJdJylcclxuICAgICAgICAubm90KCdbc3JjXj1cImh0dHA6XCJdJylcclxuICAgICAgICAubm90KCdbc3JjXj1cImh0dHBzOlwiXScpXHJcbiAgICAgICAgLm5vdCgnW3NyY149XCJkYXRhOlwiXScpXHJcbiAgICAgICAgLm5vdCgnW3NyY149XCIvXCJdJylcclxuICAgICAgICAudG9BcnJheSgpO1xyXG5cclxuZXhwb3J0IGNvbnN0IGdldEpzQXNzZXRzID0gKCQ6IENoZWVyaW9GaWxlKSA9PlxyXG4gICAgZ2V0QXNzZXRzKCQpXHJcbiAgICAgICAgLm1hcCgoZWxlbSkgPT4gJChlbGVtKS5hdHRyKFwic3JjXCIpKVxyXG4gICAgICAgIC5maWx0ZXIoaXNTdHJpbmcpXHJcbiAgICAgICAgLm1hcChnZXRSZWxhdGl2ZVBhdGgoJCkpO1xyXG5cclxuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0gY3NzIC0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbmNvbnN0IGdldENzcyA9ICgkOiBjaGVlcmlvLlJvb3QpID0+XHJcbiAgICAkKFwibGlua1wiKVxyXG4gICAgICAgIC5maWx0ZXIoJ1tyZWw9XCJzdHlsZXNoZWV0XCJdJylcclxuICAgICAgICAubm90KCdbaHJlZl49XCJodHRwOlwiXScpXHJcbiAgICAgICAgLm5vdCgnW2hyZWZePVwiaHR0cHM6XCJdJylcclxuICAgICAgICAubm90KCdbaHJlZl49XCJkYXRhOlwiXScpXHJcbiAgICAgICAgLm5vdCgnW2hyZWZePVwiL1wiXScpXHJcbiAgICAgICAgLnRvQXJyYXkoKTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRDc3NIcmVmcyA9ICgkOiBDaGVlcmlvRmlsZSkgPT5cclxuICAgIGdldENzcygkKVxyXG4gICAgICAgIC5tYXAoKGVsZW0pID0+ICQoZWxlbSkuYXR0cihcImhyZWZcIikpXHJcbiAgICAgICAgLmZpbHRlcihpc1N0cmluZylcclxuICAgICAgICAubWFwKGdldFJlbGF0aXZlUGF0aCgkKSk7XHJcblxyXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLSBpbWcgLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuY29uc3QgZ2V0SW1ncyA9ICgkOiBjaGVlcmlvLlJvb3QpID0+XHJcbiAgICAkKFwiaW1nXCIpXHJcbiAgICAgICAgLm5vdCgnW3NyY149XCJodHRwOi8vXCJdJylcclxuICAgICAgICAubm90KCdbc3JjXj1cImh0dHBzOi8vXCJdJylcclxuICAgICAgICAubm90KCdbc3JjXj1cImRhdGE6XCJdJylcclxuICAgICAgICAudG9BcnJheSgpO1xyXG5cclxuY29uc3QgZ2V0RmF2aWNvbnMgPSAoJDogY2hlZXJpby5Sb290KSA9PlxyXG4gICAgJCgnbGlua1tyZWw9XCJpY29uXCJdJylcclxuICAgICAgICAubm90KCdbaHJlZl49XCJodHRwOlwiXScpXHJcbiAgICAgICAgLm5vdCgnW2hyZWZePVwiaHR0cHM6XCJdJylcclxuICAgICAgICAubm90KCdbaHJlZl49XCJkYXRhOlwiXScpXHJcbiAgICAgICAgLnRvQXJyYXkoKTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRJbWdTcmNzID0gKCQ6IENoZWVyaW9GaWxlKSA9PiB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIC4uLmdldEltZ3MoJCkubWFwKChlbGVtKSA9PiAkKGVsZW0pLmF0dHIoXCJzcmNcIikpLFxyXG4gICAgICAgIC4uLmdldEZhdmljb25zKCQpLm1hcCgoZWxlbSkgPT4gJChlbGVtKS5hdHRyKFwiaHJlZlwiKSksXHJcbiAgICBdXHJcbiAgICAgICAgLmZpbHRlcihpc1N0cmluZylcclxuICAgICAgICAubWFwKGdldFJlbGF0aXZlUGF0aCgkKSk7XHJcbn07XHJcbiIsImltcG9ydCB7IHJlc29sdmUsIGRpcm5hbWUsIHJlbGF0aXZlIH0gZnJvbSBcInBhdGhcIjtcclxuaW1wb3J0IHsgT3V0cHV0Q2h1bmssIFBsdWdpbkNvbnRleHQgfSBmcm9tIFwicm9sbHVwXCI7XHJcbmltcG9ydCB7IEh0bWxJbnB1dHNPcHRpb25zIH0gZnJvbSBcIi4uL3BsdWdpbi1vcHRpb25zXCI7XHJcbmltcG9ydCB7IGdldE91dHB1dEZpbGVuYW1lRnJvbUNodW5rIH0gZnJvbSBcIi4uL3V0aWxzL2hlbHBlcnNcIjtcclxuaW1wb3J0IHsgQ2hlZXJpb0ZpbGUsIGZvcm1hdEh0bWwsIGdldFNjcmlwdEVsZW1zIH0gZnJvbSBcIi4vY2hlZXJpb1wiO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlSHRtbChcclxuICAgIGNvbnRleHQ6IFBsdWdpbkNvbnRleHQsXHJcbiAgICBodG1sczogQ2hlZXJpb0ZpbGVbXSxcclxuICAgIGNodW5rczogT3V0cHV0Q2h1bmtbXSxcclxuICAgIG9wdGlvbnM6IEh0bWxJbnB1dHNPcHRpb25zLFxyXG4gICAgc3JjRGlyOiBzdHJpbmcsXHJcbikge1xyXG4gICAgaHRtbHMubWFwKCQgPT4gcmVwbGFjZUltcG9ydFNjcmlwdFBhdGgoJCwgY2h1bmtzLCBzcmNEaXIsIG9wdGlvbnMuYnJvd3NlclBvbHlmaWxsKSlcclxuICAgICAgICAubWFwKCQgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBmb3JtYXRIdG1sKCQpO1xyXG4gICAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IHJlbGF0aXZlKHNyY0RpciwgJC5maWxlUGF0aCk7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZW1pdEZpbGUoe1xyXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhc3NldFwiLFxyXG4gICAgICAgICAgICAgICAgc291cmNlLCAvLyBTdHJpbmdcclxuICAgICAgICAgICAgICAgIGZpbGVOYW1lLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlcGxhY2VJbXBvcnRTY3JpcHRQYXRoKFxyXG4gICAgJDogQ2hlZXJpb0ZpbGUsXHJcbiAgICBjaHVua3M6IE91dHB1dENodW5rW10sXHJcbiAgICBzcmNEaXI6IHN0cmluZyxcclxuICAgIGJyb3dzZXJQb2x5ZmlsbD86IGJvb2xlYW4gfCB7IGV4ZWN1dGVTY3JpcHQ6IGJvb2xlYW4gfSxcclxuKSB7XHJcbiAgICBnZXRTY3JpcHRFbGVtcygkKVxyXG4gICAgICAgIC5hdHRyKFwidHlwZVwiLCBcIm1vZHVsZVwiKVxyXG4gICAgICAgIC5hdHRyKFwic3JjXCIsIChpLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBiYXNlUGF0aCA9IGRpcm5hbWUoJC5maWxlUGF0aCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGNodW5rTmFtZSA9IGdldE91dHB1dEZpbGVuYW1lRnJvbUNodW5rKHJlc29sdmUoYmFzZVBhdGgsIHZhbHVlIGFzIHVua25vd24gYXMgc3RyaW5nKSwgY2h1bmtzKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlbGF0aXZlKGJhc2VQYXRoLCByZXNvbHZlKHNyY0RpciwgY2h1bmtOYW1lKSk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgaWYgKGJyb3dzZXJQb2x5ZmlsbCkge1xyXG4gICAgICAgIGNvbnN0IGhlYWQgPSAkKFwiaGVhZFwiKTtcclxuICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIGJyb3dzZXJQb2x5ZmlsbCA9PT0gdHJ1ZSB8fFxyXG4gICAgICAgICAgICAodHlwZW9mIGJyb3dzZXJQb2x5ZmlsbCA9PT0gXCJvYmplY3RcIiAmJlxyXG4gICAgICAgICAgICAgICAgYnJvd3NlclBvbHlmaWxsLmV4ZWN1dGVTY3JpcHQpXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIGhlYWQucHJlcGVuZChcclxuICAgICAgICAgICAgICAgICc8c2NyaXB0IHNyYz1cIi9hc3NldHMvYnJvd3Nlci1wb2x5ZmlsbC1leGVjdXRlU2NyaXB0LmpzXCI+PC9zY3JpcHQ+JyxcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGhlYWQucHJlcGVuZChcclxuICAgICAgICAgICAgJzxzY3JpcHQgc3JjPVwiL2Fzc2V0cy9icm93c2VyLXBvbHlmaWxsLmpzXCI+PC9zY3JpcHQ+JyxcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiAkO1xyXG59XHJcbiIsImltcG9ydCBcImFycmF5LWZsYXQtcG9seWZpbGxcIjtcclxuXHJcbmltcG9ydCB7IHJlYWRGaWxlIH0gZnJvbSBcImZzLWV4dHJhXCI7XHJcblxyXG5cclxuaW1wb3J0IHsgaXNDaHVuaywgbm90IH0gZnJvbSBcIi4uL3V0aWxzL2hlbHBlcnNcIjtcclxuaW1wb3J0IHsgcmVkdWNlVG9SZWNvcmQgfSBmcm9tIFwiLi4vbWFuaWZlc3QtaW5wdXQvcmVkdWNlVG9SZWNvcmRcIjtcclxuaW1wb3J0IHtcclxuICAgIEh0bWxJbnB1dHNPcHRpb25zLFxyXG4gICAgSHRtbElucHV0c1BsdWdpbkNhY2hlLFxyXG4gICAgSHRtbElucHV0c1BsdWdpbixcclxufSBmcm9tIFwiLi4vcGx1Z2luLW9wdGlvbnNcIjtcclxuaW1wb3J0IHtcclxuICAgIGdldENzc0hyZWZzLFxyXG4gICAgZ2V0SW1nU3JjcyxcclxuICAgIGdldEpzQXNzZXRzLFxyXG4gICAgZ2V0U2NyaXB0U3JjLFxyXG4gICAgbG9hZEh0bWwsXHJcbn0gZnJvbSBcIi4vY2hlZXJpb1wiO1xyXG5pbXBvcnQgeyBnZW5lcmF0ZUh0bWwgfSBmcm9tIFwiLi9nZW5lcmF0ZUJ1bmRsZVwiO1xyXG5cclxuXHJcblxyXG5jb25zdCBuYW1lID0gXCJodG1sLWlucHV0c1wiO1xyXG5cclxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cclxuLyogICAgICAgICAgICAgICAgICBIVE1MLUlOUFVUUyAgICAgICAgICAgICAgICAgKi9cclxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGh0bWxJbnB1dHMoXHJcbiAgICBodG1sSW5wdXRzT3B0aW9uczogSHRtbElucHV0c09wdGlvbnMsXHJcbiAgICAvKiogVXNlZCBmb3IgdGVzdGluZyAqL1xyXG4gICAgY2FjaGUgPSB7XHJcbiAgICAgICAgc2NyaXB0czogW10sXHJcbiAgICAgICAgaHRtbDogW10sXHJcbiAgICAgICAgaHRtbCQ6IFtdLFxyXG4gICAgICAgIGpzOiBbXSxcclxuICAgICAgICBjc3M6IFtdLFxyXG4gICAgICAgIGltZzogW10sXHJcbiAgICAgICAgaW5wdXQ6IFtdLFxyXG4gICAgfSBhcyBIdG1sSW5wdXRzUGx1Z2luQ2FjaGUsXHJcbik6IEh0bWxJbnB1dHNQbHVnaW4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuYW1lLFxyXG4gICAgICAgIGNhY2hlLFxyXG5cclxuICAgICAgICBnZW5lcmF0ZUJ1bmRsZShvcHRpb25zLCBidW5kbGUpIHtcclxuICAgICAgICAgICAgaWYgKCFjYWNoZS5zcmNEaXIpIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYWNoZS5zcmNEaXIgbm90IGluaXRpYWxpemVkXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGNodW5rcyA9IE9iamVjdC52YWx1ZXMoYnVuZGxlKS5maWx0ZXIoaXNDaHVuayk7XHJcbiAgICAgICAgICAgIGdlbmVyYXRlSHRtbCh0aGlzLCBjYWNoZS5odG1sJCwgY2h1bmtzLCBodG1sSW5wdXRzT3B0aW9ucywgY2FjaGUuc3JjRGlyKTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG4iLCJpbXBvcnQgeyBiYXNlbmFtZSwgam9pbiB9IGZyb20gXCJwYXRoXCI7XHJcbmltcG9ydCB7IE91dHB1dENodW5rLCBQbHVnaW5Db250ZXh0IH0gZnJvbSBcInJvbGx1cFwiO1xyXG5pbXBvcnQgc2xhc2ggZnJvbSBcInNsYXNoXCI7XHJcbmltcG9ydCBtZW1vaXplIGZyb20gXCJtZW1cIjtcclxuaW1wb3J0IHsgZmluZENodW5rLCBnZXRPdXRwdXRGaWxlbmFtZUZyb21DaHVuayB9IGZyb20gXCIuLi91dGlscy9oZWxwZXJzXCI7XHJcbmltcG9ydCB7IENocm9tZUV4dGVuc2lvbk1hbmlmZXN0LCBDb250ZW50U2NyaXB0LCBXZWJBY2Nlc3NpYmxlUmVzb3VyY2UgfSBmcm9tIFwiLi4vbWFuaWZlc3RcIjtcclxuaW1wb3J0IHsgRHluYW1pY0ltcG9ydFdyYXBwZXJPcHRpb25zLCBwcmVwSW1wb3J0V3JhcHBlclNjcmlwdCB9IGZyb20gXCIuL2R5bmFtaWNJbXBvcnRXcmFwcGVyXCI7XHJcbmltcG9ydCB7IGNvZGUgYXMgY3RXcmFwcGVyU2NyaXB0IH0gZnJvbSBcImNvZGUgLi9icm93c2VyL2NvbnRlbnRTY3JpcHRXcmFwcGVyLnRzXCI7XHJcbmltcG9ydCB7IGJhY2tncm91bmRTY3JpcHROYW1lLCBtYW5pZmVzdE5hbWUgfSBmcm9tIFwiLi9jb21tb24vY29uc3RhbnRzXCI7XHJcbmltcG9ydCB7IHJlcGxhY2VDb250ZW50U2NyaXB0c1BhdGggfSBmcm9tIFwiLi91dGlscy9tYW5pZmVzdFwiO1xyXG5pbXBvcnQgeyBPdXRwdXRDaHVua0J1bmRsZSB9IGZyb20gXCIuLi9jb21tb24vbW9kZWxzXCI7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVkdXBlPFQ+KHg6IFRbXSk6IFRbXSB7XHJcbiAgICByZXR1cm4gWy4uLm5ldyBTZXQoeCldO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc0NvbnRlbnRTY3JpcHRzKFxyXG4gICAgbWFuaWZlc3Q6IENocm9tZUV4dGVuc2lvbk1hbmlmZXN0LFxyXG4gICAgY2h1bmtzOiBPdXRwdXRDaHVua0J1bmRsZSxcclxuICAgIHNyY0Rpcjogc3RyaW5nLFxyXG4pIHtcclxuICAgIHJlcGxhY2VDb250ZW50U2NyaXB0c1BhdGgobWFuaWZlc3QsIHBhdGggPT4ge1xyXG4gICAgICAgIGNvbnN0IGNodW5rID0gZmluZENodW5rKGpvaW4oc3JjRGlyLCBwYXRoKSwgY2h1bmtzKTtcclxuICAgICAgICByZXR1cm4gY2h1bms/LmZpbGVOYW1lIHx8IFwiXCI7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlQ29udGVudFNjcmlwdHNXcmFwcGVyKFxyXG4gICAgY29udGV4dDogUGx1Z2luQ29udGV4dCxcclxuICAgIGNvbnRlbnRfc2NyaXB0czogQ29udGVudFNjcmlwdFtdLFxyXG4gICAgd2ViX2FjY2Vzc2libGVfcmVzb3VyY2VzOiBXZWJBY2Nlc3NpYmxlUmVzb3VyY2VbXSxcclxuICAgIG1hbmlmZXN0OiBDaHJvbWVFeHRlbnNpb25NYW5pZmVzdCxcclxuICAgIGNodW5rczogT3V0cHV0Q2h1bmtbXSxcclxuICAgIHNyY0Rpcjogc3RyaW5nLFxyXG4pOiB2b2lkIHtcclxuICAgIC8vIEZsYXR0ZW4gYWxsIGpzIGZpbGUgZm9ybSAvY29udGVudF9zY3JpcHRzLyovanMvKiBpbnRvIGFuIGFycmF5IG5hbWVkIGNvbnRlbnRTY3JpcHRzXHJcbiAgICBjb25zdCBjb250ZW50U2NyaXB0cyA9IGNvbnRlbnRfc2NyaXB0cy5yZWR1Y2UoXHJcbiAgICAgICAgKHIsIHsganMgPSBbXSB9KSA9PiBbLi4uciwgLi4uanNdLFxyXG4gICAgICAgIFtdIGFzIHN0cmluZ1tdLFxyXG4gICAgKTtcclxuICAgIGlmICghY29udGVudFNjcmlwdHMubGVuZ3RoKSB7IHJldHVybjsgfVxyXG5cclxuICAgIGNvbnN0IG1lbW9pemVkRW1pdHRlciA9IG1lbW9pemUoXHJcbiAgICAgICAgKHNjcmlwdFBhdGg6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBjdFdyYXBwZXJTY3JpcHQucmVwbGFjZShcclxuICAgICAgICAgICAgICAgIFwiJVBBVEglXCIsXHJcbiAgICAgICAgICAgICAgICAvLyBGaXggcGF0aCBzbGFzaGVzIHRvIHN1cHBvcnQgV2luZG93c1xyXG4gICAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoc2xhc2goc2NyaXB0UGF0aCkpLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAvLyBvdXRwdXQgY29udGVudCBzY3JpcHQgd3JhcHBlclxyXG4gICAgICAgICAgICBjb25zdCBhc3NldElkID0gY29udGV4dC5lbWl0RmlsZSh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFzc2V0XCIsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2UsXHJcbiAgICAgICAgICAgICAgICBuYW1lOiBiYXNlbmFtZShzY3JpcHRQYXRoKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHJldHVybiBjb250ZXh0LmdldEZpbGVOYW1lKGFzc2V0SWQpO1xyXG4gICAgICAgIH0sXHJcbiAgICApO1xyXG4gICAgLy8gU2V0dXAgY29udGVudCBzY3JpcHQgaW1wb3J0IHdyYXBwZXJcclxuICAgIG1hbmlmZXN0LmNvbnRlbnRfc2NyaXB0cyA9IGNvbnRlbnRfc2NyaXB0cy5tYXAoXHJcbiAgICAgICAgKHsganMsIC4uLnJlc3QgfSkgPT4gdHlwZW9mIGpzID09PSBcInVuZGVmaW5lZFwiXHJcbiAgICAgICAgICAgID8gcmVzdFxyXG4gICAgICAgICAgICA6IHtcclxuICAgICAgICAgICAgICAgIGpzOiBqc1xyXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZmlsZW5hbWUgPT4gZ2V0T3V0cHV0RmlsZW5hbWVGcm9tQ2h1bmsoam9pbihzcmNEaXIsIGZpbGVuYW1lKSwgY2h1bmtzKSlcclxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKGZpbGVuYW1lID0+ICEhZmlsZW5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcChtZW1vaXplZEVtaXR0ZXIpXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgocCkgPT4gc2xhc2gocCkpLFxyXG4gICAgICAgICAgICAgICAgLi4ucmVzdCxcclxuICAgICAgICAgICAgfSxcclxuICAgICk7XHJcbiAgICAvLyBtYWtlIGFsbCBpbXBvcnRzICYgZHluYW1pYyBpbXBvcnRzIHdlYl9hY2NfcmVzXHJcbiAgICBjb25zdCBpbXBvcnRzID0gY2h1bmtzLnJlZHVjZShcclxuICAgICAgICAociwgeyBpc0VudHJ5LCBmaWxlTmFtZSB9KSA9PlxyXG4gICAgICAgICAgICAvLyBHZXQgaW1wb3J0ZWQgZmlsZW5hbWVzXHJcbiAgICAgICAgICAgICFpc0VudHJ5ID8gWy4uLnIsIGZpbGVOYW1lXSA6IHIsXHJcbiAgICAgICAgW10gYXMgc3RyaW5nW10sXHJcbiAgICApO1xyXG4gICAgLy8gR2V0IGNvbXBpbGVkIGNvbnRlbnQgc2NyaXB0cywgbm90IHdyYXBwZXJcclxuICAgIGNvbnN0IGNvbXBpbGVkX2NvbnRlbnRfc2NyaXB0cyA9IGNvbnRlbnRfc2NyaXB0c1xyXG4gICAgICAgIC5maWx0ZXIoY3MgPT4gISFjcy5qcylcclxuICAgICAgICAucmVkdWNlKChzY3JpcHRzLCBqc19zY3JpcHRzKSA9PiBbLi4uc2NyaXB0cywgLi4uanNfc2NyaXB0cy5qcyFdLCBbXSBhcyBzdHJpbmdbXSlcclxuICAgICAgICAubWFwKGZpbGVuYW1lID0+IGdldE91dHB1dEZpbGVuYW1lRnJvbUNodW5rKGpvaW4oc3JjRGlyLCBmaWxlbmFtZSksIGNodW5rcykpO1xyXG4gICAgY29uc3Qgd2ViQWNjZXNzUmVzb3VyY2VzRmlsZU5hbWVzID0gZGVkdXBlKFtcclxuICAgICAgICAvLyBGRUFUVVJFOiBmaWx0ZXIgb3V0IGltcG9ydHMgZm9yIGJhY2tncm91bmQ/XHJcbiAgICAgICAgLi4uaW1wb3J0cyxcclxuICAgICAgICAvLyBOZWVkIHRvIGJlIHdlYiBhY2Nlc3NpYmxlIGIvYyBvZiBpbXBvcnRcclxuICAgICAgICAuLi5jb21waWxlZF9jb250ZW50X3NjcmlwdHMsXHJcbiAgICBdKS5tYXAoKHApID0+IHNsYXNoKHApKTtcclxuICAgIG1hbmlmZXN0LndlYl9hY2Nlc3NpYmxlX3Jlc291cmNlcyA9IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICAgIHJlc291cmNlczogWy4uLndlYkFjY2Vzc1Jlc291cmNlc0ZpbGVOYW1lc10sXHJcbiAgICAgICAgICAgIG1hdGNoZXM6IFtcIjxhbGxfdXJscz5cIl0sXHJcbiAgICAgICAgfSBhcyBXZWJBY2Nlc3NpYmxlUmVzb3VyY2UsXHJcbiAgICAgICAgLi4uZGVkdXBlKHdlYl9hY2Nlc3NpYmxlX3Jlc291cmNlcykubWFwKHJlc291cmNlID0+IHtcclxuICAgICAgICAgICAgcmVzb3VyY2UucmVzb3VyY2VzID0gcmVzb3VyY2UucmVzb3VyY2VzLm1hcChwID0+IHNsYXNoKHApKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc291cmNlO1xyXG4gICAgICAgIH0pLFxyXG4gICAgXTtcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZSBhIGR5bmFtaWMgaW1wb3J0IHdyYXBwZXIgZm9yIGJhY2tncm91bmQuanNcclxuICogQGV4cG9ydFxyXG4gKiBAcGFyYW0ge1BsdWdpbkNvbnRleHR9IGNvbnRleHRcclxuICogQHBhcmFtIHtzdHJpbmd9IHNlcnZpY2Vfd29ya2VyX3BhdGg6IHRoZSBvcmlnaW5hbCBwYXRoIGZvciBzZXJ2aWNlX3dvcmtfcGF0aCBpbiBvcmlnaW5hbCBtYW5pZmVzdC5qc29uXHJcbiAqIEBwYXJhbSB7RHluYW1pY0ltcG9ydFdyYXBwZXJPcHRpb25zfSBkeW5hbWljSW1wb3J0V3JhcHBlcjogb3B0aW9ucyBmb3IgZHluYW1pYyBpbXBvcnQgd3JhcHBlclxyXG4gKiBAcGFyYW0ge091dHB1dENodW5rW119IGNodW5rczogY29tcGlsZWQgY2h1bmtzIGZyb20gcm9sbHVwXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBzcmNEaXI6IGFic29sdXRlIHBhdGggZm9yIG9yaWdpbmFsIG1hbmlmZXN0Lmpzb25cclxuICogQHJldHVybiB7Kn0gOiBwYXRoIGZvciBnZW5lcmF0ZWQgd3JhcHBlciBmaWxlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVCYWNrZ3JvdW5kU2NyaXB0V3JhcHBlcihcclxuICAgIGNvbnRleHQ6IFBsdWdpbkNvbnRleHQsXHJcbiAgICBzZXJ2aWNlX3dvcmtlcl9wYXRoOiBzdHJpbmcsXHJcbiAgICBkeW5hbWljSW1wb3J0V3JhcHBlcjogRHluYW1pY0ltcG9ydFdyYXBwZXJPcHRpb25zLFxyXG4gICAgY2h1bmtzOiBPdXRwdXRDaHVua1tdLFxyXG4gICAgc3JjRGlyOiBzdHJpbmcsXHJcbik6IHN0cmluZyB7XHJcbiAgICAvLyBFbWl0IGJhY2tncm91bmQgc2NyaXB0IHdyYXBwZXJcclxuICAgIGNvbnN0IHdyYXBwZXJTY3JpcHQgPSBwcmVwSW1wb3J0V3JhcHBlclNjcmlwdChkeW5hbWljSW1wb3J0V3JhcHBlcik7XHJcbiAgICAvLyBHZXQgY29tcGlsZWQgYmFja2dyb3VuZCBzZXJ2aWNlIHdvcmsgc2NyaXB0IGZpbGUgcGF0aCBmcm9tIGNodW5rXHJcbiAgICBjb25zdCBzY3JpcHRQYXRoID0gZ2V0T3V0cHV0RmlsZW5hbWVGcm9tQ2h1bmsoam9pbihzcmNEaXIsIHNlcnZpY2Vfd29ya2VyX3BhdGgpLCBjaHVua3MpO1xyXG4gICAgLy8gY29kZSBmaWxlXHJcbiAgICBjb25zdCBzb3VyY2UgPSB3cmFwcGVyU2NyaXB0LnJlcGxhY2UoXHJcbiAgICAgICAgLy8gUGF0aCB0byBtb2R1bGUgYmVpbmcgbG9hZGVkXHJcbiAgICAgICAgXCIlUEFUSCVcIixcclxuICAgICAgICAvLyBGaXggcGF0aCBzbGFzaGVzIHRvIHN1cHBvcnQgV2luZG93c1xyXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHNsYXNoKHNjcmlwdFBhdGgpKSxcclxuICAgICk7XHJcbiAgICAvLyBvdXRwdXQgYmFja2dyb3VuZCB3cmFwcGVyXHJcbiAgICBjb25zdCBhc3NldElkID0gY29udGV4dC5lbWl0RmlsZSh7XHJcbiAgICAgICAgdHlwZTogXCJhc3NldFwiLFxyXG4gICAgICAgIHNvdXJjZSxcclxuICAgICAgICBmaWxlTmFtZTogYmFja2dyb3VuZFNjcmlwdE5hbWUsXHJcbiAgICB9KTtcclxuICAgIHJldHVybiBzbGFzaChjb250ZXh0LmdldEZpbGVOYW1lKGFzc2V0SWQpKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlTWFuaWZlc3QoXHJcbiAgICBjb250ZXh0OiBQbHVnaW5Db250ZXh0LFxyXG4gICAgbWFuaWZlc3Q6IENocm9tZUV4dGVuc2lvbk1hbmlmZXN0LFxyXG4pIHtcclxuICAgIGNvbnN0IG1hbmlmZXN0SnNvbiA9IEpTT04uc3RyaW5naWZ5KG1hbmlmZXN0LCBudWxsLCA0KVxyXG4gICAgICAgIC8vIFNNRUxMOiBpcyB0aGlzIG5lY2Vzc2FyeT9cclxuICAgICAgICAucmVwbGFjZSgvXFwuW2p0XXN4P1wiL2csICcuanNcIicpO1xyXG4gICAgLy8gRW1pdCBtYW5pZmVzdC5qc29uXHJcbiAgICBjb250ZXh0LmVtaXRGaWxlKHtcclxuICAgICAgICB0eXBlOiBcImFzc2V0XCIsXHJcbiAgICAgICAgZmlsZU5hbWU6IG1hbmlmZXN0TmFtZSxcclxuICAgICAgICBzb3VyY2U6IG1hbmlmZXN0SnNvbixcclxuICAgIH0pO1xyXG59XHJcbiIsImltcG9ydCBcImFycmF5LWZsYXQtcG9seWZpbGxcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBjb21iaW5lUGVybXMgPSAoXHJcbiAgLi4ucGVybWlzc2lvbnM6IHN0cmluZ1tdIHwgc3RyaW5nW11bXVxyXG4pOiBzdHJpbmdbXSA9PiB7XHJcbiAgY29uc3QgeyBwZXJtcywgeHBlcm1zIH0gPSAocGVybWlzc2lvbnMuZmxhdChcclxuICAgIEluZmluaXR5LFxyXG4gICkgYXMgc3RyaW5nW10pXHJcbiAgICAuZmlsdGVyKChwZXJtKSA9PiB0eXBlb2YgcGVybSAhPT0gXCJ1bmRlZmluZWRcIilcclxuICAgIC5yZWR1Y2UoXHJcbiAgICAgICh7IHBlcm1zLCB4cGVybXMgfSwgcGVybSkgPT4ge1xyXG4gICAgICAgIGlmIChwZXJtLnN0YXJ0c1dpdGgoXCIhXCIpKSB7XHJcbiAgICAgICAgICB4cGVybXMuYWRkKHBlcm0uc2xpY2UoMSkpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBwZXJtcy5hZGQocGVybSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4geyBwZXJtcywgeHBlcm1zIH07XHJcbiAgICAgIH0sXHJcbiAgICAgIHsgcGVybXM6IG5ldyBTZXQ8c3RyaW5nPigpLCB4cGVybXM6IG5ldyBTZXQ8c3RyaW5nPigpIH0sXHJcbiAgICApO1xyXG5cclxuICByZXR1cm4gWy4uLnBlcm1zXS5maWx0ZXIoKHApID0+ICF4cGVybXMuaGFzKHApKTtcclxufTtcclxuIiwiaW1wb3J0IGdsb2IgZnJvbSBcImdsb2JcIjtcclxuaW1wb3J0IGdldCBmcm9tIFwibG9kYXNoLmdldFwiO1xyXG5pbXBvcnQgZGlmZiBmcm9tIFwibG9kYXNoLmRpZmZlcmVuY2VcIjtcclxuaW1wb3J0IHsgam9pbiB9IGZyb20gXCJwYXRoXCI7XHJcblxyXG5pbXBvcnQge1xyXG4gICAgQ2hyb21lRXh0ZW5zaW9uTWFuaWZlc3QsXHJcbiAgICBDb250ZW50U2NyaXB0LFxyXG4gICAgV2ViQWNjZXNzaWJsZVJlc291cmNlLFxyXG59IGZyb20gXCIuLi8uLi9tYW5pZmVzdFwiO1xyXG5cclxuLy8gLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cclxuLy8gLyogICAgICAgICAgICAgICAgREVSSVZFIE1BTklGRVNUICAgICAgICAgICAgICAgKi9cclxuLy8gLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cclxuXHJcbi8vIGV4cG9ydCBmdW5jdGlvbiBkZXJpdmVNYW5pZmVzdChcclxuLy8gICBtYW5pZmVzdDogQ2hyb21lRXh0ZW5zaW9uTWFuaWZlc3QsIC8vIG1hbmlmZXN0Lmpzb25cclxuLy8gICAuLi5wZXJtaXNzaW9uczogc3RyaW5nW10gfCBzdHJpbmdbXVtdIC8vIHdpbGwgYmUgY29tYmluZWQgd2l0aCBtYW5pZmVzdC5wZXJtaXNzaW9uc1xyXG4vLyApOiBDaHJvbWVFeHRlbnNpb25NYW5pZmVzdCB7XHJcbi8vICAgcmV0dXJuIHZhbGlkYXRlTWFuaWZlc3Qoe1xyXG4vLyAgICAgLy8gU01FTEw6IElzIHRoaXMgbmVjZXNzYXJ5P1xyXG4vLyAgICAgbWFuaWZlc3RfdmVyc2lvbjogMixcclxuLy8gICAgIC4uLm1hbmlmZXN0LFxyXG4vLyAgICAgcGVybWlzc2lvbnM6IGNvbWJpbmVQZXJtcyhwZXJtaXNzaW9ucywgbWFuaWZlc3QucGVybWlzc2lvbnMpLFxyXG4vLyAgIH0pXHJcbi8vIH1cclxuXHJcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcbi8qICAgICAgICAgICAgICAgICBERVJJVkUgRklMRVMgICAgICAgICAgICAgICAgICovXHJcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlRmlsZXMoXHJcbiAgICBtYW5pZmVzdDogQ2hyb21lRXh0ZW5zaW9uTWFuaWZlc3QsXHJcbiAgICBzcmNEaXI6IHN0cmluZyxcclxuKSB7XHJcbiAgICAvLyBnZXQgcmVzb3VyY2VzIGZyb20gc2VjdGlvbiB3ZWJfYWNjZXNzaWJsZV9yZXNvdXJjZXNcclxuICAgIGNvbnN0IHdlYl9hY2Nlc3NpYmxlX3Jlc291cmNlcyA9IGdldChcclxuICAgICAgICBtYW5pZmVzdCxcclxuICAgICAgICBcIndlYl9hY2Nlc3NpYmxlX3Jlc291cmNlc1wiLFxyXG4gICAgICAgIFtdIGFzIFdlYkFjY2Vzc2libGVSZXNvdXJjZVtdLFxyXG4gICAgKS5yZWR1Y2UoKHJlc291cmNlX3BhdGhzLCB3ZWJfYWNjZXNzaWJsZV9yZXNvdXJjZSkgPT5cclxuICAgICAgICB3ZWJfYWNjZXNzaWJsZV9yZXNvdXJjZS5yZXNvdXJjZXMucmVkdWNlKChyLCB4KSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChnbG9iLmhhc01hZ2ljKHgpKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlcyA9IGdsb2Iuc3luYyh4LCB7IGN3ZDogc3JjRGlyIH0pO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsuLi5yLCAuLi5maWxlcy5tYXAoKGYpID0+IGYucmVwbGFjZShzcmNEaXIsIFwiXCIpKV07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gWy4uLnIsIHhdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSwgcmVzb3VyY2VfcGF0aHMpLFxyXG4gICAgW10gYXMgc3RyaW5nW10pO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICoganMgZmlsZXMgY29tZSBmcm9tOlxyXG4gICAgICogIC0gd2ViX2FjY2Vzc2libGVfcmVzb3VyY2VzXHJcbiAgICAgKiAgLSBiYWNrZ3JvdW5kLnNlcnZpY2Vfd29ya2VyXHJcbiAgICAgKiAgLSBjb250ZW50X3NjcmlwdHNcclxuICAgICAqL1xyXG4gICAgY29uc3QganMgPSBbXHJcbiAgICAgICAgLi4ud2ViX2FjY2Vzc2libGVfcmVzb3VyY2VzLmZpbHRlcigoZjogc3RyaW5nKSA9PiAvXFwuW2p0XXN4PyQvLnRlc3QoZikpLFxyXG4gICAgICAgIGdldChtYW5pZmVzdCwgXCJiYWNrZ3JvdW5kLnNlcnZpY2Vfd29ya2VyXCIpLFxyXG4gICAgICAgIC4uLmdldChcclxuICAgICAgICAgICAgbWFuaWZlc3QsXHJcbiAgICAgICAgICAgIFwiY29udGVudF9zY3JpcHRzXCIsXHJcbiAgICAgICAgICAgIFtdIGFzIENvbnRlbnRTY3JpcHRbXSxcclxuICAgICAgICApLnJlZHVjZSgociwgeyBqcyA9IFtdIH0pID0+IFsuLi5yLCAuLi5qc10sIFtdIGFzIHN0cmluZ1tdKSxcclxuICAgIF07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBodG1sIGZpbGVzIGNvbWUgZnJvbTpcclxuICAgICAqICAtIHdlYl9hY2Nlc3NpYmxlX3Jlc291cmNlc1xyXG4gICAgICogIC0gb3B0aW9uc19wYWdlXHJcbiAgICAgKiAgLSBvcHRpb25zX3VpLnBhZ2VcclxuICAgICAqICAtIGRldnRvb2xzX3BhZ2VcclxuICAgICAqICAtIGFjdGlvbi5kZWZhdWx0X3BvcHVwXHJcbiAgICAgKiAgLSBjaHJvbWVfdXJsX292ZXJyaWRlc1xyXG4gICAgICovXHJcbiAgICBjb25zdCBodG1sID0gW1xyXG4gICAgICAgIC4uLndlYl9hY2Nlc3NpYmxlX3Jlc291cmNlcy5maWx0ZXIoKGY6IHN0cmluZykgPT4gL1xcLmh0bWw/JC8udGVzdChmKSksXHJcbiAgICAgICAgZ2V0KG1hbmlmZXN0LCBcIm9wdGlvbnNfcGFnZVwiKSxcclxuICAgICAgICBnZXQobWFuaWZlc3QsIFwib3B0aW9uc191aS5wYWdlXCIpLFxyXG4gICAgICAgIGdldChtYW5pZmVzdCwgXCJkZXZ0b29sc19wYWdlXCIpLFxyXG4gICAgICAgIGdldChtYW5pZmVzdCwgXCJhY3Rpb24uZGVmYXVsdF9wb3B1cFwiKSxcclxuICAgICAgICAuLi5PYmplY3QudmFsdWVzKGdldChtYW5pZmVzdCwgXCJjaHJvbWVfdXJsX292ZXJyaWRlc1wiLCB7fSkpLFxyXG4gICAgXTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGNzcyBmaWxlcyBjb21lIGZyb206XHJcbiAgICAgKiAgLSB3ZWJfYWNjZXNzaWJsZV9yZXNvdXJjZXNcclxuICAgICAqICAtIGNvbnRlbnRfc2NyaXB0c1xyXG4gICAgICovXHJcbiAgICBjb25zdCBjc3MgPSBbXHJcbiAgICAgICAgLi4ud2ViX2FjY2Vzc2libGVfcmVzb3VyY2VzLmZpbHRlcigoZjogc3RyaW5nKSA9PiBmLmVuZHNXaXRoKFwiLmNzc1wiKSksXHJcbiAgICAgICAgLi4uZ2V0KFxyXG4gICAgICAgICAgICBtYW5pZmVzdCxcclxuICAgICAgICAgICAgXCJjb250ZW50X3NjcmlwdHNcIixcclxuICAgICAgICAgICAgW10gYXMgQ29udGVudFNjcmlwdFtdLFxyXG4gICAgICAgICkucmVkdWNlKFxyXG4gICAgICAgICAgICAociwgeyBjc3MgPSBbXSB9KSA9PiBbLi4uciwgLi4uY3NzXSxcclxuICAgICAgICAgICAgW10gYXMgc3RyaW5nW10sXHJcbiAgICAgICAgKSxcclxuICAgIF07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBhY3Rpb24gaWNvbnMgY29tZSBmcm9tOlxyXG4gICAgICogIC0gd2ViX2FjY2Vzc2libGVfcmVzb3VyY2VzXHJcbiAgICAgKiAgLSBjb250ZW50X3NjcmlwdHNcclxuICAgICAqL1xyXG4gICAgY29uc3QgYWN0aW9uSWNvblNldCA9IG5ldyBTZXQ8c3RyaW5nPigpO1xyXG4gICAgY29uc3QgZGVmYXVsdF9pY29uczogc3RyaW5nIHwgeyBbc2l6ZTogc3RyaW5nXTogc3RyaW5nIH0gPSBnZXQoXHJcbiAgICAgICAgbWFuaWZlc3QsXHJcbiAgICAgICAgXCJhY3Rpb24uZGVmYXVsdF9pY29uXCIsXHJcbiAgICAgICAge30gYXMgYW55LFxyXG4gICAgKTtcclxuICAgIGlmICh0eXBlb2YgZGVmYXVsdF9pY29ucyA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIGFjdGlvbkljb25TZXQuYWRkKGRlZmF1bHRfaWNvbnMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBPYmplY3QudmFsdWVzKGRlZmF1bHRfaWNvbnMpLmZvckVhY2goKHgpID0+IGFjdGlvbkljb25TZXQuYWRkKHgpKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIGltYWdlIGZpbGVzIGNvbWUgZnJvbTpcclxuICAgICAqICAtIHdlYl9hY2Nlc3NpYmxlX3Jlc291cmNlc1xyXG4gICAgICogIC0gYWN0aW9uLmRlZmF1bHRfaWNvblxyXG4gICAgICogIC0gaWNvbnNcclxuICAgICAqL1xyXG4gICAgY29uc3QgaW1nID0gW1xyXG4gICAgICAgIC4uLmFjdGlvbkljb25TZXQsXHJcbiAgICAgICAgLi4ud2ViX2FjY2Vzc2libGVfcmVzb3VyY2VzLmZpbHRlcigoZikgPT5cclxuICAgICAgICAgICAgL1xcLihqcGU/Z3xwbmd8c3ZnfHRpZmY/fGdpZnx3ZWJwfGJtcHxpY28pJC9pLnRlc3QoZiksXHJcbiAgICAgICAgKSxcclxuICAgICAgICAuLi5PYmplY3QudmFsdWVzKGdldChtYW5pZmVzdCwgXCJpY29uc1wiLCB7fSkpLFxyXG4gICAgXTtcclxuXHJcbiAgICAvLyBGaWxlcyBsaWtlIGZvbnRzLCB0aGluZ3MgdGhhdCBhcmUgbm90IGV4cGVjdGVkXHJcbiAgICBjb25zdCBvdGhlcnMgPSBkaWZmKHdlYl9hY2Nlc3NpYmxlX3Jlc291cmNlcywgY3NzLCBqcywgaHRtbCwgaW1nKTtcclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNzczogdmFsaWRhdGUoY3NzKSxcclxuICAgICAgICBqczogdmFsaWRhdGUoanMpLFxyXG4gICAgICAgIGh0bWw6IHZhbGlkYXRlKGh0bWwpLFxyXG4gICAgICAgIGltZzogdmFsaWRhdGUoaW1nKSxcclxuICAgICAgICBvdGhlcnM6IHZhbGlkYXRlKG90aGVycyksXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKGFyeTogYW55W10pIHtcclxuICAgICAgICByZXR1cm4gWy4uLm5ldyBTZXQoYXJ5LmZpbHRlcihpc1N0cmluZykpXS5tYXAoKHgpID0+XHJcbiAgICAgICAgICAgIGpvaW4oc3JjRGlyLCB4KSxcclxuICAgICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGlzU3RyaW5nKHg6IGFueSk6IHggaXMgc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIHggPT09IFwic3RyaW5nXCI7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IEFqdiBmcm9tIFwiYWp2XCI7XHJcbmltcG9ydCB7IENocm9tZUV4dGVuc2lvbk1hbmlmZXN0IH0gZnJvbSBcIi4uLy4uL21hbmlmZXN0XCI7XHJcbmltcG9ydCBqc29uU2NoZW1hIGZyb20gXCIuL2pzb24tc2NoZW1hLWRyYWZ0LTA0Lmpzb25cIjtcclxuaW1wb3J0IG1hbmlmZXN0U2NoZW1hIGZyb20gXCIuL3NjaGVtYS13ZWItZXh0LW1hbmlmZXN0LXYzLmpzb25cIjtcclxuXHJcbmV4cG9ydCB0eXBlIFZhbGlkYXRpb25FcnJvcnNBcnJheSA9XHJcbiAgICB8IEFqdi5FcnJvck9iamVjdFtdXHJcbiAgICB8IG51bGxcclxuICAgIHwgdW5kZWZpbmVkXHJcbmV4cG9ydCBjbGFzcyBWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihtc2c6IHN0cmluZywgZXJyb3JzOiBWYWxpZGF0aW9uRXJyb3JzQXJyYXkpIHtcclxuICAgICAgICBzdXBlcihtc2cpO1xyXG4gICAgICAgIHRoaXMubmFtZSA9IFwiVmFsaWRhdGlvbkVycm9yXCI7XHJcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBlcnJvcnM7XHJcbiAgICB9XHJcbiAgICBlcnJvcnM6IFZhbGlkYXRpb25FcnJvcnNBcnJheVxyXG59XHJcblxyXG4vLyBjb25zdCBqc29uU2NoZW1hID0gcmVhZEpTT05TeW5jKFxyXG4vLyAgIHJlc29sdmUoX19kaXJuYW1lLCAnanNvbi1zY2hlbWEtZHJhZnQtMDQuanNvbicpLFxyXG4vLyApXHJcblxyXG4vLyBjb25zdCBtYW5pZmVzdFNjaGVtYSA9IHJlYWRKU09OU3luYyhcclxuLy8gICByZXNvbHZlKF9fZGlybmFtZSwgJ3NjaGVtYS13ZWItZXh0LW1hbmlmZXN0LXYzLmpzb24nKSxcclxuLy8gKVxyXG5cclxuZXhwb3J0IGNvbnN0IGFqdiA9IG5ldyBBanYoe1xyXG4gICAgdmVyYm9zZTogdHJ1ZSxcclxuICAgIHNjaGVtYUlkOiBcImF1dG9cIixcclxuICAgIHNjaGVtYXM6IHtcclxuICAgICAgICBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiOiBqc29uU2NoZW1hLFxyXG4gICAgfSxcclxuICAgIHN0cmljdERlZmF1bHRzOiB0cnVlLFxyXG59KTtcclxuXHJcbi8vIGFqdi5hZGRNZXRhU2NoZW1hKGpzb25TY2hlbWEpXHJcblxyXG5jb25zdCB2YWxpZGF0b3IgPSBhanYuY29tcGlsZShtYW5pZmVzdFNjaGVtYSk7XHJcblxyXG5leHBvcnQgY29uc3QgdmFsaWRhdGVNYW5pZmVzdCA9IChcclxuICAgIG1hbmlmZXN0OiBDaHJvbWVFeHRlbnNpb25NYW5pZmVzdCxcclxuKSA9PiB7XHJcbiAgICBpZiAodmFsaWRhdG9yKG1hbmlmZXN0KSkgeyByZXR1cm4gbWFuaWZlc3Q7IH1cclxuICAgIGNvbnN0IHsgZXJyb3JzIH0gPSB2YWxpZGF0b3I7XHJcbiAgICBjb25zdCBtc2cgPSBcIlRoZXJlIHdlcmUgcHJvYmxlbXMgd2l0aCB0aGUgZXh0ZW5zaW9uIG1hbmlmZXN0LlwiO1xyXG4gICAgY29uc29sZS5lcnJvcihlcnJvcnMpXHJcbiAgICB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKG1zZywgZXJyb3JzKTtcclxufTtcclxuIiwiaW1wb3J0IHsgcmVsYXRpdmUgfSBmcm9tIFwicGF0aFwiO1xyXG5cclxudHlwZSBJbnB1dFJlY29yZCA9IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiByZWR1Y2VUb1JlY29yZChzcmNEaXI6IHN0cmluZyB8IG51bGwpIHtcclxuICAgIGlmIChzcmNEaXIgPT09IG51bGwgfHwgdHlwZW9mIHNyY0RpciA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgIC8vIFRoaXMgd291bGQgYmUgYSBjb25maWcgZXJyb3IsIHNvIHNob3VsZCB0aHJvd1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJzcmNEaXIgaXMgbnVsbCBvciB1bmRlZmluZWRcIik7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgICBpbnB1dFJlY29yZDogSW5wdXRSZWNvcmQsXHJcbiAgICAgICAgZmlsZW5hbWU6IHN0cmluZyxcclxuICAgICk6IElucHV0UmVjb3JkID0+IHtcclxuICAgICAgICBjb25zdCBuYW1lID0gcmVsYXRpdmUoc3JjRGlyLCBmaWxlbmFtZSlcclxuICAgICAgICAgICAgLnNwbGl0KFwiLlwiKVxyXG4gICAgICAgICAgICAuc2xpY2UoMCwgLTEpXHJcbiAgICAgICAgICAgIC5qb2luKFwiLlwiKTtcclxuXHJcbiAgICAgICAgaWYgKG5hbWUgaW4gaW5wdXRSZWNvcmQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgYFNjcmlwdCBmaWxlcyB3aXRoIGRpZmZlcmVudCBleHRlbnNpb25zIHNob3VsZCBub3Qgc2hhcmUgbmFtZXM6XFxuXFxuXCIke2ZpbGVuYW1lfVwiXFxud2lsbCBvdmVyd3JpdGVcXG5cIiR7aW5wdXRSZWNvcmRbbmFtZV19XCJgLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIHsgLi4uaW5wdXRSZWNvcmQsIFtuYW1lXTogZmlsZW5hbWUgfTtcclxuICAgIH07XHJcbn1cclxuIiwiaW1wb3J0IHsgT3V0cHV0QXNzZXQsIE91dHB1dEJ1bmRsZSwgT3V0cHV0Q2h1bmsgfSBmcm9tIFwicm9sbHVwXCI7XHJcbmltcG9ydCB7IE91dHB1dEFzc2V0QnVuZGxlLCBPdXRwdXRDaHVua0J1bmRsZSB9IGZyb20gXCIuLi9jb21tb24vbW9kZWxzXCI7XHJcbmltcG9ydCB7IGlzQXNzZXQsIGlzQ2h1bmsgfSBmcm9tIFwiLi9oZWxwZXJzXCI7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2h1bmsoYnVuZGxlOiBPdXRwdXRCdW5kbGUpIHtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyhidW5kbGUpXHJcbiAgICAgICAgLmZpbHRlcihrZXkgPT4gaXNDaHVuayhidW5kbGVba2V5XSkpXHJcbiAgICAgICAgLnJlZHVjZSgoYiwgaykgPT4ge1xyXG4gICAgICAgICAgICBiW2tdID0gYnVuZGxlW2tdIGFzIE91dHB1dENodW5rO1xyXG4gICAgICAgICAgICByZXR1cm4gYjtcclxuICAgICAgICB9LCB7fSBhcyBPdXRwdXRDaHVua0J1bmRsZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRBc3NldHMoYnVuZGxlOiBPdXRwdXRCdW5kbGUpIHtcclxuICAgIHJldHVybiBPYmplY3Qua2V5cyhidW5kbGUpXHJcbiAgICAgICAgLmZpbHRlcihrZXkgPT4gaXNBc3NldChidW5kbGVba2V5XSkpXHJcbiAgICAgICAgLnJlZHVjZSgoYiwgaykgPT4ge1xyXG4gICAgICAgICAgICBiW2tdID0gYnVuZGxlW2tdIGFzIE91dHB1dEFzc2V0O1xyXG4gICAgICAgICAgICByZXR1cm4gYjtcclxuICAgICAgICB9LCB7fSBhcyBPdXRwdXRBc3NldEJ1bmRsZSk7XHJcbn1cclxuIiwiaW1wb3J0IHsgY29zbWljb25maWdTeW5jIH0gZnJvbSBcImNvc21pY29uZmlnXCI7XHJcbmltcG9ydCB7IEpTT05QYXRoIH0gZnJvbSBcImpzb25wYXRoLXBsdXNcIjtcclxuaW1wb3J0IHBhdGggZnJvbSBcInBhdGhcIjtcclxuaW1wb3J0IHsgRW1pdHRlZEFzc2V0IH0gZnJvbSBcInJvbGx1cFwiO1xyXG5pbXBvcnQge1xyXG4gICAgZmluZENodW5rLFxyXG4gICAgZ2V0T3V0cHV0RmlsZW5hbWVGcm9tQ2h1bmssXHJcbiAgICBpc0pzb25GaWxlUGF0aCxcclxufSBmcm9tIFwiLi4vdXRpbHMvaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBDaHJvbWVFeHRlbnNpb25NYW5pZmVzdCB9IGZyb20gXCIuLi9tYW5pZmVzdFwiO1xyXG5pbXBvcnQge1xyXG4gICAgTWFuaWZlc3RJbnB1dFBsdWdpbixcclxuICAgIE1hbmlmZXN0SW5wdXRQbHVnaW5DYWNoZSxcclxuICAgIE1hbmlmZXN0SW5wdXRQbHVnaW5PcHRpb25zLFxyXG59IGZyb20gXCIuLi9wbHVnaW4tb3B0aW9uc1wiO1xyXG5pbXBvcnQgeyBjbG9uZU9iamVjdCB9IGZyb20gXCIuLi91dGlscy9jbG9uZU9iamVjdFwiO1xyXG5pbXBvcnQgeyBtYW5pZmVzdE5hbWUgfSBmcm9tIFwiLi9jb21tb24vY29uc3RhbnRzXCI7XHJcbmltcG9ydCB7IGdlbmVyYXRlTWFuaWZlc3QgfSBmcm9tIFwiLi9nZW5lcmF0ZUJ1bmRsZVwiO1xyXG5pbXBvcnQgeyBjb21iaW5lUGVybXMgfSBmcm9tIFwiLi9tYW5pZmVzdC1wYXJzZXIvY29tYmluZVwiO1xyXG5pbXBvcnQge1xyXG4gICAgZGVyaXZlRmlsZXMsXHJcbn0gZnJvbSBcIi4vbWFuaWZlc3QtcGFyc2VyL2luZGV4XCI7XHJcbmltcG9ydCB7XHJcbiAgICB2YWxpZGF0ZU1hbmlmZXN0LFxyXG4gICAgVmFsaWRhdGlvbkVycm9yc0FycmF5LFxyXG59IGZyb20gXCIuL21hbmlmZXN0LXBhcnNlci92YWxpZGF0ZVwiO1xyXG5pbXBvcnQgeyByZWR1Y2VUb1JlY29yZCB9IGZyb20gXCIuL3JlZHVjZVRvUmVjb3JkXCI7XHJcbmltcG9ydCB7IGpvaW4gfSBmcm9tIFwicGF0aFwiO1xyXG5pbXBvcnQgeyBnZXRBc3NldHMsIGdldENodW5rIH0gZnJvbSBcIi4uL3V0aWxzL2J1bmRsZVwiO1xyXG5pbXBvcnQgc2xhc2ggZnJvbSBcInNsYXNoXCI7XHJcblxyXG5leHBvcnQgY29uc3QgZXhwbG9yZXIgPSBjb3NtaWNvbmZpZ1N5bmMoXCJtYW5pZmVzdFwiLCB7XHJcbiAgICBjYWNoZTogZmFsc2UsXHJcbn0pO1xyXG5cclxuY29uc3QgbmFtZSA9IFwibWFuaWZlc3QtaW5wdXRcIjtcclxuXHJcbmNvbnN0IG5wbVBrZ0RldGFpbHMgPVxyXG4gICAgcHJvY2Vzcy5lbnYubnBtX3BhY2thZ2VfbmFtZSAmJlxyXG4gICAgICAgIHByb2Nlc3MuZW52Lm5wbV9wYWNrYWdlX3ZlcnNpb24gJiZcclxuICAgICAgICBwcm9jZXNzLmVudi5ucG1fcGFja2FnZV9kZXNjcmlwdGlvblxyXG4gICAgICAgID8ge1xyXG4gICAgICAgICAgICBuYW1lOiBwcm9jZXNzLmVudi5ucG1fcGFja2FnZV9uYW1lLFxyXG4gICAgICAgICAgICB2ZXJzaW9uOiBwcm9jZXNzLmVudi5ucG1fcGFja2FnZV92ZXJzaW9uLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogcHJvY2Vzcy5lbnYubnBtX3BhY2thZ2VfZGVzY3JpcHRpb24sXHJcbiAgICAgICAgfVxyXG4gICAgICAgIDoge1xyXG4gICAgICAgICAgICBuYW1lOiBcIlwiLFxyXG4gICAgICAgICAgICB2ZXJzaW9uOiBcIlwiLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJcIixcclxuICAgICAgICB9O1xyXG5cclxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cclxuLyogICAgICAgICAgICAgICAgTUFOSUZFU1QtSU5QVVQgICAgICAgICAgICAgICAgKi9cclxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBtYW5pZmVzdElucHV0KFxyXG4gICAge1xyXG4gICAgICAgIGJyb3dzZXJQb2x5ZmlsbCA9IGZhbHNlLFxyXG4gICAgICAgIGNvbnRlbnRTY3JpcHRXcmFwcGVyID0gdHJ1ZSxcclxuICAgICAgICBjcm9zc0Jyb3dzZXIgPSBmYWxzZSxcclxuICAgICAgICBkeW5hbWljSW1wb3J0V3JhcHBlciA9IHt9LFxyXG4gICAgICAgIGV4dGVuZE1hbmlmZXN0ID0ge30sXHJcbiAgICAgICAgZmlyc3RDbGFzc01hbmlmZXN0ID0gdHJ1ZSxcclxuICAgICAgICBpaWZlSnNvblBhdGhzID0gW10sXHJcbiAgICAgICAgcGtnID0gbnBtUGtnRGV0YWlscyxcclxuICAgICAgICBwdWJsaWNLZXksXHJcbiAgICAgICAgY2FjaGUgPSB7XHJcbiAgICAgICAgICAgIGFzc2V0Q2hhbmdlZDogZmFsc2UsXHJcbiAgICAgICAgICAgIGFzc2V0czogW10sXHJcbiAgICAgICAgICAgIGlpZmU6IFtdLFxyXG4gICAgICAgICAgICBpbnB1dDogW10sXHJcbiAgICAgICAgICAgIGlucHV0QXJ5OiBbXSxcclxuICAgICAgICAgICAgaW5wdXRPYmo6IHt9LFxyXG4gICAgICAgICAgICBwZXJtc0hhc2g6IFwiXCIsXHJcbiAgICAgICAgICAgIHJlYWRGaWxlOiBuZXcgTWFwPHN0cmluZywgYW55PigpLFxyXG4gICAgICAgICAgICBzcmNEaXI6IG51bGwsXHJcbiAgICAgICAgfSBhcyBNYW5pZmVzdElucHV0UGx1Z2luQ2FjaGUsXHJcbiAgICB9ID0ge30gYXMgTWFuaWZlc3RJbnB1dFBsdWdpbk9wdGlvbnMsXHJcbik6IE1hbmlmZXN0SW5wdXRQbHVnaW4ge1xyXG5cclxuICAgIC8qIC0tLS0tLS0tLS0tIEhPT0tTIENMT1NVUkVTIFNUQVJUIC0tLS0tLS0tLS0tICovXHJcbiAgICBsZXQgbWFuaWZlc3RQYXRoOiBzdHJpbmc7XHJcbiAgICAvKiAtLS0tLS0tLS0tLS0gSE9PS1MgQ0xPU1VSRVMgRU5EIC0tLS0tLS0tLS0tLSAqL1xyXG5cclxuICAgIC8qIC0tLS0tLS0tLS0tLS0tLSBwbHVnaW4gb2JqZWN0IC0tLS0tLS0tLS0tLS0tICovXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5hbWUsXHJcblxyXG4gICAgICAgIGJyb3dzZXJQb2x5ZmlsbCxcclxuICAgICAgICBjcm9zc0Jyb3dzZXIsXHJcblxyXG4gICAgICAgIGdldCBzcmNEaXIoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZS5zcmNEaXI7XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgZ2V0IGZvcm1hdE1hcCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgaWlmZTogY2FjaGUuaWlmZSB9O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXHJcbiAgICAgICAgLyogICAgICAgICAgICAgICAgIE9QVElPTlMgSE9PSyAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xyXG5cclxuICAgICAgICBvcHRpb25zKG9wdGlvbnMpIHtcclxuICAgICAgICAgICAgLy8gRG8gbm90IHJlbG9hZCBtYW5pZmVzdCB3aXRob3V0IGNoYW5nZXNcclxuICAgICAgICAgICAgaWYgKCFjYWNoZS5tYW5pZmVzdCkge1xyXG4gICAgICAgICAgICAgICAgLyogLS0tLS0tLS0tLS0gTE9BRCBBTkQgUFJPQ0VTUyBNQU5JRkVTVCAtLS0tLS0tLS0tLSAqL1xyXG4gICAgICAgICAgICAgICAgbGV0IGlucHV0TWFuaWZlc3RQYXRoOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmlucHV0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hbmlmZXN0SW5kZXggPSBvcHRpb25zLmlucHV0LmZpbmRJbmRleChcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNKc29uRmlsZVBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dE1hbmlmZXN0UGF0aCA9IG9wdGlvbnMuaW5wdXRbbWFuaWZlc3RJbmRleF07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuaW5wdXRBcnkgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMuaW5wdXQuc2xpY2UoMCwgbWFuaWZlc3RJbmRleCksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMuaW5wdXQuc2xpY2UobWFuaWZlc3RJbmRleCArIDEpLFxyXG4gICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmlucHV0ID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRNYW5pZmVzdFBhdGggPSBvcHRpb25zLmlucHV0Lm1hbmlmZXN0O1xyXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLmlucHV0T2JqID0gY2xvbmVPYmplY3Qob3B0aW9ucy5pbnB1dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNhY2hlLmlucHV0T2JqW1wibWFuaWZlc3RcIl07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGlucHV0TWFuaWZlc3RQYXRoID0gb3B0aW9ucy5pbnB1dDtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzSnNvbkZpbGVQYXRoKGlucHV0TWFuaWZlc3RQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiUm9sbHVwT3B0aW9ucy5pbnB1dCBtdXN0IGJlIGEgc2luZ2xlIENocm9tZSBleHRlbnNpb24gbWFuaWZlc3QuXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAvLyBMb2FkIGNvbnRlbnQgb2YgbWFuaWZlc3QuanNvblxyXG4gICAgICAgICAgICAgICAgY29uc3QgY29uZmlnUmVzdWx0ID0gZXhwbG9yZXIubG9hZChcclxuICAgICAgICAgICAgICAgICAgICBpbnB1dE1hbmlmZXN0UGF0aCxcclxuICAgICAgICAgICAgICAgICkgYXMge1xyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVwYXRoOiBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBDaHJvbWVFeHRlbnNpb25NYW5pZmVzdCxcclxuICAgICAgICAgICAgICAgICAgICBpc0VtcHR5PzogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlnUmVzdWx0LmlzRW1wdHkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7b3B0aW9ucy5pbnB1dH0gaXMgYW4gZW1wdHkgZmlsZS5gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCB7IG9wdGlvbnNfcGFnZSwgb3B0aW9uc191aSB9ID0gY29uZmlnUmVzdWx0LmNvbmZpZztcclxuICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zX3BhZ2UgIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnNfdWkgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm9wdGlvbnNfdWkgYW5kIG9wdGlvbnNfcGFnZSBjYW5ub3QgYm90aCBiZSBkZWZpbmVkIGluIG1hbmlmZXN0Lmpzb24uXCIsXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBtYW5pZmVzdFBhdGggPSBjb25maWdSZXN1bHQuZmlsZXBhdGg7XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRlbmRNYW5pZmVzdCA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUubWFuaWZlc3QgPSBleHRlbmRNYW5pZmVzdChjb25maWdSZXN1bHQuY29uZmlnKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4dGVuZE1hbmlmZXN0ID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUubWFuaWZlc3QgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmNvbmZpZ1Jlc3VsdC5jb25maWcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmV4dGVuZE1hbmlmZXN0LFxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlLm1hbmlmZXN0ID0gY29uZmlnUmVzdWx0LmNvbmZpZztcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBjYWNoZS5zcmNEaXIgPSBwYXRoLmRpcm5hbWUobWFuaWZlc3RQYXRoKTtcclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RDbGFzc01hbmlmZXN0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FjaGUuaWlmZSA9IGlpZmVKc29uUGF0aHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoanNvblBhdGgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IEpTT05QYXRoKHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBqc29uUGF0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uOiBjYWNoZS5tYW5pZmVzdCEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmxhdChJbmZpbml0eSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIERlcml2ZSBlbnRyeSBwYXRocyBmcm9tIG1hbmlmZXN0XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBqcywgaHRtbCwgY3NzLCBpbWcsIG90aGVycyB9ID0gZGVyaXZlRmlsZXMoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLm1hbmlmZXN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zcmNEaXIsXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FjaGUgZGVyaXZlZCBpbnB1dHNcclxuICAgICAgICAgICAgICAgICAgICBjYWNoZS5pbnB1dCA9IFsuLi5jYWNoZS5pbnB1dEFyeSwgLi4uanMsIC4uLmh0bWxdO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjYWNoZS5hc3NldHMgPSBbXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZHVwZSBhc3NldHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgLi4ubmV3IFNldChbLi4uY3NzLCAuLi5pbWcsIC4uLm90aGVyc10pLFxyXG4gICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgLyogLS0tLS0tLS0tLS0tLS0tIEVORCBMT0FEIE1BTklGRVNUIC0tLS0tLS0tLS0tLS0tLSAqL1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsSW5wdXQgPSBjYWNoZS5pbnB1dC5yZWR1Y2UoXHJcbiAgICAgICAgICAgICAgICByZWR1Y2VUb1JlY29yZChjYWNoZS5zcmNEaXIpLFxyXG4gICAgICAgICAgICAgICAgY2FjaGUuaW5wdXRPYmosXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIHJldHVybiB7IC4uLm9wdGlvbnMsIGlucHV0OiBmaW5hbElucHV0IH07XHJcbiAgICAgICAgfSxcclxuXHJcbiAgICAgICAgLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cclxuICAgICAgICAvKiAgICAgICAgICAgICAgICBHRU5FUkFURUJVTkRMRSAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXHJcblxyXG4gICAgICAgIGdlbmVyYXRlQnVuZGxlKG9wdGlvbnMsIGJ1bmRsZSkge1xyXG4gICAgICAgICAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLSBHRVQgQ0hVTktTIC0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgICAgICAgICAgY29uc3QgY2h1bmtzID0gZ2V0Q2h1bmsoYnVuZGxlKTtcclxuICAgICAgICAgICAgY29uc3QgYXNzZXRzID0gZ2V0QXNzZXRzKGJ1bmRsZSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoYnVuZGxlKS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgICAgICAgICBcIlRoZSBtYW5pZmVzdCBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGFzc2V0IChodG1sIG9yIGNzcykgb3Igc2NyaXB0IGZpbGUuXCIsXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2xvbmUgY2FjaGUubWFuaWZlc3RcclxuICAgICAgICAgICAgICAgIGlmICghY2FjaGUubWFuaWZlc3QpXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIHByb2dyYW1taW5nIGVycm9yLCBzbyBpdCBzaG91bGQgdGhyb3dcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBjYWNoZS5tYW5pZmVzdCBpcyAke3R5cGVvZiBjYWNoZS5tYW5pZmVzdH1gKTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBjbG9uZWRNYW5pZmVzdCA9IGNsb25lT2JqZWN0KGNhY2hlLm1hbmlmZXN0KTtcclxuXHJcbiAgICAgICAgICAgICAgICBjb25zdCBtYW5pZmVzdEJvZHk6IENocm9tZUV4dGVuc2lvbk1hbmlmZXN0ID0gdmFsaWRhdGVNYW5pZmVzdCh7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHBrZy5kZXNjcmlwdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAuLi5jbG9uZWRNYW5pZmVzdCxcclxuICAgICAgICAgICAgICAgICAgICBwZXJtaXNzaW9uczogY29tYmluZVBlcm1zKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9uZWRNYW5pZmVzdC5wZXJtaXNzaW9ucyB8fCBbXSxcclxuICAgICAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICAgICAgfSBhcyBDaHJvbWVFeHRlbnNpb25NYW5pZmVzdCk7XHJcblxyXG4gICAgICAgICAgICAgICAgY29uc3Qge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRfc2NyaXB0czogY3RzID0gW10sXHJcbiAgICAgICAgICAgICAgICAgICAgd2ViX2FjY2Vzc2libGVfcmVzb3VyY2VzOiB3YXIgPSBbXSxcclxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiB7IHNlcnZpY2Vfd29ya2VyOiBzdyA9IFwiXCIgfSA9IHt9LFxyXG4gICAgICAgICAgICAgICAgfSA9IG1hbmlmZXN0Qm9keTtcclxuICAgICAgICAgICAgICAgIC8qIC0tLS0tLS0tLS0tLS0gU0VUVVAgQ09OVEVOVCBTQ1JJUFRTIC0tLS0tLS0tLS0tLS0gKi9cclxuICAgICAgICAgICAgICAgIG1hbmlmZXN0Qm9keS5jb250ZW50X3NjcmlwdHMgPSBjdHMubWFwKFxyXG4gICAgICAgICAgICAgICAgICAgICh7IGpzLCAuLi5yZXN0IH0pID0+IHR5cGVvZiBqcyA9PT0gXCJ1bmRlZmluZWRcIlxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlc3RcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqczoganNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZpbGVuYW1lID0+IGdldE91dHB1dEZpbGVuYW1lRnJvbUNodW5rKGpvaW4oY2FjaGUuc3JjRGlyISwgZmlsZW5hbWUpLCBPYmplY3QudmFsdWVzKGNodW5rcykpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZmlsZW5hbWUgPT4gISFmaWxlbmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKChwKSA9PiBzbGFzaChwKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5yZXN0LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIC8qIC0tLS0tLS0tLS0tLSBTRVRVUCBCQUNLR1JPVU5EIFNDUklQVFMgLS0tLS0tLS0tLS0gKi9cclxuICAgICAgICAgICAgICAgIGlmIChzdyAmJiBtYW5pZmVzdEJvZHkuYmFja2dyb3VuZCAmJiBtYW5pZmVzdEJvZHkuYmFja2dyb3VuZC5zZXJ2aWNlX3dvcmtlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIG1ha2UgYmFja2dyb3VuZCBjaHVuayBvdXRwdXQgaW4gdGhlIHNhbWUgZGlyZWN0b3J5IGFzIG1hbmlmZXN0Lmpzb25cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IGZpbmRDaHVuayhqb2luKGNhY2hlLnNyY0RpciEsIG1hbmlmZXN0Qm9keS5iYWNrZ3JvdW5kLnNlcnZpY2Vfd29ya2VyKSwgY2h1bmtzKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG9yaWdpbmFsIGNodW5rXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBidW5kbGVbY2h1bmsuZmlsZU5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGFuZ2UgYmFja2dyb3VuZCBjaHVuayBvdXRwdXQgaW4gdGhlIHNhbWUgZGlyZWN0b3J5IGFzIG1hbmlmZXN0Lmpzb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsuZmlsZU5hbWUgPSBjaHVuay5maWxlTmFtZS5yZXBsYWNlKC9hc3NldHNcXC8vLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnVuZGxlW2NodW5rLmZpbGVOYW1lXSA9IGNodW5rO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYW5pZmVzdEJvZHkuYmFja2dyb3VuZC5zZXJ2aWNlX3dvcmtlciA9IGNodW5rLmZpbGVOYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIC8qIC0tLS0tLS0tLS0tLSBTRVRVUCBBU1NFVFMgSU4gV0VCIEFDQ0VTU0lCTEUgUkVTT1VSQ0VTIC0tLS0tLS0tLS0tICovXHJcbiAgICAgICAgICAgICAgICBtYW5pZmVzdEJvZHkud2ViX2FjY2Vzc2libGVfcmVzb3VyY2VzID0gW1xyXG4gICAgICAgICAgICAgICAgICAgIC4uLndhciwge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlczogT2JqZWN0LmtleXMoYXNzZXRzKSxcclxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzOiBbXCI8YWxsX3VybHM+XCJdXHJcbiAgICAgICAgICAgICAgICB9XTtcclxuICAgICAgICAgICAgICAgIC8qIC0tLS0tLS0tLSBTVEFCTEUgRVhURU5TSU9OIElEIC0tLS0tLS0tICovXHJcbiAgICAgICAgICAgICAgICBpZiAocHVibGljS2V5KSBtYW5pZmVzdEJvZHkua2V5ID0gcHVibGljS2V5O1xyXG4gICAgICAgICAgICAgICAgLyogLS0tLS0tLS0tLS0gT1VUUFVUIE1BTklGRVNULkpTT04gLS0tLS0tLS0tLSAqL1xyXG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVNYW5pZmVzdCh0aGlzLCBtYW5pZmVzdEJvZHkpO1xyXG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgLy8gQ2F0Y2ggaGVyZSBiZWNhdXNlIHdlIG5lZWQgdGhlIHZhbGlkYXRlZCByZXN1bHQgaW4gc2NvcGVcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvci5uYW1lICE9PSBcIlZhbGlkYXRpb25FcnJvclwiKSB0aHJvdyBlcnJvcjtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IGVycm9yLmVycm9ycyBhcyBWYWxpZGF0aW9uRXJyb3JzQXJyYXk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLmZvckVhY2goKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGSVhNRTogbWFrZSBhIGJldHRlciB2YWxpZGF0aW9uIGVycm9yIG1lc3NhZ2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2F0bGFzc2lhbi9iZXR0ZXItYWp2LWVycm9yc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLndhcm4oSlNPTi5zdHJpbmdpZnkoZXJyLCB1bmRlZmluZWQsIDIpKTtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoZXJyb3IubWVzc2FnZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgbWFuaWZlc3RJbnB1dDtcclxuIiwiaW1wb3J0IHsgSW5wdXRPcHRpb24gfSBmcm9tIFwicm9sbHVwXCI7XHJcblxyXG5mdW5jdGlvbiBsb2dJbnB1dEZpbGVzKGVudHJpZXM/OiBJbnB1dE9wdGlvbikge1xyXG4gICAgY29uc29sZS5sb2coXCJcXHgxQlszNm0lc1wiLCBcIlxcbkZpbmQgZW50cnkgZmlsZXNcIik7XHJcbiAgICBpZiAoIWVudHJpZXMpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIlxceDFCWzMzbSVzXFx4MUJbMG1cIiwgXCJFbXB0eSBlbnRyeSBmaWxlcy5cIik7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIGVudHJpZXMgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIlxceDFCWzMybSVzXFx4MUJbMG1cIiwgZW50cmllcyk7XHJcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZW50cmllcykpIHtcclxuICAgICAgICBlbnRyaWVzLmZvckVhY2goaW5wdXQgPT4ge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlxceDFCWzMybSVzXFx4MUJbMG1cIiwgaW5wdXQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGFsaWFzIGluIGVudHJpZXMpIHtcclxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlbnRyaWVzLCBhbGlhcykpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiXFx4MUJbMG0lczogXFx4MUJbMzJtJXNcXHgxQlswbVwiLCBhbGlhcywgZW50cmllc1thbGlhc10pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc29sZS5sb2coKTtcclxufVxyXG5cclxuXHJcbmV4cG9ydCBjb25zdCBsb2dnZXIgPSB7XHJcbiAgICBpbmZvOiAobXNnOiBzdHJpbmcpID0+IGNvbnNvbGUubG9nKFwiXFx4MUJbMzJtJXNcXHgxQlswbVwiLCBtc2cpLFxyXG4gICAgZXJyb3I6IChtc2c6IHN0cmluZykgPT4gY29uc29sZS5sb2coXCJcXHgxQlszMW0lc1xceDFCWzBtXCIsIG1zZyksXHJcbiAgICB3YXJuOiAobXNnOiBzdHJpbmcpID0+IGNvbnNvbGUubG9nKFwiXFx4MUJbMzNtJXNcXHgxQlswbVwiLCBtc2cpLFxyXG4gICAgbG9nSW5wdXRGaWxlcyxcclxufTtcclxuIiwiaW1wb3J0IHsgT3V0cHV0QXNzZXQsIE91dHB1dENodW5rLCBQbHVnaW4gfSBmcm9tIFwicm9sbHVwXCI7XHJcblxyXG5pbnRlcmZhY2UgTWFuaWZlc3RBc3NldCBleHRlbmRzIE91dHB1dEFzc2V0IHtcclxuICAgIHNvdXJjZTogc3RyaW5nXHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFZhbGlkYXRlTmFtZXNQbHVnaW4gPSBQaWNrPFxyXG4gICAgUmVxdWlyZWQ8UGx1Z2luPixcclxuICAgIFwibmFtZVwiIHwgXCJnZW5lcmF0ZUJ1bmRsZVwiXHJcbj5cclxuXHJcbmV4cG9ydCBjb25zdCB2YWxpZGF0ZU5hbWVzID0gKCk6IFZhbGlkYXRlTmFtZXNQbHVnaW4gPT4gKHtcclxuICAgIG5hbWU6IFwidmFsaWRhdGUtbmFtZXNcIixcclxuXHJcbiAgICBnZW5lcmF0ZUJ1bmRsZShvcHRpb25zLCBidW5kbGUpIHtcclxuICAgICAgICBjb25zdCBjaHVua3MgPSBPYmplY3QudmFsdWVzKGJ1bmRsZSkuZmlsdGVyKFxyXG4gICAgICAgICAgICAoeCk6IHggaXMgT3V0cHV0Q2h1bmsgPT4geC50eXBlID09PSBcImNodW5rXCIsXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gRmlsZXMgY2Fubm90IHN0YXJ0IHdpdGggXCJfXCIgaW4gQ2hyb21lIEV4dGVuc2lvbnNcclxuICAgICAgICAvLyBMb29wIHRocm91Z2ggZWFjaCBmaWxlIGFuZCBjaGVjayBmb3IgXCJfXCIgaW4gZmlsZW5hbWVcclxuICAgICAgICBPYmplY3Qua2V5cyhidW5kbGUpXHJcbiAgICAgICAgICAgIC5maWx0ZXIoKGZpbGVOYW1lKSA9PiBmaWxlTmFtZS5zdGFydHNXaXRoKFwiX1wiKSlcclxuICAgICAgICAgICAgLmZvckVhY2goKGZpbGVOYW1lKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHJlcGxhY2UgZmlyc3QgaW5zdGFuY2VcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChmaWxlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaXhlZCA9IGZpbGVOYW1lLnNsaWNlKDEpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIEZpeCBtYW5pZmVzdFxyXG4gICAgICAgICAgICAgICAgY29uc3QgbWFuaWZlc3QgPSBidW5kbGVbXCJtYW5pZmVzdC5qc29uXCJdIGFzIE1hbmlmZXN0QXNzZXQ7XHJcbiAgICAgICAgICAgICAgICBtYW5pZmVzdC5zb3VyY2UgPSBtYW5pZmVzdC5zb3VyY2UucmVwbGFjZShyZWdleCwgZml4ZWQpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENoYW5nZSBidW5kbGUga2V5XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IGJ1bmRsZVtmaWxlTmFtZV07XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgYnVuZGxlW2ZpbGVOYW1lXTtcclxuICAgICAgICAgICAgICAgIGJ1bmRsZVtmaXhlZF0gPSBjaHVuaztcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBGaXggY2h1bmtcclxuICAgICAgICAgICAgICAgIGNodW5rLmZpbGVOYW1lID0gZml4ZWQ7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gRmluZCBpbXBvcnRzIGFuZCBmaXhcclxuICAgICAgICAgICAgICAgIGNodW5rc1xyXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHsgaW1wb3J0cyB9KSA9PiBpbXBvcnRzLmluY2x1ZGVzKGZpbGVOYW1lKSlcclxuICAgICAgICAgICAgICAgICAgICAuZm9yRWFjaCgoY2h1bmspID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRml4IGltcG9ydHMgbGlzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVuay5pbXBvcnRzID0gY2h1bmsuaW1wb3J0cy5tYXAoKGkpID0+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpID09PSBmaWxlTmFtZSA/IGZpeGVkIDogaSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRml4IGltcG9ydHMgaW4gY29kZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVuay5jb2RlID0gY2h1bmsuY29kZS5yZXBsYWNlKHJlZ2V4LCBmaXhlZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgfSxcclxufSk7XHJcbiIsImltcG9ydCBnbG9iIGZyb20gXCJnbG9iXCI7XHJcbmltcG9ydCBnZXQgZnJvbSBcImxvZGFzaC5nZXRcIjtcclxuaW1wb3J0IGRpZmYgZnJvbSBcImxvZGFzaC5kaWZmZXJlbmNlXCI7XHJcbmltcG9ydCB7IGpvaW4gfSBmcm9tIFwicGF0aFwiO1xyXG5cclxuaW1wb3J0IHtcclxuICAgIENocm9tZUV4dGVuc2lvbk1hbmlmZXN0LFxyXG4gICAgQ29udGVudFNjcmlwdCxcclxuICAgIFdlYkFjY2Vzc2libGVSZXNvdXJjZSxcclxufSBmcm9tIFwiLi4vLi4vbWFuaWZlc3RcIjtcclxuXHJcbi8vIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXHJcbi8vIC8qICAgICAgICAgICAgICAgIERFUklWRSBNQU5JRkVTVCAgICAgICAgICAgICAgICovXHJcbi8vIC8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09ICovXHJcblxyXG4vLyBleHBvcnQgZnVuY3Rpb24gZGVyaXZlTWFuaWZlc3QoXHJcbi8vICAgbWFuaWZlc3Q6IENocm9tZUV4dGVuc2lvbk1hbmlmZXN0LCAvLyBtYW5pZmVzdC5qc29uXHJcbi8vICAgLi4ucGVybWlzc2lvbnM6IHN0cmluZ1tdIHwgc3RyaW5nW11bXSAvLyB3aWxsIGJlIGNvbWJpbmVkIHdpdGggbWFuaWZlc3QucGVybWlzc2lvbnNcclxuLy8gKTogQ2hyb21lRXh0ZW5zaW9uTWFuaWZlc3Qge1xyXG4vLyAgIHJldHVybiB2YWxpZGF0ZU1hbmlmZXN0KHtcclxuLy8gICAgIC8vIFNNRUxMOiBJcyB0aGlzIG5lY2Vzc2FyeT9cclxuLy8gICAgIG1hbmlmZXN0X3ZlcnNpb246IDIsXHJcbi8vICAgICAuLi5tYW5pZmVzdCxcclxuLy8gICAgIHBlcm1pc3Npb25zOiBjb21iaW5lUGVybXMocGVybWlzc2lvbnMsIG1hbmlmZXN0LnBlcm1pc3Npb25zKSxcclxuLy8gICB9KVxyXG4vLyB9XHJcblxyXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4vKiAgICAgICAgICAgICAgICAgREVSSVZFIEZJTEVTICAgICAgICAgICAgICAgICAqL1xyXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZUZpbGVzKFxyXG4gICAgbWFuaWZlc3Q6IENocm9tZUV4dGVuc2lvbk1hbmlmZXN0LFxyXG4gICAgc3JjRGlyOiBzdHJpbmcsXHJcbikge1xyXG4gICAgLy8gZ2V0IHJlc291cmNlcyBmcm9tIHNlY3Rpb24gd2ViX2FjY2Vzc2libGVfcmVzb3VyY2VzXHJcbiAgICBjb25zdCB3ZWJfYWNjZXNzaWJsZV9yZXNvdXJjZXMgPSBnZXQoXHJcbiAgICAgICAgbWFuaWZlc3QsXHJcbiAgICAgICAgXCJ3ZWJfYWNjZXNzaWJsZV9yZXNvdXJjZXNcIixcclxuICAgICAgICBbXSBhcyBXZWJBY2Nlc3NpYmxlUmVzb3VyY2VbXSxcclxuICAgICkucmVkdWNlKChyZXNvdXJjZV9wYXRocywgd2ViX2FjY2Vzc2libGVfcmVzb3VyY2UpID0+XHJcbiAgICAgICAgd2ViX2FjY2Vzc2libGVfcmVzb3VyY2UucmVzb3VyY2VzLnJlZHVjZSgociwgeCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZ2xvYi5oYXNNYWdpYyh4KSkge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZXMgPSBnbG9iLnN5bmMoeCwgeyBjd2Q6IHNyY0RpciB9KTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbLi4uciwgLi4uZmlsZXMubWFwKChmKSA9PiBmLnJlcGxhY2Uoc3JjRGlyLCBcIlwiKSldO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsuLi5yLCB4XTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sIHJlc291cmNlX3BhdGhzKSxcclxuICAgIFtdIGFzIHN0cmluZ1tdKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIGpzIGZpbGVzIGNvbWUgZnJvbTpcclxuICAgICAqICAtIHdlYl9hY2Nlc3NpYmxlX3Jlc291cmNlc1xyXG4gICAgICogIC0gYmFja2dyb3VuZC5zZXJ2aWNlX3dvcmtlclxyXG4gICAgICogIC0gY29udGVudF9zY3JpcHRzXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGpzID0gW1xyXG4gICAgICAgIC4uLndlYl9hY2Nlc3NpYmxlX3Jlc291cmNlcy5maWx0ZXIoKGY6IHN0cmluZykgPT4gL1xcLltqdF1zeD8kLy50ZXN0KGYpKSxcclxuICAgICAgICBnZXQobWFuaWZlc3QsIFwiYmFja2dyb3VuZC5zZXJ2aWNlX3dvcmtlclwiKSxcclxuICAgICAgICAuLi5nZXQoXHJcbiAgICAgICAgICAgIG1hbmlmZXN0LFxyXG4gICAgICAgICAgICBcImNvbnRlbnRfc2NyaXB0c1wiLFxyXG4gICAgICAgICAgICBbXSBhcyBDb250ZW50U2NyaXB0W10sXHJcbiAgICAgICAgKS5yZWR1Y2UoKHIsIHsganMgPSBbXSB9KSA9PiBbLi4uciwgLi4uanNdLCBbXSBhcyBzdHJpbmdbXSksXHJcbiAgICBdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogaHRtbCBmaWxlcyBjb21lIGZyb206XHJcbiAgICAgKiAgLSB3ZWJfYWNjZXNzaWJsZV9yZXNvdXJjZXNcclxuICAgICAqICAtIG9wdGlvbnNfcGFnZVxyXG4gICAgICogIC0gb3B0aW9uc191aS5wYWdlXHJcbiAgICAgKiAgLSBkZXZ0b29sc19wYWdlXHJcbiAgICAgKiAgLSBhY3Rpb24uZGVmYXVsdF9wb3B1cFxyXG4gICAgICogIC0gY2hyb21lX3VybF9vdmVycmlkZXNcclxuICAgICAqL1xyXG4gICAgY29uc3QgaHRtbCA9IFtcclxuICAgICAgICAuLi53ZWJfYWNjZXNzaWJsZV9yZXNvdXJjZXMuZmlsdGVyKChmOiBzdHJpbmcpID0+IC9cXC5odG1sPyQvLnRlc3QoZikpLFxyXG4gICAgICAgIGdldChtYW5pZmVzdCwgXCJvcHRpb25zX3BhZ2VcIiksXHJcbiAgICAgICAgZ2V0KG1hbmlmZXN0LCBcIm9wdGlvbnNfdWkucGFnZVwiKSxcclxuICAgICAgICBnZXQobWFuaWZlc3QsIFwiZGV2dG9vbHNfcGFnZVwiKSxcclxuICAgICAgICBnZXQobWFuaWZlc3QsIFwiYWN0aW9uLmRlZmF1bHRfcG9wdXBcIiksXHJcbiAgICAgICAgLi4uT2JqZWN0LnZhbHVlcyhnZXQobWFuaWZlc3QsIFwiY2hyb21lX3VybF9vdmVycmlkZXNcIiwge30pKSxcclxuICAgIF07XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBjc3MgZmlsZXMgY29tZSBmcm9tOlxyXG4gICAgICogIC0gd2ViX2FjY2Vzc2libGVfcmVzb3VyY2VzXHJcbiAgICAgKiAgLSBjb250ZW50X3NjcmlwdHNcclxuICAgICAqL1xyXG4gICAgY29uc3QgY3NzID0gW1xyXG4gICAgICAgIC4uLndlYl9hY2Nlc3NpYmxlX3Jlc291cmNlcy5maWx0ZXIoKGY6IHN0cmluZykgPT4gZi5lbmRzV2l0aChcIi5jc3NcIikpLFxyXG4gICAgICAgIC4uLmdldChcclxuICAgICAgICAgICAgbWFuaWZlc3QsXHJcbiAgICAgICAgICAgIFwiY29udGVudF9zY3JpcHRzXCIsXHJcbiAgICAgICAgICAgIFtdIGFzIENvbnRlbnRTY3JpcHRbXSxcclxuICAgICAgICApLnJlZHVjZShcclxuICAgICAgICAgICAgKHIsIHsgY3NzID0gW10gfSkgPT4gWy4uLnIsIC4uLmNzc10sXHJcbiAgICAgICAgICAgIFtdIGFzIHN0cmluZ1tdLFxyXG4gICAgICAgICksXHJcbiAgICBdO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogYWN0aW9uIGljb25zIGNvbWUgZnJvbTpcclxuICAgICAqICAtIHdlYl9hY2Nlc3NpYmxlX3Jlc291cmNlc1xyXG4gICAgICogIC0gY29udGVudF9zY3JpcHRzXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGFjdGlvbkljb25TZXQgPSBuZXcgU2V0PHN0cmluZz4oKTtcclxuICAgIGNvbnN0IGRlZmF1bHRfaWNvbnM6IHN0cmluZyB8IHsgW3NpemU6IHN0cmluZ106IHN0cmluZyB9ID0gZ2V0KFxyXG4gICAgICAgIG1hbmlmZXN0LFxyXG4gICAgICAgIFwiYWN0aW9uLmRlZmF1bHRfaWNvblwiLFxyXG4gICAgICAgIHt9IGFzIGFueSxcclxuICAgICk7XHJcbiAgICBpZiAodHlwZW9mIGRlZmF1bHRfaWNvbnMgPT09IFwic3RyaW5nXCIpIHtcclxuICAgICAgICBhY3Rpb25JY29uU2V0LmFkZChkZWZhdWx0X2ljb25zKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgT2JqZWN0LnZhbHVlcyhkZWZhdWx0X2ljb25zKS5mb3JFYWNoKCh4KSA9PiBhY3Rpb25JY29uU2V0LmFkZCh4KSk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBpbWFnZSBmaWxlcyBjb21lIGZyb206XHJcbiAgICAgKiAgLSB3ZWJfYWNjZXNzaWJsZV9yZXNvdXJjZXNcclxuICAgICAqICAtIGFjdGlvbi5kZWZhdWx0X2ljb25cclxuICAgICAqICAtIGljb25zXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGltZyA9IFtcclxuICAgICAgICAuLi5hY3Rpb25JY29uU2V0LFxyXG4gICAgICAgIC4uLndlYl9hY2Nlc3NpYmxlX3Jlc291cmNlcy5maWx0ZXIoKGYpID0+XHJcbiAgICAgICAgICAgIC9cXC4oanBlP2d8cG5nfHN2Z3x0aWZmP3xnaWZ8d2VicHxibXB8aWNvKSQvaS50ZXN0KGYpLFxyXG4gICAgICAgICksXHJcbiAgICAgICAgLi4uT2JqZWN0LnZhbHVlcyhnZXQobWFuaWZlc3QsIFwiaWNvbnNcIiwge30pKSxcclxuICAgIF07XHJcblxyXG4gICAgLy8gRmlsZXMgbGlrZSBmb250cywgdGhpbmdzIHRoYXQgYXJlIG5vdCBleHBlY3RlZFxyXG4gICAgY29uc3Qgb3RoZXJzID0gZGlmZih3ZWJfYWNjZXNzaWJsZV9yZXNvdXJjZXMsIGNzcywganMsIGh0bWwsIGltZyk7XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBjc3M6IHZhbGlkYXRlKGNzcyksXHJcbiAgICAgICAganM6IHZhbGlkYXRlKGpzKSxcclxuICAgICAgICBodG1sOiB2YWxpZGF0ZShodG1sKSxcclxuICAgICAgICBpbWc6IHZhbGlkYXRlKGltZyksXHJcbiAgICAgICAgb3RoZXJzOiB2YWxpZGF0ZShvdGhlcnMpLFxyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShhcnk6IGFueVtdKSB7XHJcbiAgICAgICAgcmV0dXJuIFsuLi5uZXcgU2V0KGFyeS5maWx0ZXIoaXNTdHJpbmcpKV0ubWFwKCh4KSA9PlxyXG4gICAgICAgICAgICBqb2luKHNyY0RpciwgeCksXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpc1N0cmluZyh4OiBhbnkpOiB4IGlzIHN0cmluZyB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB4ID09PSBcInN0cmluZ1wiO1xyXG4gICAgfVxyXG59XHJcbiIsImV4cG9ydCBmdW5jdGlvbiByZW1vdmVGaWxlRXh0ZW5zaW9uKGZpbGVQYXRoOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IGluZGV4ID0gZmlsZVBhdGgubGFzdEluZGV4T2YoXCIuXCIpO1xyXG4gICAgcmV0dXJuIGluZGV4ID4gLTEgPyBmaWxlUGF0aC5zdWJzdHJpbmcoMCwgaW5kZXgpIDogZmlsZVBhdGg7XHJcbn1cclxuIiwiaW1wb3J0IHsgSW5wdXRPcHRpb24gfSBmcm9tIFwicm9sbHVwXCI7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZmxhdHRlblJvbGx1cElucHV0KGlucHV0PzogSW5wdXRPcHRpb24pOiBzdHJpbmdbXSB7XHJcbiAgICBsZXQgaW5wdXRBcnJheTogc3RyaW5nW107XHJcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XHJcbiAgICAgICAgaW5wdXRBcnJheSA9IFtpbnB1dF07XHJcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XHJcbiAgICAgICAgaW5wdXRBcnJheSA9IFsuLi5pbnB1dF07XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIGlucHV0QXJyYXkgPSBPYmplY3QudmFsdWVzKGlucHV0KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcclxuICAgICAgICAgICAgYG9wdGlvbnMuaW5wdXQgY2Fubm90IGJlICR7dHlwZW9mIGlucHV0fWAsXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuICAgIHJldHVybiBpbnB1dEFycmF5O1xyXG59XHJcbiIsImltcG9ydCB7IGpvaW4gfSBmcm9tIFwicGF0aFwiO1xyXG5pbXBvcnQgeyBPdXRwdXRBc3NldCB9IGZyb20gXCJyb2xsdXBcIjtcclxuaW1wb3J0IHNsYXNoIGZyb20gXCJzbGFzaFwiO1xyXG5cclxuY29uc3QgY3NzVXJsUkUgPSAvKCg/PD11cmwgKlxcKCAqJyAqKVteKGRhdGE6KV1bXiddKyg/PSAqJyAqXFwpKXwoPzw9dXJsICpcXCggKlwiICopW14oZGF0YTopXVteXCJdKyg/PSAqXCIgKlxcKSl8KD88PXVybCAqXFwoICopW14oZGF0YTopXVteJ1wiKV0rKD89ICpcXCkpKS9nXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZUNzc1VybChjb2RlOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IHJlc291cmNlcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xyXG4gICAgY29uc3QgdXBkYXRlZENvZGUgPSBjb2RlLnJlcGxhY2UoY3NzVXJsUkUsIChzdWJzdHJpbmcpID0+IHtcclxuICAgICAgICBjb25zdCB1cmwgPSBzdWJzdHJpbmcudHJpbSgpO1xyXG4gICAgICAgIGlmICh1cmwpIHtcclxuICAgICAgICAgICAgcmVzb3VyY2VzLmFkZCh1cmwpO1xyXG4gICAgICAgICAgICByZXR1cm4gXCJjaHJvbWUtZXh0ZW5zaW9uOi8vXCIgKyBzbGFzaChqb2luKFwiX19NU0dfQEBleHRlbnNpb25faWRfX1wiLCBzdWJzdHJpbmcudHJpbSgpKSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzb3VyY2VzLnNpemUgPiAwXHJcbiAgICAgICAgPyB7IGNvZGU6IHVwZGF0ZWRDb2RlLCByZXNvdXJjZXM6IEFycmF5LmZyb20ocmVzb3VyY2VzKSB9XHJcbiAgICAgICAgOiB7IGNvZGU6IHVwZGF0ZWRDb2RlIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVDc3MoYXNzZXQ6IE91dHB1dEFzc2V0KSB7XHJcbiAgICBpZiAodHlwZW9mIGFzc2V0LnNvdXJjZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgIC8vIHVwZGF0ZSB1cmwoKSBpbiBjc3NcclxuICAgICAgICBjb25zdCB7IGNvZGUsIHJlc291cmNlcyB9ID0gcmVwbGFjZUNzc1VybChhc3NldC5zb3VyY2UpO1xyXG4gICAgICAgIGFzc2V0LnNvdXJjZSA9IGNvZGU7XHJcbiAgICAgICAgcmV0dXJuIHsgYXNzZXQsIHJlc291cmNlcyB9O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHsgYXNzZXQgfTtcclxufVxyXG4iLCJpbXBvcnQgeyBkaXJuYW1lLCBqb2luIH0gZnJvbSBcInBhdGhcIjtcclxuaW1wb3J0IHsgT3V0cHV0QnVuZGxlLCBPdXRwdXRDaHVuaywgUGx1Z2luIH0gZnJvbSBcInJvbGx1cFwiO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIG1peGluUGx1Z2luKFxyXG4gICAgYnVuZGxlOiBPdXRwdXRCdW5kbGUsXHJcbik6IFBsdWdpbiB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5hbWU6IFwibWl4aW5cIixcclxuICAgICAgICByZXNvbHZlSWQoc291cmNlLCBpbXBvcnRlcikge1xyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbXBvcnRlciA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2U7XHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpciA9IGRpcm5hbWUoaW1wb3J0ZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkID0gam9pbihkaXIsIHNvdXJjZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVkIGluIGJ1bmRsZSA/IHJlc29sdmVkIDogZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInJlc29sdmVJZFwiLCBlcnJvcik7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbG9hZChpZCkge1xyXG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IGJ1bmRsZVtpZF0gYXMgT3V0cHV0Q2h1bms7XHJcbiAgICAgICAgICAgIGlmIChjaHVuaykge1xyXG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIGNodW5rIGZyb20gYnVuZGxlXHJcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnZhbHVlcyhidW5kbGUpLmZpbHRlcihjID0+IGMudHlwZSA9PT0gXCJjaHVua1wiICYmIGMuaW1wb3J0cy5pbmNsdWRlcyhjaHVuay5maWxlTmFtZSkpLmxlbmd0aCA8IDEpIHtcclxuICAgICAgICAgICAgICAgICAgICBkZWxldGUgYnVuZGxlW2lkXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29kZTogY2h1bmsuY29kZSxcclxuICAgICAgICAgICAgICAgICAgICBtYXA6IGNodW5rLm1hcCxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgT3V0cHV0QnVuZGxlLCBPdXRwdXRDaHVuaywgUGx1Z2luQ29udGV4dCwgcm9sbHVwIH0gZnJvbSBcInJvbGx1cFwiO1xyXG5pbXBvcnQgeyBtaXhpblBsdWdpbiB9IGZyb20gXCIuL21peGluLnBsdWdpblwiO1xyXG5cclxuLyoqXHJcbiAqIGJ1bmRsZSBlbnRyeSBjaHVuayBhbmQgaXRzIGRlcGVuZGVuY2VzIGludG8gb25lIElJRkUgY2h1bmtcclxuICogdGhpcyBmdW5jdGlvbiB3aWxsIHJlcGxhY2UgdGhlIGVudHJ5IGNodW5rXHJcbiAqIEBwYXJhbSBjb250ZXh0OiBjb250ZXh0IG9mIHBhcmVudCByb2xsdXAgcHJvY2Vzc1xyXG4gKiBAcGFyYW0gZW50cnk6IGNodW5rIGFzIGVudHJ5IHBvaW50XHJcbiAqIEBwYXJhbSBidW5kbGU6IGNodW5rcyBidW5kbGVkIGJ5IHBhcmVudCByb2xsdXAgcHJvY2Vzc1xyXG4gKiBAcmV0dXJuc1xyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIG1peGluQ2h1bmtzRm9ySUlGRShcclxuICAgIGNvbnRleHQ6IFBsdWdpbkNvbnRleHQsXHJcbiAgICBlbnRyeTogT3V0cHV0Q2h1bmssXHJcbiAgICBidW5kbGU6IE91dHB1dEJ1bmRsZVxyXG4pOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgY29uc3QgYnVpbGQgPSBhd2FpdCByb2xsdXAoe1xyXG4gICAgICAgIGlucHV0OiBlbnRyeS5maWxlTmFtZSxcclxuICAgICAgICBwbHVnaW5zOiBbbWl4aW5QbHVnaW4oYnVuZGxlKV1cclxuICAgIH0pO1xyXG4gICAgY29uc3Qgb3V0cHV0cyA9IChhd2FpdCBidWlsZC5nZW5lcmF0ZSh7IGZvcm1hdDogXCJpaWZlXCIgfSkpLm91dHB1dDtcclxuICAgIGlmIChvdXRwdXRzLmxlbmd0aCA8IDEpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJcIik7XHJcbiAgICB9IGVsc2UgaWYgKG91dHB1dHMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1peCBjb250ZW50IHNjcmlwdCBjaHVua3MgZXJyb3I6IG91dHB1dCBtdXN0IGNvbnRhaW4gb25seSBvbmUgY2h1bmsuXCIpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgb3V0cHV0Q2h1bmsgPSBvdXRwdXRzWzBdO1xyXG4gICAgY29uc3QgcmVmZXJlbmNlSWQgPSBjb250ZXh0LmVtaXRGaWxlKHtcclxuICAgICAgICB0eXBlOiBcImFzc2V0XCIsXHJcbiAgICAgICAgc291cmNlOiBvdXRwdXRDaHVuay5jb2RlLFxyXG4gICAgICAgIGZpbGVOYW1lOiBlbnRyeS5maWxlTmFtZVxyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gY29udGV4dC5nZXRGaWxlTmFtZShyZWZlcmVuY2VJZCk7XHJcbn1cclxuIiwiaW1wb3J0IHNsYXNoIGZyb20gXCJzbGFzaFwiO1xyXG5pbXBvcnQgeyBPdXRwdXRBc3NldCwgT3V0cHV0QnVuZGxlLCBPdXRwdXRDaHVuaywgUGx1Z2luQ29udGV4dCwgcm9sbHVwIH0gZnJvbSBcInJvbGx1cFwiO1xyXG5pbXBvcnQgeyByZW1vdmVGaWxlRXh0ZW5zaW9uIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi91dGlsc1wiO1xyXG5pbXBvcnQgeyBDaHJvbWVFeHRlbnNpb25NYW5pZmVzdCwgV2ViQWNjZXNzaWJsZVJlc291cmNlIH0gZnJvbSBcIi4uLy4uL21hbmlmZXN0XCI7XHJcbmltcG9ydCB7IE5vcm1hbGl6ZWRDaHJvbWVFeHRlbnNpb25PcHRpb25zIH0gZnJvbSBcIi4uLy4uL3BsdWdpbi1vcHRpb25zXCI7XHJcbmltcG9ydCB7IGZpbmRBc3NldEJ5TmFtZSwgZmluZENodW5rQnlOYW1lIH0gZnJvbSBcIi4uLy4uL3V0aWxzL2hlbHBlcnNcIjtcclxuaW1wb3J0IHsgdXBkYXRlQ3NzIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi91dGlscy9jc3NcIjtcclxuaW1wb3J0IHsgbWl4aW5DaHVua3NGb3JJSUZFIH0gZnJvbSBcIi4uL21peGluXCI7XHJcblxyXG5leHBvcnQgY2xhc3MgQ29udGVudFNjcmlwdFByb2Nlc3NvciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIG9wdGlvbnM6IE5vcm1hbGl6ZWRDaHJvbWVFeHRlbnNpb25PcHRpb25zKSB7fVxyXG4gICAgcHVibGljIGFzeW5jIGdlbmVyYXRlQnVuZGxlKFxyXG4gICAgICAgIGNvbnRleHQ6IFBsdWdpbkNvbnRleHQsXHJcbiAgICAgICAgYnVuZGxlOiBPdXRwdXRCdW5kbGUsXHJcbiAgICAgICAgbWFuaWZlc3Q6IENocm9tZUV4dGVuc2lvbk1hbmlmZXN0LFxyXG4gICAgKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICAgICAgZm9yIChjb25zdCBjb250ZW50X3NjcmlwdCBvZiBtYW5pZmVzdC5jb250ZW50X3NjcmlwdHMgfHwgW10pIHtcclxuICAgICAgICAgICAgY29uc3Qge2pzLCBjc3MsIC4uLnJlc3R9ID0gY29udGVudF9zY3JpcHRcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBqcyA9PT0gXCJ1bmRlZmluZWRcIikgeyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAvLyBwcm9jZXNzIHJlbGF0ZWQgY3NzXHJcbiAgICAgICAgICAgIGpzLm1hcChuYW1lID0+IGZpbmRBc3NldEJ5TmFtZShgJHtyZW1vdmVGaWxlRXh0ZW5zaW9uKG5hbWUpfS5jc3NgLCBidW5kbGUpIGFzIE91dHB1dEFzc2V0KVxyXG4gICAgICAgICAgICAgICAgLmZpbHRlcihhc3NldCA9PiAhIWFzc2V0KVxyXG4gICAgICAgICAgICAgICAgLm1hcChhc3NldCA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBhc3NldDogYXN0LCByZXNvdXJjZXMgfSA9IHVwZGF0ZUNzcyhhc3NldCk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHJlc291cmNlIHRvIHdlYl9hY2Nlc3NpYmxlX3Jlc291cmNlc1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNvdXJjZXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2ViX2FjY2Vzc2libGVfcmVzb3VyY2VzOiBXZWJBY2Nlc3NpYmxlUmVzb3VyY2UgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvdXJjZXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVzOiByZXN0Lm1hdGNoZXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1hbmlmZXN0LndlYl9hY2Nlc3NpYmxlX3Jlc291cmNlcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFuaWZlc3Qud2ViX2FjY2Vzc2libGVfcmVzb3VyY2VzID0gW3dlYl9hY2Nlc3NpYmxlX3Jlc291cmNlc107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYW5pZmVzdC53ZWJfYWNjZXNzaWJsZV9yZXNvdXJjZXMucHVzaCh3ZWJfYWNjZXNzaWJsZV9yZXNvdXJjZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhc3Q7XHJcbiAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgLmZvckVhY2goYXNzZXQgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNzc0ZpbGVOYW1lID0gc2xhc2goYXNzZXQuZmlsZU5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNzcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjc3MucHVzaChjc3NGaWxlTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudF9zY3JpcHQuY3NzID0gW2Nzc0ZpbGVOYW1lXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgLy8gbWl4aW4gcmVsYXRlZCBqc1xyXG4gICAgICAgICAgICBjb250ZW50X3NjcmlwdC5qcyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGpzTmFtZSBvZiBqcykge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBmaW5kQ2h1bmtCeU5hbWUocmVtb3ZlRmlsZUV4dGVuc2lvbihqc05hbWUpLCBidW5kbGUpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGNodW5rKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGVudF9zY3JpcHQuanMucHVzaChzbGFzaChhd2FpdCBtaXhpbkNodW5rc0ZvcklJRkUoY29udGV4dCwgY2h1bmssIGJ1bmRsZSkpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2VuZXJhdGVCdW5kbGVGcm9tRHluYW1pY0ltcG9ydHMoXHJcbiAgICAgICAgY29udGV4dDogUGx1Z2luQ29udGV4dCxcclxuICAgICAgICBidW5kbGU6IE91dHB1dEJ1bmRsZSxcclxuICAgICAgICBkeW5hbWljSW1wb3J0czogc3RyaW5nW10sXHJcbiAgICApIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGR5bmFtaWNJbXBvcnQgb2YgZHluYW1pY0ltcG9ydHMpIHtcclxuICAgICAgICAgICAgY29uc3QgZmlsZW5hbWUgPSBjb250ZXh0LmdldEZpbGVOYW1lKGR5bmFtaWNJbXBvcnQpO1xyXG4gICAgICAgICAgICBjb25zdCBjaHVuayA9IGJ1bmRsZVtmaWxlbmFtZV07XHJcbiAgICAgICAgICAgIGlmIChjaHVuayAmJiBjaHVuay50eXBlID09PSBcImNodW5rXCIpIHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IG1peGluQ2h1bmtzRm9ySUlGRShjb250ZXh0LCBjaHVuaywgYnVuZGxlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCIvKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xyXG4vKiAgICAgICAgICAgICAgIENIRUNLIFBFUk1JU1NJT05TICAgICAgICAgICAgICAqL1xyXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSAqL1xyXG5cclxuLy8gZXhwb3J0IGNvbnN0IGRlYnVnZ2VyID0gcyA9PiAvKChjaHJvbWVwPyl8KGJyb3dzZXIpKVtcXHNcXG5dKlxcLltcXHNcXG5dKmRlYnVnZ2VyLy50ZXN0KHMpXHJcbi8vIGV4cG9ydCBjb25zdCBlbnRlcnByaXNlLmRldmljZUF0dHJpYnV0ZXMgPSBzID0+IC8oKGNocm9tZXA/KXwoYnJvd3NlcikpW1xcc1xcbl0qXFwuW1xcc1xcbl0qZW50ZXJwcmlzZVxcLmRldmljZUF0dHJpYnV0ZXMvLnRlc3QocylcclxuLy8gZXhwb3J0IGNvbnN0IGVudGVycHJpc2UuaGFyZHdhcmVQbGF0Zm9ybSA9IHMgPT4gLygoY2hyb21lcD8pfChicm93c2VyKSlbXFxzXFxuXSpcXC5bXFxzXFxuXSplbnRlcnByaXNlXFwuaGFyZHdhcmVQbGF0Zm9ybS8udGVzdChzKVxyXG4vLyBleHBvcnQgY29uc3QgZW50ZXJwcmlzZS5wbGF0Zm9ybUtleXMgPSBzID0+IC8oKGNocm9tZXA/KXwoYnJvd3NlcikpW1xcc1xcbl0qXFwuW1xcc1xcbl0qZW50ZXJwcmlzZVxcLnBsYXRmb3JtS2V5cy8udGVzdChzKVxyXG4vLyBleHBvcnQgY29uc3QgbmV0d29ya2luZy5jb25maWcgPSBzID0+IC8oKGNocm9tZXA/KXwoYnJvd3NlcikpW1xcc1xcbl0qXFwuW1xcc1xcbl0qbmV0d29ya2luZ1xcLmNvbmZpZy8udGVzdChzKVxyXG4vLyBleHBvcnQgY29uc3Qgc3lzdGVtLmNwdSA9IHMgPT4gLygoY2hyb21lcD8pfChicm93c2VyKSlbXFxzXFxuXSpcXC5bXFxzXFxuXSpzeXN0ZW1cXC5jcHUvLnRlc3QocylcclxuLy8gZXhwb3J0IGNvbnN0IHN5c3RlbS5kaXNwbGF5ID0gcyA9PiAvKChjaHJvbWVwPyl8KGJyb3dzZXIpKVtcXHNcXG5dKlxcLltcXHNcXG5dKnN5c3RlbVxcLmRpc3BsYXkvLnRlc3QocylcclxuLy8gZXhwb3J0IGNvbnN0IHN5c3RlbS5tZW1vcnkgPSBzID0+IC8oKGNocm9tZXA/KXwoYnJvd3NlcikpW1xcc1xcbl0qXFwuW1xcc1xcbl0qc3lzdGVtXFwubWVtb3J5Ly50ZXN0KHMpXHJcbi8vIGV4cG9ydCBjb25zdCBzeXN0ZW0uc3RvcmFnZSA9IHMgPT4gLygoY2hyb21lcD8pfChicm93c2VyKSlbXFxzXFxuXSpcXC5bXFxzXFxuXSpzeXN0ZW1cXC5zdG9yYWdlLy50ZXN0KHMpXHJcblxyXG5leHBvcnQgY29uc3QgYWxhcm1zID0gKHM6IHN0cmluZykgPT5cclxuICAgIC8oKGNocm9tZXA/KXwoYnJvd3NlcikpW1xcc1xcbl0qXFwuW1xcc1xcbl0qYWxhcm1zLy50ZXN0KHMpO1xyXG5cclxuZXhwb3J0IGNvbnN0IGJvb2ttYXJrcyA9IChzOiBzdHJpbmcpID0+XHJcbiAgICAvKChjaHJvbWVwPyl8KGJyb3dzZXIpKVtcXHNcXG5dKlxcLltcXHNcXG5dKmJvb2ttYXJrcy8udGVzdChzKTtcclxuXHJcbmV4cG9ydCBjb25zdCBjb250ZW50U2V0dGluZ3MgPSAoczogc3RyaW5nKSA9PlxyXG4gICAgLygoY2hyb21lcD8pfChicm93c2VyKSlbXFxzXFxuXSpcXC5bXFxzXFxuXSpjb250ZW50U2V0dGluZ3MvLnRlc3Qocyk7XHJcblxyXG5leHBvcnQgY29uc3QgY29udGV4dE1lbnVzID0gKHM6IHN0cmluZykgPT5cclxuICAgIC8oKGNocm9tZXA/KXwoYnJvd3NlcikpW1xcc1xcbl0qXFwuW1xcc1xcbl0qY29udGV4dE1lbnVzLy50ZXN0KHMpO1xyXG5cclxuZXhwb3J0IGNvbnN0IGNvb2tpZXMgPSAoczogc3RyaW5nKSA9PlxyXG4gICAgLygoY2hyb21lcD8pfChicm93c2VyKSlbXFxzXFxuXSpcXC5bXFxzXFxuXSpjb29raWVzLy50ZXN0KHMpO1xyXG5cclxuZXhwb3J0IGNvbnN0IGRlY2xhcmF0aXZlQ29udGVudCA9IChzOiBzdHJpbmcpID0+XHJcbiAgICAvKChjaHJvbWVwPyl8KGJyb3dzZXIpKVtcXHNcXG5dKlxcLltcXHNcXG5dKmRlY2xhcmF0aXZlQ29udGVudC8udGVzdChzKTtcclxuZXhwb3J0IGNvbnN0IGRlY2xhcmF0aXZlTmV0UmVxdWVzdCA9IChzOiBzdHJpbmcpID0+XHJcbiAgICAvKChjaHJvbWVwPyl8KGJyb3dzZXIpKVtcXHNcXG5dKlxcLltcXHNcXG5dKmRlY2xhcmF0aXZlTmV0UmVxdWVzdC8udGVzdChzKTtcclxuZXhwb3J0IGNvbnN0IGRlY2xhcmF0aXZlV2ViUmVxdWVzdCA9IChzOiBzdHJpbmcpID0+XHJcbiAgICAvKChjaHJvbWVwPyl8KGJyb3dzZXIpKVtcXHNcXG5dKlxcLltcXHNcXG5dKmRlY2xhcmF0aXZlV2ViUmVxdWVzdC8udGVzdChzKTtcclxuZXhwb3J0IGNvbnN0IGRlc2t0b3BDYXB0dXJlID0gKHM6IHN0cmluZykgPT5cclxuICAgIC8oKGNocm9tZXA/KXwoYnJvd3NlcikpW1xcc1xcbl0qXFwuW1xcc1xcbl0qZGVza3RvcENhcHR1cmUvLnRlc3Qocyk7XHJcbmV4cG9ydCBjb25zdCBkaXNwbGF5U291cmNlID0gKHM6IHN0cmluZykgPT5cclxuICAgIC8oKGNocm9tZXA/KXwoYnJvd3NlcikpW1xcc1xcbl0qXFwuW1xcc1xcbl0qZGlzcGxheVNvdXJjZS8udGVzdChzKTtcclxuZXhwb3J0IGNvbnN0IGRucyA9IChzOiBzdHJpbmcpID0+XHJcbiAgICAvKChjaHJvbWVwPyl8KGJyb3dzZXIpKVtcXHNcXG5dKlxcLltcXHNcXG5dKmRucy8udGVzdChzKTtcclxuZXhwb3J0IGNvbnN0IGRvY3VtZW50U2NhbiA9IChzOiBzdHJpbmcpID0+XHJcbiAgICAvKChjaHJvbWVwPyl8KGJyb3dzZXIpKVtcXHNcXG5dKlxcLltcXHNcXG5dKmRvY3VtZW50U2Nhbi8udGVzdChzKTtcclxuZXhwb3J0IGNvbnN0IGRvd25sb2FkcyA9IChzOiBzdHJpbmcpID0+XHJcbiAgICAvKChjaHJvbWVwPyl8KGJyb3dzZXIpKVtcXHNcXG5dKlxcLltcXHNcXG5dKmRvd25sb2Fkcy8udGVzdChzKTtcclxuZXhwb3J0IGNvbnN0IGV4cGVyaW1lbnRhbCA9IChzOiBzdHJpbmcpID0+XHJcbiAgICAvKChjaHJvbWVwPyl8KGJyb3dzZXIpKVtcXHNcXG5dKlxcLltcXHNcXG5dKmV4cGVyaW1lbnRhbC8udGVzdChzKTtcclxuZXhwb3J0IGNvbnN0IGZpbGVCcm93c2VySGFuZGxlciA9IChzOiBzdHJpbmcpID0+XHJcbiAgICAvKChjaHJvbWVwPyl8KGJyb3dzZXIpKVtcXHNcXG5dKlxcLltcXHNcXG5dKmZpbGVCcm93c2VySGFuZGxlci8udGVzdChzKTtcclxuZXhwb3J0IGNvbnN0IGZpbGVTeXN0ZW1Qcm92aWRlciA9IChzOiBzdHJpbmcpID0+XHJcbiAgICAvKChjaHJvbWVwPyl8KGJyb3dzZXIpKVtcXHNcXG5dKlxcLltcXHNcXG5dKmZpbGVTeXN0ZW1Qcm92aWRlci8udGVzdChzKTtcclxuZXhwb3J0IGNvbnN0IGZvbnRTZXR0aW5ncyA9IChzOiBzdHJpbmcpID0+XHJcbiAgICAvKChjaHJvbWVwPyl8KGJyb3dzZXIpKVtcXHNcXG5dKlxcLltcXHNcXG5dKmZvbnRTZXR0aW5ncy8udGVzdChzKTtcclxuZXhwb3J0IGNvbnN0IGdjbSA9IChzOiBzdHJpbmcpID0+XHJcbiAgICAvKChjaHJvbWVwPyl8KGJyb3dzZXIpKVtcXHNcXG5dKlxcLltcXHNcXG5dKmdjbS8udGVzdChzKTtcclxuZXhwb3J0IGNvbnN0IGdlb2xvY2F0aW9uID0gKHM6IHN0cmluZykgPT5cclxuICAgIC8oKGNocm9tZXA/KXwoYnJvd3NlcikpW1xcc1xcbl0qXFwuW1xcc1xcbl0qZ2VvbG9jYXRpb24vLnRlc3Qocyk7XHJcbmV4cG9ydCBjb25zdCBoaXN0b3J5ID0gKHM6IHN0cmluZykgPT5cclxuICAgIC8oKGNocm9tZXA/KXwoYnJvd3NlcikpW1xcc1xcbl0qXFwuW1xcc1xcbl0qaGlzdG9yeS8udGVzdChzKTtcclxuZXhwb3J0IGNvbnN0IGlkZW50aXR5ID0gKHM6IHN0cmluZykgPT5cclxuICAgIC8oKGNocm9tZXA/KXwoYnJvd3NlcikpW1xcc1xcbl0qXFwuW1xcc1xcbl0qaWRlbnRpdHkvLnRlc3Qocyk7XHJcbmV4cG9ydCBjb25zdCBpZGxlID0gKHM6IHN0cmluZykgPT5cclxuICAgIC8oKGNocm9tZXA/KXwoYnJvd3NlcikpW1xcc1xcbl0qXFwuW1xcc1xcbl0qaWRsZS8udGVzdChzKTtcclxuZXhwb3J0IGNvbnN0IGlkbHRlc3QgPSAoczogc3RyaW5nKSA9PlxyXG4gICAgLygoY2hyb21lcD8pfChicm93c2VyKSlbXFxzXFxuXSpcXC5bXFxzXFxuXSppZGx0ZXN0Ly50ZXN0KHMpO1xyXG5leHBvcnQgY29uc3QgbWFuYWdlbWVudCA9IChzOiBzdHJpbmcpID0+XHJcbiAgICAvKChjaHJvbWVwPyl8KGJyb3dzZXIpKVtcXHNcXG5dKlxcLltcXHNcXG5dKm1hbmFnZW1lbnQvLnRlc3Qocyk7XHJcbmV4cG9ydCBjb25zdCBuYXRpdmVNZXNzYWdpbmcgPSAoczogc3RyaW5nKSA9PlxyXG4gICAgLygoY2hyb21lcD8pfChicm93c2VyKSlbXFxzXFxuXSpcXC5bXFxzXFxuXSpuYXRpdmVNZXNzYWdpbmcvLnRlc3Qocyk7XHJcbmV4cG9ydCBjb25zdCBub3RpZmljYXRpb25zID0gKHM6IHN0cmluZykgPT5cclxuICAgIC8oKGNocm9tZXA/KXwoYnJvd3NlcikpW1xcc1xcbl0qXFwuW1xcc1xcbl0qbm90aWZpY2F0aW9ucy8udGVzdChzKTtcclxuZXhwb3J0IGNvbnN0IHBhZ2VDYXB0dXJlID0gKHM6IHN0cmluZykgPT5cclxuICAgIC8oKGNocm9tZXA/KXwoYnJvd3NlcikpW1xcc1xcbl0qXFwuW1xcc1xcbl0qcGFnZUNhcHR1cmUvLnRlc3Qocyk7XHJcbmV4cG9ydCBjb25zdCBwbGF0Zm9ybUtleXMgPSAoczogc3RyaW5nKSA9PlxyXG4gICAgLygoY2hyb21lcD8pfChicm93c2VyKSlbXFxzXFxuXSpcXC5bXFxzXFxuXSpwbGF0Zm9ybUtleXMvLnRlc3Qocyk7XHJcbmV4cG9ydCBjb25zdCBwb3dlciA9IChzOiBzdHJpbmcpID0+XHJcbiAgICAvKChjaHJvbWVwPyl8KGJyb3dzZXIpKVtcXHNcXG5dKlxcLltcXHNcXG5dKnBvd2VyLy50ZXN0KHMpO1xyXG5leHBvcnQgY29uc3QgcHJpbnRlclByb3ZpZGVyID0gKHM6IHN0cmluZykgPT5cclxuICAgIC8oKGNocm9tZXA/KXwoYnJvd3NlcikpW1xcc1xcbl0qXFwuW1xcc1xcbl0qcHJpbnRlclByb3ZpZGVyLy50ZXN0KHMpO1xyXG5leHBvcnQgY29uc3QgcHJpdmFjeSA9IChzOiBzdHJpbmcpID0+XHJcbiAgICAvKChjaHJvbWVwPyl8KGJyb3dzZXIpKVtcXHNcXG5dKlxcLltcXHNcXG5dKnByaXZhY3kvLnRlc3Qocyk7XHJcbmV4cG9ydCBjb25zdCBwcm9jZXNzZXMgPSAoczogc3RyaW5nKSA9PlxyXG4gICAgLygoY2hyb21lcD8pfChicm93c2VyKSlbXFxzXFxuXSpcXC5bXFxzXFxuXSpwcm9jZXNzZXMvLnRlc3Qocyk7XHJcbmV4cG9ydCBjb25zdCBwcm94eSA9IChzOiBzdHJpbmcpID0+XHJcbiAgICAvKChjaHJvbWVwPyl8KGJyb3dzZXIpKVtcXHNcXG5dKlxcLltcXHNcXG5dKnByb3h5Ly50ZXN0KHMpO1xyXG5leHBvcnQgY29uc3Qgc2Vzc2lvbnMgPSAoczogc3RyaW5nKSA9PlxyXG4gICAgLygoY2hyb21lcD8pfChicm93c2VyKSlbXFxzXFxuXSpcXC5bXFxzXFxuXSpzZXNzaW9ucy8udGVzdChzKTtcclxuZXhwb3J0IGNvbnN0IHNpZ25lZEluRGV2aWNlcyA9IChzOiBzdHJpbmcpID0+XHJcbiAgICAvKChjaHJvbWVwPyl8KGJyb3dzZXIpKVtcXHNcXG5dKlxcLltcXHNcXG5dKnNpZ25lZEluRGV2aWNlcy8udGVzdChzKTtcclxuZXhwb3J0IGNvbnN0IHN0b3JhZ2UgPSAoczogc3RyaW5nKSA9PlxyXG4gICAgLygoY2hyb21lcD8pfChicm93c2VyKSlbXFxzXFxuXSpcXC5bXFxzXFxuXSpzdG9yYWdlLy50ZXN0KHMpO1xyXG5leHBvcnQgY29uc3QgdGFiQ2FwdHVyZSA9IChzOiBzdHJpbmcpID0+XHJcbiAgICAvKChjaHJvbWVwPyl8KGJyb3dzZXIpKVtcXHNcXG5dKlxcLltcXHNcXG5dKnRhYkNhcHR1cmUvLnRlc3Qocyk7XHJcbi8vIGV4cG9ydCBjb25zdCB0YWJzID0gcyA9PiAvKChjaHJvbWVwPyl8KGJyb3dzZXIpKVtcXHNcXG5dKlxcLltcXHNcXG5dKnRhYnMvLnRlc3QocylcclxuZXhwb3J0IGNvbnN0IHRvcFNpdGVzID0gKHM6IHN0cmluZykgPT5cclxuICAgIC8oKGNocm9tZXA/KXwoYnJvd3NlcikpW1xcc1xcbl0qXFwuW1xcc1xcbl0qdG9wU2l0ZXMvLnRlc3Qocyk7XHJcbmV4cG9ydCBjb25zdCB0dHMgPSAoczogc3RyaW5nKSA9PlxyXG4gICAgLygoY2hyb21lcD8pfChicm93c2VyKSlbXFxzXFxuXSpcXC5bXFxzXFxuXSp0dHMvLnRlc3Qocyk7XHJcbmV4cG9ydCBjb25zdCB0dHNFbmdpbmUgPSAoczogc3RyaW5nKSA9PlxyXG4gICAgLygoY2hyb21lcD8pfChicm93c2VyKSlbXFxzXFxuXSpcXC5bXFxzXFxuXSp0dHNFbmdpbmUvLnRlc3Qocyk7XHJcbmV4cG9ydCBjb25zdCB1bmxpbWl0ZWRTdG9yYWdlID0gKHM6IHN0cmluZykgPT5cclxuICAgIC8oKGNocm9tZXA/KXwoYnJvd3NlcikpW1xcc1xcbl0qXFwuW1xcc1xcbl0qdW5saW1pdGVkU3RvcmFnZS8udGVzdChzKTtcclxuZXhwb3J0IGNvbnN0IHZwblByb3ZpZGVyID0gKHM6IHN0cmluZykgPT5cclxuICAgIC8oKGNocm9tZXA/KXwoYnJvd3NlcikpW1xcc1xcbl0qXFwuW1xcc1xcbl0qdnBuUHJvdmlkZXIvLnRlc3Qocyk7XHJcbmV4cG9ydCBjb25zdCB3YWxscGFwZXIgPSAoczogc3RyaW5nKSA9PlxyXG4gICAgLygoY2hyb21lcD8pfChicm93c2VyKSlbXFxzXFxuXSpcXC5bXFxzXFxuXSp3YWxscGFwZXIvLnRlc3Qocyk7XHJcbmV4cG9ydCBjb25zdCB3ZWJOYXZpZ2F0aW9uID0gKHM6IHN0cmluZykgPT5cclxuICAgIC8oKGNocm9tZXA/KXwoYnJvd3NlcikpW1xcc1xcbl0qXFwuW1xcc1xcbl0qd2ViTmF2aWdhdGlvbi8udGVzdChzKTtcclxuZXhwb3J0IGNvbnN0IHdlYlJlcXVlc3QgPSAoczogc3RyaW5nKSA9PlxyXG4gICAgLygoY2hyb21lcD8pfChicm93c2VyKSlbXFxzXFxuXSpcXC5bXFxzXFxuXSp3ZWJSZXF1ZXN0Ly50ZXN0KHMpO1xyXG5leHBvcnQgY29uc3Qgd2ViUmVxdWVzdEJsb2NraW5nID0gKHM6IHN0cmluZykgPT5cclxuICAgIHdlYlJlcXVlc3QocykgJiYgcy5pbmNsdWRlcyhcIidibG9ja2luZydcIik7XHJcblxyXG4vLyBUT0RPOiBhZGQgcmVhZENsaXBib2FyZFxyXG4vLyBUT0RPOiBhZGQgd3JpdGVDbGlwYm9hcmRcclxuIiwiaW1wb3J0IHsgT3V0cHV0Q2h1bmssIFBsdWdpbkNvbnRleHQgfSBmcm9tIFwicm9sbHVwXCI7XHJcbmltcG9ydCB7IE91dHB1dENodW5rQnVuZGxlIH0gZnJvbSBcIi4uL2NvbW1vbi9tb2RlbHNcIjtcclxuaW1wb3J0IHsgQ2hyb21lRXh0ZW5zaW9uTWFuaWZlc3QgfSBmcm9tIFwiLi4vbWFuaWZlc3RcIjtcclxuaW1wb3J0ICogYXMgcGVybWlzc2lvbnMgZnJvbSBcIi4uL21hbmlmZXN0LWlucHV0L21hbmlmZXN0LXBhcnNlci9wZXJtaXNzaW9uc1wiO1xyXG5cclxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cclxuLyogICAgICAgICAgICAgIERFUklWRSBQRVJNSVNTSU9OUyAgICAgICAgICAgICAgKi9cclxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0gKi9cclxuZXhwb3J0IGNvbnN0IGRlcml2ZVBlcm1pc3Npb25zID0gKFxyXG4gICAgc2V0OiBTZXQ8c3RyaW5nPixcclxuICAgIHsgY29kZSB9OiBPdXRwdXRDaHVuayxcclxuKSA9PlxyXG4gICAgT2JqZWN0LmVudHJpZXMocGVybWlzc2lvbnMpXHJcbiAgICAgICAgLmZpbHRlcigoWywgZm5dKSA9PiBmbihjb2RlKSlcclxuICAgICAgICAubWFwKChba2V5XSkgPT4ga2V5KVxyXG4gICAgICAgIC5yZWR1Y2UoKHMsIHApID0+IHMuYWRkKHApLCBzZXQpO1xyXG5cclxuZXhwb3J0IGNsYXNzIFBlcm1pc3Npb25Qcm9jZXNzb3JDYWNoZSB7XHJcbiAgICBwdWJsaWMgcGVybXNIYXNoID0gXCJcIjtcclxuICAgIHB1YmxpYyBhc3NldENoYW5nZWQgPSBmYWxzZTtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFBlcm1pc3Npb25Qcm9jZXNzb3JPcHRpb25zIHtcclxuICAgIHB1YmxpYyB2ZXJib3NlID0gdHJ1ZTtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFBlcm1pc3Npb25Qcm9jZXNzb3Ige1xyXG4gICAgcHJpdmF0ZSBjYWNoZSA9IG5ldyBQZXJtaXNzaW9uUHJvY2Vzc29yQ2FjaGUoKTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IocHJpdmF0ZSBvcHRpb25zOiBQZXJtaXNzaW9uUHJvY2Vzc29yT3B0aW9ucykge31cclxuXHJcbiAgICBwdWJsaWMgZGVyaXZlUGVybWlzc2lvbnMoXHJcbiAgICAgICAgY29udGV4dDogUGx1Z2luQ29udGV4dCxcclxuICAgICAgICBjaHVua3M6IE91dHB1dENodW5rQnVuZGxlLFxyXG4gICAgICAgIG1hbmlmZXN0OiBDaHJvbWVFeHRlbnNpb25NYW5pZmVzdCxcclxuICAgICk6IHZvaWQge1xyXG4gICAgICAgIGxldCBwZXJtaXNzaW9uczogc3RyaW5nW107XHJcbiAgICAgICAgaWYgKHRoaXMuY2FjaGUuYXNzZXRDaGFuZ2VkICYmIHRoaXMuY2FjaGUucGVybXNIYXNoKSB7XHJcbiAgICAgICAgICAgIC8vIFBlcm1pc3Npb25zIGRpZCBub3QgY2hhbmdlXHJcbiAgICAgICAgICAgIHBlcm1pc3Npb25zID0gSlNPTi5wYXJzZSh0aGlzLmNhY2hlLnBlcm1zSGFzaCkgYXMgc3RyaW5nW107XHJcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuYXNzZXRDaGFuZ2VkID0gZmFsc2U7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgLy8gUGVybWlzc2lvbnMgbWF5IGhhdmUgY2hhbmdlZFxyXG4gICAgICAgICAgICBwZXJtaXNzaW9ucyA9IEFycmF5LmZyb20oXHJcbiAgICAgICAgICAgICAgICBPYmplY3QudmFsdWVzKGNodW5rcykucmVkdWNlKGRlcml2ZVBlcm1pc3Npb25zLCBuZXcgU2V0PHN0cmluZz4oKSkpO1xyXG4gICAgICAgICAgICBjb25zdCBwZXJtc0hhc2ggPSBKU09OLnN0cmluZ2lmeShwZXJtaXNzaW9ucyk7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMudmVyYm9zZSAmJiBwZXJtaXNzaW9ucy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jYWNoZS5wZXJtc0hhc2gpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0Lndhcm4oXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBEZXRlY3RlZCBwZXJtaXNzaW9uczogJHtwZXJtaXNzaW9ucy50b1N0cmluZygpfWAsXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGVybXNIYXNoICE9PSB0aGlzLmNhY2hlLnBlcm1zSGFzaCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQud2FybihcclxuICAgICAgICAgICAgICAgICAgICAgICAgYERldGVjdGVkIG5ldyBwZXJtaXNzaW9uczogJHtwZXJtaXNzaW9ucy50b1N0cmluZygpfWAsXHJcbiAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLmNhY2hlLnBlcm1zSGFzaCA9IHBlcm1zSGFzaDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gdXBkYXRlIHBlcm1pc3Npb25zIGluIG1hbmlmZXN0Lmpzb25cclxuICAgICAgICBjb25zdCB1cGRhdGVkUGVybWlzc2lvbnMgPSBuZXcgU2V0PHN0cmluZz4oWy4uLm1hbmlmZXN0LnBlcm1pc3Npb25zIHx8IFtdLCAuLi5wZXJtaXNzaW9uc10pO1xyXG4gICAgICAgIGlmICh1cGRhdGVkUGVybWlzc2lvbnMuc2l6ZSA+IDApIHtcclxuICAgICAgICAgICAgbWFuaWZlc3QucGVybWlzc2lvbnMgPSBBcnJheS5mcm9tKHVwZGF0ZWRQZXJtaXNzaW9ucyk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZGVsZXRlIG1hbmlmZXN0W1wicGVybWlzc2lvbnNcIl07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IE91dHB1dEJ1bmRsZSwgUGx1Z2luQ29udGV4dCwgVHJhbnNmb3JtUGx1Z2luQ29udGV4dCB9IGZyb20gXCJyb2xsdXBcIjtcclxuaW1wb3J0IHsgcmVzb2x2ZSwgcGFyc2UsIGpvaW4gfSBmcm9tIFwicGF0aFwiO1xyXG5pbXBvcnQgeyBleGlzdHNTeW5jLCByZWFkRmlsZVN5bmMgfSBmcm9tIFwiZnNcIjtcclxuaW1wb3J0IHNsYXNoIGZyb20gXCJzbGFzaFwiO1xyXG5pbXBvcnQgeyBDaHJvbWVFeHRlbnNpb25NYW5pZmVzdCB9IGZyb20gXCIuLi8uLi9tYW5pZmVzdFwiO1xyXG5pbXBvcnQgeyByZW1vdmVGaWxlRXh0ZW5zaW9uIH0gZnJvbSBcIi4uLy4uL2NvbW1vbi91dGlsc1wiO1xyXG5pbXBvcnQgeyBmaW5kQ2h1bmtCeU5hbWUgfSBmcm9tIFwiLi4vLi4vdXRpbHMvaGVscGVyc1wiO1xyXG5pbXBvcnQgeyBtaXhpbkNodW5rc0ZvcklJRkUgfSBmcm9tIFwiLi4vbWl4aW5cIjtcclxuaW1wb3J0IHsgTm9ybWFsaXplZENocm9tZUV4dGVuc2lvbk9wdGlvbnMgfSBmcm9tIFwiQHJvb3Qvc3JjL3BsdWdpbi1vcHRpb25zXCI7XHJcblxyXG5jb25zdCBkeW5hbWljSW1wb3J0QXNzZXRSZXggPSAvKD88PWNocm9tZS5zY3JpcHRpbmcuaW5zZXJ0Q1NTXFwoKVtcXHNcXFNdKj8oPz1cXCkpL2dtO1xyXG5jb25zdCBkeW5hbWljSW1wb3J0U2NyaXB0UmV4ID0gLyg/PD1jaHJvbWUuc2NyaXB0aW5nLmV4ZWN1dGVTY3JpcHRcXCgpW1xcc1xcU10qPyg/PVxcKSkvZ207XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIEJhY2tncm91bmREeW5hbWljSW1wb3J0IHtcclxuICAgIGNvZGU6IHN0cmluZztcclxuICAgIGltcG9ydHM6IHN0cmluZ1tdO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgQmFja2dyb3VuZFByb2Nlc3NlciB7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIG9wdGlvbnM6IE5vcm1hbGl6ZWRDaHJvbWVFeHRlbnNpb25PcHRpb25zKSB7fVxyXG5cclxuICAgIHB1YmxpYyByZXNvbHZlRHluYW1pY0ltcG9ydHMoY29udGV4dDogVHJhbnNmb3JtUGx1Z2luQ29udGV4dCwgY29kZTogc3RyaW5nKTogQmFja2dyb3VuZER5bmFtaWNJbXBvcnQge1xyXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnNyY0Rpcikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQmFja2dyb3VuZFByb2Nlc3Nlcjogb3B0aW9ucy5zcmNEaXIgaXMgbm90IGluaXRpYWxpemVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLSBQUk9DRVNTIERZTkFNSUNBTExZIElNUE9SVEVEIEFTU0VUUyAtLS0tLS0tLS0tLS0tLS0tLSovXHJcbiAgICAgICAgY29kZS5tYXRjaChkeW5hbWljSW1wb3J0QXNzZXRSZXgpXHJcbiAgICAgICAgICAgID8ubWFwKG0gPT4gbS5tYXRjaCgvKD88PShmaWxlczpcXFspP1xcXCIpW1xcc1xcU10qPyg/PVxcXT9cXFwiKS9nbSkpXHJcbiAgICAgICAgICAgIC5yZWR1Y2UoKGYsIG0pID0+IGYuY29uY2F0KC4uLihtIHx8IFtdKSkgfHwgW10sIFtdIGFzIHN0cmluZ1tdKVxyXG4gICAgICAgICAgICAubWFwKG0gPT4geyBjb25zb2xlLmxvZyhcInJlc29sdmVEeW5hbWljSW1wb3J0c1wiLCBtKTsgcmV0dXJuIG07IH0pXHJcbiAgICAgICAgICAgIC5mb3JFYWNoKG0gPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZVBhdGggPSByZXNvbHZlKHRoaXMub3B0aW9ucy5zcmNEaXIhLCBtKTtcclxuICAgICAgICAgICAgICAgIGlmIChleGlzdHNTeW5jKGZpbGVQYXRoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZW1pdEZpbGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFzc2V0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBtLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHJlYWRGaWxlU3luYyhmaWxlUGF0aCksXHJcbiAgICAgICAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgLyogLS0tLS0tLS0tLS0tLS0tLS0gUFJPQ0VTUyBEWU5BTUlDQUxMWSBJTVBPUlRFRCBTQ1JJUFRTIC0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgICAgICAvLyBkeW5hbWljSW1wb3J0cyBjb2xsZWN0cyBmaWxlcyB1c2VkIGJ5IGNocm9tZS5zY3JpcHRpbmcuZXhlY3V0ZVNjcmlwdFxyXG4gICAgICAgIGNvbnN0IGR5bmFtaWNJbXBvcnRzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgIGNvbnN0IHVwZGF0ZWRDb2RlID0gY29kZS5yZXBsYWNlKFxyXG4gICAgICAgICAgICBkeW5hbWljSW1wb3J0U2NyaXB0UmV4LFxyXG4gICAgICAgICAgICBtYXRjaCA9PiBtYXRjaC5yZXBsYWNlKC8oPzw9KGZpbGVzOlxcWyk/KVxcXCJbXFxzXFxTXSo/XFxcIig/PVxcXT8pL2dtLCBmaWxlU3RyID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBwYXJzZShmaWxlU3RyLnJlcGxhY2UoL1xcXCIvZywgXCJcIikudHJpbSgpKTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVQYXRoID0gcmVzb2x2ZSh0aGlzLm9wdGlvbnMuc3JjRGlyISwgZmlsZS5kaXIsIGZpbGUuYmFzZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RzU3luYyhmaWxlUGF0aCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWZlcmVuY2VJZCA9IGNvbnRleHQuZW1pdEZpbGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogZmlsZVBhdGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiY2h1bmtcIixcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogam9pbihmaWxlLmRpciwgZmlsZS5uYW1lKVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWNJbXBvcnRzLnB1c2gocmVmZXJlbmNlSWQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgaW1wb3J0Lm1ldGEuUk9MTFVQX0ZJTEVfVVJMXyR7cmVmZXJlbmNlSWR9YDtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbGVTdHI7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgKTtcclxuICAgICAgICByZXR1cm4geyBjb2RlOiB1cGRhdGVkQ29kZSwgaW1wb3J0czogZHluYW1pY0ltcG9ydHMgfTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZ2VuZXJhdGVCdW5kbGUoXHJcbiAgICAgICAgY29udGV4dDogUGx1Z2luQ29udGV4dCxcclxuICAgICAgICBidW5kbGU6IE91dHB1dEJ1bmRsZSxcclxuICAgICAgICBtYW5pZmVzdDogQ2hyb21lRXh0ZW5zaW9uTWFuaWZlc3RcclxuICAgICk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgICAgIGlmIChtYW5pZmVzdC5iYWNrZ3JvdW5kPy5zZXJ2aWNlX3dvcmtlcikge1xyXG4gICAgICAgICAgICAvLyBtYWtlIGJhY2tncm91bmQgY2h1bmsgb3V0cHV0IGluIHRoZSBzYW1lIGRpcmVjdG9yeSBhcyBtYW5pZmVzdC5qc29uXHJcbiAgICAgICAgICAgIGNvbnN0IGNodW5rID0gZmluZENodW5rQnlOYW1lKHJlbW92ZUZpbGVFeHRlbnNpb24obWFuaWZlc3QuYmFja2dyb3VuZC5zZXJ2aWNlX3dvcmtlciksIGJ1bmRsZSk7XHJcbiAgICAgICAgICAgIGlmIChjaHVuaykge1xyXG4gICAgICAgICAgICAgICAgLy8gbWl4aW4gYWxsIGRlcGVuZGVudCBjaHVua3NcclxuICAgICAgICAgICAgICAgIC8vIGNoYW5nZSBiYWNrZ3JvdW5kIGNodW5rIG91dHB1dCBpbiB0aGUgc2FtZSBkaXJlY3RvcnkgYXMgbWFuaWZlc3QuanNvblxyXG4gICAgICAgICAgICAgICAgY2h1bmsuZmlsZU5hbWUgPSBjaHVuay5maWxlTmFtZS5yZXBsYWNlKC9hc3NldHNcXC8vLCBcIlwiKTtcclxuICAgICAgICAgICAgICAgIG1hbmlmZXN0LmJhY2tncm91bmQuc2VydmljZV93b3JrZXIgPSBzbGFzaChhd2FpdCBtaXhpbkNodW5rc0ZvcklJRkUoY29udGV4dCwgY2h1bmssIGJ1bmRsZSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBmcyBmcm9tIFwiZnMtZXh0cmFcIjtcclxuaW1wb3J0IGNoYWxrIGZyb20gXCJjaGFsa1wiO1xyXG5pbXBvcnQgbWVtb2l6ZSBmcm9tIFwibWVtXCI7XHJcbmltcG9ydCB7IGRpcm5hbWUsIHJlbGF0aXZlLCBiYXNlbmFtZSB9IGZyb20gXCJwYXRoXCI7XHJcbmltcG9ydCB7IGNvc21pY29uZmlnU3luYyB9IGZyb20gXCJjb3NtaWNvbmZpZ1wiO1xyXG5pbXBvcnQgeyBFbWl0dGVkQXNzZXQsIElucHV0T3B0aW9uLCBJbnB1dE9wdGlvbnMsIE91dHB1dEJ1bmRsZSwgUGx1Z2luQ29udGV4dCwgVHJhbnNmb3JtUGx1Z2luQ29udGV4dCB9IGZyb20gXCJyb2xsdXBcIjtcclxuaW1wb3J0IHsgQ2hyb21lRXh0ZW5zaW9uTWFuaWZlc3QsIEJhY2tncm91bmQgfSBmcm9tIFwiLi4vbWFuaWZlc3RcIjtcclxuaW1wb3J0IHsgZGVyaXZlRmlsZXMgfSBmcm9tIFwiLi4vbWFuaWZlc3QtaW5wdXQvbWFuaWZlc3QtcGFyc2VyXCI7XHJcbmltcG9ydCB7IHJlZHVjZVRvUmVjb3JkIH0gZnJvbSBcIi4uL21hbmlmZXN0LWlucHV0L3JlZHVjZVRvUmVjb3JkXCI7XHJcbmltcG9ydCB7IE1hbmlmZXN0SW5wdXRQbHVnaW5DYWNoZSwgTm9ybWFsaXplZENocm9tZUV4dGVuc2lvbk9wdGlvbnMgfSBmcm9tIFwiLi4vcGx1Z2luLW9wdGlvbnNcIjtcclxuaW1wb3J0IHsgY2xvbmVPYmplY3QgfSBmcm9tIFwiLi4vdXRpbHMvY2xvbmVPYmplY3RcIjtcclxuaW1wb3J0IHsgbWFuaWZlc3ROYW1lIH0gZnJvbSBcIi4uL21hbmlmZXN0LWlucHV0L2NvbW1vbi9jb25zdGFudHNcIjtcclxuaW1wb3J0IHsgZ2V0QXNzZXRzLCBnZXRDaHVuayB9IGZyb20gXCIuLi91dGlscy9idW5kbGVcIjtcclxuaW1wb3J0IHtcclxuICAgIHZhbGlkYXRlTWFuaWZlc3QsXHJcbiAgICBWYWxpZGF0aW9uRXJyb3JzQXJyYXksXHJcbn0gZnJvbSBcIi4uL21hbmlmZXN0LWlucHV0L21hbmlmZXN0LXBhcnNlci92YWxpZGF0ZVwiO1xyXG5pbXBvcnQgeyBDb250ZW50U2NyaXB0UHJvY2Vzc29yIH0gZnJvbSBcIi4vY29udGVudC1zY3JpcHQvY29udGVudC1zY3JpcHRcIjtcclxuaW1wb3J0IHsgUGVybWlzc2lvblByb2Nlc3NvciwgUGVybWlzc2lvblByb2Nlc3Nvck9wdGlvbnMgfSBmcm9tIFwiLi9wZXJtaXNzaW9uXCI7XHJcbmltcG9ydCB7IEJhY2tncm91bmRQcm9jZXNzZXIgfSBmcm9tIFwiLi9iYWNrZ3JvdW5kL2JhY2tncm91bmRcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBleHBsb3JlciA9IGNvc21pY29uZmlnU3luYyhcIm1hbmlmZXN0XCIsIHtcclxuICAgIGNhY2hlOiBmYWxzZSxcclxufSk7XHJcblxyXG5leHBvcnQgdHlwZSBFeHRlbmRNYW5pZmVzdCA9XHJcbiAgICB8IFBhcnRpYWw8Q2hyb21lRXh0ZW5zaW9uTWFuaWZlc3Q+XHJcbiAgICB8ICgobWFuaWZlc3Q6IENocm9tZUV4dGVuc2lvbk1hbmlmZXN0KSA9PiBDaHJvbWVFeHRlbnNpb25NYW5pZmVzdCk7XHJcblxyXG5leHBvcnQgdHlwZSBDaHJvbWVFeHRlbnNpb25Db25maWd1cmF0aW9uSW5mbyA9IHtcclxuICAgIGZpbGVwYXRoOiBzdHJpbmcsXHJcbiAgICBjb25maWc6IENocm9tZUV4dGVuc2lvbk1hbmlmZXN0LFxyXG4gICAgaXNFbXB0eT86IHRydWUsXHJcbn07XHJcblxyXG5leHBvcnQgY2xhc3MgTWFuaWZlc3RQcm9jZXNzb3Ige1xyXG4gICAgcHVibGljIGNhY2hlID0ge1xyXG4gICAgICAgIGFzc2V0Q2hhbmdlZDogZmFsc2UsXHJcbiAgICAgICAgYXNzZXRzOiBbXSxcclxuICAgICAgICBpaWZlOiBbXSxcclxuICAgICAgICBpbnB1dDogW10sXHJcbiAgICAgICAgaW5wdXRBcnk6IFtdLFxyXG4gICAgICAgIGlucHV0T2JqOiB7fSxcclxuICAgICAgICBkeW5hbWljSW1wb3J0Q29udGVudFNjcmlwdHM6IFtdLFxyXG4gICAgICAgIHBlcm1zSGFzaDogXCJcIixcclxuICAgICAgICByZWFkRmlsZTogbmV3IE1hcDxzdHJpbmcsIGFueT4oKSxcclxuICAgICAgICBzcmNEaXI6IG51bGwsXHJcbiAgICB9IGFzIE1hbmlmZXN0SW5wdXRQbHVnaW5DYWNoZTtcclxuICAgIHB1YmxpYyBtYW5pZmVzdD86IENocm9tZUV4dGVuc2lvbk1hbmlmZXN0O1xyXG4gICAgcHVibGljIGNvbnRlbnRTY3JpcHRQcm9jZXNzb3I6IENvbnRlbnRTY3JpcHRQcm9jZXNzb3I7XHJcbiAgICBwdWJsaWMgcGVybWlzc2lvblByb2Nlc3NvcjogUGVybWlzc2lvblByb2Nlc3NvcjtcclxuICAgIHB1YmxpYyBiYWNrZ3JvdW5kUHJvY2Vzc29yOiBCYWNrZ3JvdW5kUHJvY2Vzc2VyO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3Rvcihwcml2YXRlIG9wdGlvbnMgPSB7fSBhcyBOb3JtYWxpemVkQ2hyb21lRXh0ZW5zaW9uT3B0aW9ucykge1xyXG4gICAgICAgIHRoaXMuY29udGVudFNjcmlwdFByb2Nlc3NvciA9IG5ldyBDb250ZW50U2NyaXB0UHJvY2Vzc29yKG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMucGVybWlzc2lvblByb2Nlc3NvciA9IG5ldyBQZXJtaXNzaW9uUHJvY2Vzc29yKG5ldyBQZXJtaXNzaW9uUHJvY2Vzc29yT3B0aW9ucygpKTtcclxuICAgICAgICB0aGlzLmJhY2tncm91bmRQcm9jZXNzb3IgPSBuZXcgQmFja2dyb3VuZFByb2Nlc3NlcihvcHRpb25zKTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIExvYWQgY29udGVudCBmcm9tIG1hbmlmZXN0Lmpzb25cclxuICAgICAqIEBwYXJhbSBvcHRpb25zOiByb2xsdXAgaW5wdXQgb3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgbG9hZChvcHRpb25zOiBJbnB1dE9wdGlvbnMpIHtcclxuICAgICAgICAvKiAtLS0tLS0tLS0tLS0tLS0gR0VUIE1BTklGRVNULkpTT04gUEFUSCAtLS0tLS0tLS0tLS0tLS0gKi9cclxuICAgICAgICBjb25zdCBpbnB1dE1hbmlmZXN0UGF0aCA9IHRoaXMucmVzb2x2ZU1hbmlmZXN0UGF0aChvcHRpb25zKTtcclxuICAgICAgICAvKiAtLS0tLS0tLS0tLS0tLS0gTE9BRCBDT05URU5UIEZST00gTUFOSUZFU1QuSlNPTiAtLS0tLS0tLS0tLS0tLS0gKi9cclxuICAgICAgICBjb25zdCBjb25maWdSZXN1bHQgPSBleHBsb3Jlci5sb2FkKGlucHV0TWFuaWZlc3RQYXRoKSBhcyBDaHJvbWVFeHRlbnNpb25Db25maWd1cmF0aW9uSW5mbztcclxuICAgICAgICAvKiAtLS0tLS0tLS0tLS0tLS0gVkFMSURBVEUgTUFOSUZFU1QuSlNPTiBDT05URU5UIC0tLS0tLS0tLS0tLS0tLSAqL1xyXG4gICAgICAgIHRoaXMudmFsaWRhdGVNYW5pZmVzdENvbnRlbnQoY29uZmlnUmVzdWx0KTtcclxuICAgICAgICAvKiAtLS0tLS0tLS0tLS0tLS0gQVBQTFkgVVNFUiBDVVNUT00gQ09ORklHIC0tLS0tLS0tLS0tLS0tLSAqL1xyXG4gICAgICAgIHRoaXMubWFuaWZlc3QgPSB0aGlzLmFwcGx5RXh0ZXJuYWxNYW5pZmVzdENvbmZpZ3VyYXRpb24oY29uZmlnUmVzdWx0KTtcclxuICAgICAgICAvKiAtLS0tLS0tLS0tLS0tLS0gUkVDT1JEIE9QVElPTlMgLS0tLS0tLS0tLS0tLS0tICovXHJcbiAgICAgICAgdGhpcy5vcHRpb25zLm1hbmlmZXN0UGF0aCA9IGNvbmZpZ1Jlc3VsdC5maWxlcGF0aDtcclxuICAgICAgICB0aGlzLm9wdGlvbnMuc3JjRGlyID0gZGlybmFtZSh0aGlzLm9wdGlvbnMubWFuaWZlc3RQYXRoKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5tYW5pZmVzdDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIFJlc29sdmUgaW5wdXQgZmlsZXMgZm9yIHJvbGx1cFxyXG4gICAgICogQHBhcmFtIGlucHV0OiBJbnB1dCBub3QgaW4gbWFuaWZlc3QuanNvbiBidXQgc3BlY2lmeSBieSB1c2VyXHJcbiAgICAgKiBAcmV0dXJuc1xyXG4gICAgICovXHJcbiAgICBwdWJsaWMgcmVzb2x2ZUlucHV0KGlucHV0PzogSW5wdXRPcHRpb24pOiB7XHJcbiAgICAgICAgW2VudHJ5QWxpYXM6IHN0cmluZ106IHN0cmluZztcclxuICAgIH0ge1xyXG4gICAgICAgIGlmICghdGhpcy5tYW5pZmVzdCB8fCAhdGhpcy5vcHRpb25zLnNyY0Rpcikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwibWFuaWZlc3QgYW5kIG9wdGlvbnMuc3JjRGlyIG5vdCBpbml0aWFsaXplZFwiKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gRGVyaXZlIGFsbCBzdGF0aWMgcmVzb3VyY2VzIGZyb20gbWFuaWZlc3RcclxuICAgICAgICAvLyBEeW5hbWljIGVudHJpZXMgd2lsbCBlbWl0IGluIHRyYW5zZm9ybSBob29rXHJcbiAgICAgICAgY29uc3QgeyBqcywgaHRtbCwgY3NzLCBpbWcsIG90aGVycyB9ID0gZGVyaXZlRmlsZXMoXHJcbiAgICAgICAgICAgIHRoaXMubWFuaWZlc3QsXHJcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zcmNEaXIsXHJcbiAgICAgICAgKTtcclxuICAgICAgICAvLyBDYWNoZSBkZXJpdmVkIGlucHV0c1xyXG4gICAgICAgIHRoaXMuY2FjaGUuaW5wdXQgPSBbLi4udGhpcy5jYWNoZS5pbnB1dEFyeSwgLi4uanMsIC4uLmh0bWxdO1xyXG4gICAgICAgIHRoaXMuY2FjaGUuYXNzZXRzID0gWy4uLm5ldyBTZXQoWy4uLmNzcywgLi4uaW1nLCAuLi5vdGhlcnNdKV07XHJcbiAgICAgICAgY29uc3QgaW5wdXRzID0gdGhpcy5jYWNoZS5pbnB1dC5yZWR1Y2UoXHJcbiAgICAgICAgICAgIHJlZHVjZVRvUmVjb3JkKHRoaXMub3B0aW9ucy5zcmNEaXIpLFxyXG4gICAgICAgICAgICB0aGlzLmNhY2hlLmlucHV0T2JqKTtcclxuICAgICAgICByZXR1cm4gaW5wdXRzO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB0cmFuc2Zvcm0oY29udGV4dDogVHJhbnNmb3JtUGx1Z2luQ29udGV4dCwgY29kZTogc3RyaW5nLCBpZDogc3RyaW5nLCBzc3I/OiBib29sZWFuKSB7XHJcbiAgICAgICAgY29uc3QgeyBjb2RlOnVwZGF0ZWRDb2RlLCBpbXBvcnRzIH0gPSB0aGlzLmJhY2tncm91bmRQcm9jZXNzb3IucmVzb2x2ZUR5bmFtaWNJbXBvcnRzKGNvbnRleHQsIGNvZGUpO1xyXG4gICAgICAgIHRoaXMuY2FjaGUuZHluYW1pY0ltcG9ydENvbnRlbnRTY3JpcHRzLnB1c2goLi4uaW1wb3J0cyk7XHJcbiAgICAgICAgcmV0dXJuIHVwZGF0ZWRDb2RlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBpc0R5bmFtaWNJbXBvcnRlZENvbnRlbnRTY3JpcHQocmVmZXJlbmNlSWQ6IHN0cmluZykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlLmR5bmFtaWNJbXBvcnRDb250ZW50U2NyaXB0cy5pbmNsdWRlcyhyZWZlcmVuY2VJZCk7XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgd2F0Y2ggZmlsZXNcclxuICAgICAqIEBwYXJhbSBjb250ZXh0IFJvbGx1cCBQbHVnaW4gQ29udGV4dFxyXG4gICAgICovXHJcbiAgICBwdWJsaWMgYWRkV2F0Y2hGaWxlcyhjb250ZXh0OiBQbHVnaW5Db250ZXh0KSB7XHJcbiAgICAgICAgLy8gd2F0Y2ggbWFuaWZlc3QuanNvbiBmaWxlXHJcbiAgICAgICAgY29udGV4dC5hZGRXYXRjaEZpbGUodGhpcy5vcHRpb25zLm1hbmlmZXN0UGF0aCEpO1xyXG4gICAgICAgIC8vIHdhdGNoIGFzc2V0IGZpbGVzXHJcbiAgICAgICAgdGhpcy5jYWNoZS5hc3NldHMuZm9yRWFjaChzcmNQYXRoID0+IGNvbnRleHQuYWRkV2F0Y2hGaWxlKHNyY1BhdGgpKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYXN5bmMgZW1pdEZpbGVzKGNvbnRleHQ6IFBsdWdpbkNvbnRleHQpIHtcclxuICAgICAgICAvLyBDb3B5IGFzc2V0IGZpbGVzXHJcbiAgICAgICAgY29uc3QgYXNzZXRzOiBFbWl0dGVkQXNzZXRbXSA9IGF3YWl0IFByb21pc2UuYWxsKFxyXG4gICAgICAgICAgICB0aGlzLmNhY2hlLmFzc2V0cy5tYXAoYXN5bmMgKHNyY1BhdGgpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGF3YWl0IHRoaXMucmVhZEFzc2V0QXNCdWZmZXIoc3JjUGF0aCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXNzZXRcIiBhcyBjb25zdCxcclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IHJlbGF0aXZlKHRoaXMub3B0aW9ucy5zcmNEaXIhLCBzcmNQYXRoKSxcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgYXNzZXRzLmZvckVhY2goKGFzc2V0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuZW1pdEZpbGUoYXNzZXQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjbGVhckNhY2hlQnlJZChpZDogc3RyaW5nKSB7XHJcbiAgICAgICAgaWYgKGlkLmVuZHNXaXRoKG1hbmlmZXN0TmFtZSkpIHtcclxuICAgICAgICAgICAgLy8gRHVtcCBjYWNoZS5tYW5pZmVzdCBpZiBtYW5pZmVzdCBjaGFuZ2VzXHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLm1hbmlmZXN0O1xyXG4gICAgICAgICAgICB0aGlzLmNhY2hlLmFzc2V0Q2hhbmdlZCA9IGZhbHNlO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIEZvcmNlIG5ldyByZWFkIG9mIGNoYW5nZWQgYXNzZXRcclxuICAgICAgICAgICAgdGhpcy5jYWNoZS5hc3NldENoYW5nZWQgPSB0aGlzLmNhY2hlLnJlYWRGaWxlLmRlbGV0ZShpZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhc3luYyBnZW5lcmF0ZUJ1bmRsZShjb250ZXh0OiBQbHVnaW5Db250ZXh0LCBidW5kbGU6IE91dHB1dEJ1bmRsZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5tYW5pZmVzdCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJbZ2VuZXJhdGUgYnVuZGxlXSBNYW5pZmVzdCBjYW5ub3QgYmUgZW1wdHlcIik7IH1cclxuICAgICAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLSBHRVQgQ0hVTktTIC0tLS0tLS0tLS0tLS0tLS0tKi9cclxuICAgICAgICBjb25zdCBjaHVua3MgPSBnZXRDaHVuayhidW5kbGUpO1xyXG4gICAgICAgIGNvbnN0IGFzc2V0cyA9IGdldEFzc2V0cyhidW5kbGUpO1xyXG4gICAgICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tIFVQREFURSBQRVJNSVNTSU9OUyAtLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4gICAgICAgIHRoaXMucGVybWlzc2lvblByb2Nlc3Nvci5kZXJpdmVQZXJtaXNzaW9ucyhjb250ZXh0LCBjaHVua3MsIHRoaXMubWFuaWZlc3QpO1xyXG4gICAgICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tIFVQREFURSBDT05URU5UIFNDUklQVFMgLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuICAgICAgICBhd2FpdCB0aGlzLmNvbnRlbnRTY3JpcHRQcm9jZXNzb3IuZ2VuZXJhdGVCdW5kbGUoY29udGV4dCwgYnVuZGxlLCB0aGlzLm1hbmlmZXN0KTtcclxuICAgICAgICBhd2FpdCB0aGlzLmNvbnRlbnRTY3JpcHRQcm9jZXNzb3IuZ2VuZXJhdGVCdW5kbGVGcm9tRHluYW1pY0ltcG9ydHMoY29udGV4dCwgYnVuZGxlLCB0aGlzLmNhY2hlLmR5bmFtaWNJbXBvcnRDb250ZW50U2NyaXB0cyk7XHJcbiAgICAgICAgLyogLS0tLS0tLS0tLS0tLS0tLS0gU0VUVVAgQkFDS0dST1VORCBTQ1JJUFRTIC0tLS0tLS0tLS0tLS0tLS0tICovXHJcbiAgICAgICAgYXdhaXQgdGhpcy5iYWNrZ3JvdW5kUHJvY2Vzc29yLmdlbmVyYXRlQnVuZGxlKGNvbnRleHQsIGJ1bmRsZSwgdGhpcy5tYW5pZmVzdCk7XHJcbiAgICAgICAgLyogLS0tLS0tLS0tLS0tLS0tLS0gU0VUVVAgQVNTRVRTIElOIFdFQiBBQ0NFU1NJQkxFIFJFU09VUkNFUyAtLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuICAgICAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLSBTVEFCTEUgRVhURU5TSU9OIElEIC0tLS0tLS0tLS0tLS0tLS0tICovXHJcbiAgICAgICAgLyogLS0tLS0tLS0tLS0tLS0tLS0gT1VUUFVUIE1BTklGRVNULkpTT04gLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuICAgICAgICAvKiAtLS0tLS0tLS0tLSBPVVRQVVQgTUFOSUZFU1QuSlNPTiAtLS0tLS0tLS0tICovXHJcbiAgICAgICAgdGhpcy5nZW5lcmF0ZU1hbmlmZXN0KGNvbnRleHQsIHRoaXMubWFuaWZlc3QpO1xyXG4gICAgICAgIC8vIHZhbGlkYXRlIG1hbmlmZXN0XHJcbiAgICAgICAgdGhpcy52YWxpZGF0ZU1hbmlmZXN0KCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSByZXNvbHZlTWFuaWZlc3RQYXRoKG9wdGlvbnM6IElucHV0T3B0aW9ucyk6IHN0cmluZyB7XHJcbiAgICAgICAgaWYgKCFvcHRpb25zLmlucHV0KSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGNoYWxrLnJlZChcIk5vIGlucHV0IGlzIHByb3ZpZGVkLlwiKSlcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gaW5wdXQgaXMgcHJvdmlkZWQuXCIpXHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCBpbnB1dE1hbmlmZXN0UGF0aDogc3RyaW5nIHwgdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMuaW5wdXQpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG1hbmlmZXN0SW5kZXggPSBvcHRpb25zLmlucHV0LmZpbmRJbmRleChpID0+IGJhc2VuYW1lKGkpID09PSBcIm1hbmlmZXN0Lmpzb25cIik7XHJcbiAgICAgICAgICAgIGlmIChtYW5pZmVzdEluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgICAgIGlucHV0TWFuaWZlc3RQYXRoID0gb3B0aW9ucy5pbnB1dFttYW5pZmVzdEluZGV4XTtcclxuICAgICAgICAgICAgICAgIHRoaXMuY2FjaGUuaW5wdXRBcnkgPSBvcHRpb25zLmlucHV0LnNwbGljZShtYW5pZmVzdEluZGV4LCAxKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGNoYWxrLnJlZChcIlJvbGx1cE9wdGlvbnMuaW5wdXQgYXJyYXkgbXVzdCBjb250YWluIGEgQ2hyb21lIGV4dGVuc2lvbiBtYW5pZmVzdCB3aXRoIGZpbGVuYW1lICdtYW5pZmVzdC5qc29uJy5cIikpO1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9sbHVwT3B0aW9ucy5pbnB1dCBhcnJheSBtdXN0IGNvbnRhaW4gYSBDaHJvbWUgZXh0ZW5zaW9uIG1hbmlmZXN0IHdpdGggZmlsZW5hbWUgJ21hbmlmZXN0Lmpzb24nLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuaW5wdXQgPT09IFwib2JqZWN0XCIpIHtcclxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaW5wdXQubWFuaWZlc3QpIHtcclxuICAgICAgICAgICAgICAgIGlucHV0TWFuaWZlc3RQYXRoID0gb3B0aW9ucy5pbnB1dC5tYW5pZmVzdDtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zLmlucHV0W1wibWFuaWZlc3RcIl07XHJcbiAgICAgICAgICAgICAgICB0aGlzLmNhY2hlLmlucHV0T2JqID0gY2xvbmVPYmplY3Qob3B0aW9ucy5pbnB1dCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhjaGFsay5yZWQoXCJSb2xsdXBPcHRpb25zLmlucHV0IG9iamVjdCBtdXN0IGNvbnRhaW4gYSBDaHJvbWUgZXh0ZW5zaW9uIG1hbmlmZXN0IHdpdGggS2V5IG1hbmlmZXN0LlwiKSk7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSb2xsdXBPcHRpb25zLmlucHV0IG9iamVjdCBtdXN0IGNvbnRhaW4gYSBDaHJvbWUgZXh0ZW5zaW9uIG1hbmlmZXN0IHdpdGggS2V5IG1hbmlmZXN0LlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGlucHV0TWFuaWZlc3RQYXRoID0gb3B0aW9ucy5pbnB1dDtcclxuICAgICAgICAgICAgZGVsZXRlIG9wdGlvbnMuaW5wdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qIC0tLS0tLS0tLS0tLS0tLSBWQUxJREFURSBNQU5JRkVTVC5KU09OIFBBVEggLS0tLS0tLS0tLS0tLS0tICovXHJcbiAgICAgICAgaWYgKGJhc2VuYW1lKGlucHV0TWFuaWZlc3RQYXRoKSAhPT0gXCJtYW5pZmVzdC5qc29uXCIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIklucHV0IGZvciBhIENocm9tZSBleHRlbnNpb24gbWFuaWZlc3QgbXVzdCBoYXZlIGZpbGVuYW1lICdtYW5pZmVzdC5qc29uJy5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBpbnB1dE1hbmlmZXN0UGF0aDtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHZhbGlkYXRlTWFuaWZlc3RDb250ZW50KGNvbmZpZzogQ2hyb21lRXh0ZW5zaW9uQ29uZmlndXJhdGlvbkluZm8pIHtcclxuICAgICAgICBpZiAoY29uZmlnLmlzRW1wdHkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2NvbmZpZy5maWxlcGF0aH0gaXMgYW4gZW1wdHkgZmlsZS5gKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgeyBvcHRpb25zX3BhZ2UsIG9wdGlvbnNfdWkgfSA9IGNvbmZpZy5jb25maWc7XHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICBvcHRpb25zX3BhZ2UgIT09IHVuZGVmaW5lZCAmJlxyXG4gICAgICAgICAgICBvcHRpb25zX3VpICE9PSB1bmRlZmluZWRcclxuICAgICAgICApIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgICAgXCJvcHRpb25zX3VpIGFuZCBvcHRpb25zX3BhZ2UgY2Fubm90IGJvdGggYmUgZGVmaW5lZCBpbiBtYW5pZmVzdC5qc29uLlwiLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHZhbGlkYXRlTWFuaWZlc3QoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubWFuaWZlc3QpIHtcclxuICAgICAgICAgICAgdmFsaWRhdGVNYW5pZmVzdCh0aGlzLm1hbmlmZXN0KVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hbmlmZXN0IGNhbm5vdCBiZSBlbXB0eVwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBhcHBseUV4dGVybmFsTWFuaWZlc3RDb25maWd1cmF0aW9uKFxyXG4gICAgICAgIGNvbmZpZzogQ2hyb21lRXh0ZW5zaW9uQ29uZmlndXJhdGlvbkluZm9cclxuICAgICk6IENocm9tZUV4dGVuc2lvbk1hbmlmZXN0IHtcclxuICAgICAgICBpZiAodHlwZW9mIHRoaXMub3B0aW9ucy5leHRlbmRNYW5pZmVzdCA9PT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZXh0ZW5kTWFuaWZlc3QoY29uZmlnLmNvbmZpZyk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLmV4dGVuZE1hbmlmZXN0ID09PSBcIm9iamVjdFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAuLi5jb25maWcuY29uZmlnLFxyXG4gICAgICAgICAgICAgICAgLi4udGhpcy5vcHRpb25zLmV4dGVuZE1hbmlmZXN0LFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb25maWcuY29uZmlnO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIHJlYWRBc3NldEFzQnVmZmVyID0gbWVtb2l6ZShcclxuICAgICAgICAoZmlsZXBhdGg6IHN0cmluZykgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gZnMucmVhZEZpbGUoZmlsZXBhdGgpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgICBjYWNoZTogdGhpcy5jYWNoZS5yZWFkRmlsZSxcclxuICAgICAgICB9LFxyXG4gICAgKTtcclxuXHJcbiAgICBwcml2YXRlIGdlbmVyYXRlTWFuaWZlc3QoXHJcbiAgICAgICAgY29udGV4dDogUGx1Z2luQ29udGV4dCxcclxuICAgICAgICBtYW5pZmVzdDogQ2hyb21lRXh0ZW5zaW9uTWFuaWZlc3QsXHJcbiAgICApIHtcclxuICAgICAgICBjb25zdCBtYW5pZmVzdEpzb24gPSBKU09OLnN0cmluZ2lmeShtYW5pZmVzdCwgbnVsbCwgNClcclxuICAgICAgICAgICAgLy8gU01FTEw6IGlzIHRoaXMgbmVjZXNzYXJ5P1xyXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwuW2p0XXN4P1wiL2csICcuanNcIicpO1xyXG4gICAgICAgIC8vIEVtaXQgbWFuaWZlc3QuanNvblxyXG4gICAgICAgIGNvbnRleHQuZW1pdEZpbGUoe1xyXG4gICAgICAgICAgICB0eXBlOiBcImFzc2V0XCIsXHJcbiAgICAgICAgICAgIGZpbGVOYW1lOiBtYW5pZmVzdE5hbWUsXHJcbiAgICAgICAgICAgIHNvdXJjZTogbWFuaWZlc3RKc29uLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCB7IGRpcm5hbWUsIHJlbGF0aXZlLCByZXNvbHZlIH0gZnJvbSBcInBhdGhcIjtcclxuaW1wb3J0IHsgSW5wdXRPcHRpb24sIE91dHB1dEJ1bmRsZSwgT3V0cHV0Q2h1bmssIFBsdWdpbkNvbnRleHQgfSBmcm9tIFwicm9sbHVwXCI7XHJcbmltcG9ydCBmbGF0dGVuIGZyb20gXCJsb2Rhc2guZmxhdHRlblwiO1xyXG5pbXBvcnQgeyByZWFkRmlsZSB9IGZyb20gXCJmcy1leHRyYVwiO1xyXG5pbXBvcnQgeyBmbGF0dGVuUm9sbHVwSW5wdXQgfSBmcm9tIFwiLi4vY29tbW9uL3V0aWxzL3JvbGx1cFwiO1xyXG5pbXBvcnQgeyBDaGVlcmlvRmlsZSwgZm9ybWF0SHRtbCwgZ2V0Q3NzSHJlZnMsIGdldEltZ1NyY3MsIGdldEpzQXNzZXRzLCBnZXRTY3JpcHRFbGVtcywgZ2V0U2NyaXB0U3JjLCBsb2FkSHRtbCB9IGZyb20gXCIuLi9odG1sLWlucHV0cy9jaGVlcmlvXCI7XHJcbmltcG9ydCB7IEh0bWxJbnB1dHNQbHVnaW5DYWNoZSwgTm9ybWFsaXplZENocm9tZUV4dGVuc2lvbk9wdGlvbnMgfSBmcm9tIFwiLi4vcGx1Z2luLW9wdGlvbnNcIjtcclxuaW1wb3J0IHsgZ2V0T3V0cHV0RmlsZW5hbWVGcm9tQ2h1bmssIGlzQ2h1bmssIG5vdCB9IGZyb20gXCIuLi91dGlscy9oZWxwZXJzXCI7XHJcbmltcG9ydCB7IHJlZHVjZVRvUmVjb3JkIH0gZnJvbSBcIi4uL21hbmlmZXN0LWlucHV0L3JlZHVjZVRvUmVjb3JkXCI7XHJcblxyXG5jb25zdCBpc0h0bWwgPSAocGF0aDogc3RyaW5nKSA9PiAvXFwuaHRtbD8kLy50ZXN0KHBhdGgpO1xyXG5cclxuZXhwb3J0IGNsYXNzIEh0bWxQcm9jZXNzb3Ige1xyXG4gICAgcHJpdmF0ZSBjYWNoZSA9IHtcclxuICAgICAgICBzY3JpcHRzOiBbXSxcclxuICAgICAgICBodG1sOiBbXSxcclxuICAgICAgICBodG1sJDogW10sXHJcbiAgICAgICAganM6IFtdLFxyXG4gICAgICAgIGNzczogW10sXHJcbiAgICAgICAgaW1nOiBbXSxcclxuICAgICAgICBpbnB1dDogW10sXHJcbiAgICB9IGFzIEh0bWxJbnB1dHNQbHVnaW5DYWNoZTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIG9wdGlvbnM6IE5vcm1hbGl6ZWRDaHJvbWVFeHRlbnNpb25PcHRpb25zKSB7IH1cclxuXHJcbiAgICBwdWJsaWMgcmVzb2x2ZUlucHV0KGlucHV0PzogSW5wdXRPcHRpb24pIHtcclxuICAgICAgICAvLyBzcmNEaXIgbWF5IGJlIGluaXRpYWxpemVkIGJ5IGFub3RoZXIgcGx1Z2luXHJcbiAgICAgICAgY29uc3QgeyBzcmNEaXIgfSA9IHRoaXMub3B0aW9ucztcclxuICAgICAgICBpZiAoc3JjRGlyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuc3JjRGlyID0gc3JjRGlyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJvcHRpb25zLnNyY0RpciBub3QgaW5pdGlhbGl6ZWRcIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTa2lwIGlmIGNhY2hlLmlucHV0IGV4aXN0c1xyXG4gICAgICAgIC8vIGNhY2hlIGlzIGR1bXBlZCBpbiB3YXRjaENoYW5nZSBob29rXHJcblxyXG4gICAgICAgIC8vIEZsYXR0ZW4gaW5wdXQgdG8gYXJyYXlcclxuICAgICAgICBjb25zdCBpbnB1dEFycmF5ID0gZmxhdHRlblJvbGx1cElucHV0KGlucHV0KTtcclxuXHJcbiAgICAgICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4gICAgICAgIC8qICAgICAgICAgICAgICAgICBIQU5ETEUgSFRNTCBGSUxFUyAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG4gICAgICAgIC8vIEZpbHRlciBodG0gYW5kIGh0bWwgZmlsZXNcclxuICAgICAgICB0aGlzLmNhY2hlLmh0bWwgPSBpbnB1dEFycmF5LmZpbHRlcihpc0h0bWwpO1xyXG5cclxuICAgICAgICAvLyBJZiBubyBodG1sIGZpbGVzLCBkbyBub3RoaW5nXHJcbiAgICAgICAgaWYgKHRoaXMuY2FjaGUuaHRtbC5sZW5ndGggPT09IDApIHJldHVybiBpbnB1dDtcclxuXHJcbiAgICAgICAgLy8gSWYgdGhlIGNhY2hlIGhhcyBiZWVuIGR1bXBlZCwgcmVsb2FkIGZyb20gZmlsZXNcclxuICAgICAgICBpZiAodGhpcy5jYWNoZS5odG1sJC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgLy8gVGhpcyBpcyBhbGwgZG9uZSBvbmNlXHJcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuaHRtbCQgPSB0aGlzLmNhY2hlLmh0bWwubWFwKGxvYWRIdG1sKHNyY0RpcikpO1xyXG4gICAgICAgICAgICB0aGlzLmNhY2hlLmpzID0gZmxhdHRlbih0aGlzLmNhY2hlLmh0bWwkLm1hcChnZXRTY3JpcHRTcmMpKTtcclxuICAgICAgICAgICAgdGhpcy5jYWNoZS5jc3MgPSBmbGF0dGVuKHRoaXMuY2FjaGUuaHRtbCQubWFwKGdldENzc0hyZWZzKSk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuaW1nID0gZmxhdHRlbih0aGlzLmNhY2hlLmh0bWwkLm1hcChnZXRJbWdTcmNzKSk7XHJcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2NyaXB0cyA9IGZsYXR0ZW4odGhpcy5jYWNoZS5odG1sJC5tYXAoZ2V0SnNBc3NldHMpKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlbW92ZSBIVE1MIGZpbGVzIGZyb20gaW5wdXRcclxuICAgICAgICAgICAgLy8gQ2FjaGUganNFbnRyaWVzIHdpdGggZXhpc3RpbmcgaW5wdXRcclxuICAgICAgICAgICAgdGhpcy5jYWNoZS5pbnB1dCA9IGlucHV0QXJyYXkuZmlsdGVyKG5vdChpc0h0bWwpKS5jb25jYXQodGhpcy5jYWNoZS5qcyk7XHJcblxyXG4gICAgICAgICAgICBpZiAodGhpcy5jYWNoZS5pbnB1dC5sZW5ndGggPT09IDApIHtcclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0IGxlYXN0IG9uZSBIVE1MIGZpbGUgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBzY3JpcHQuXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyAtIFBhcnNlIEhUTUwgYW5kIGVtaXQgY2h1bmtzIGFuZCBhc3NldHMgaW4gYnVpbGRTdGFydFxyXG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlLmlucHV0LnJlZHVjZShyZWR1Y2VUb1JlY29yZChzcmNEaXIpLCB7fSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFkZFdhdGNoRmlsZXMoY29udGV4dDogUGx1Z2luQ29udGV4dCkge1xyXG4gICAgICAgIFtcclxuICAgICAgICAgICAgLi4udGhpcy5jYWNoZS5jc3MsXHJcbiAgICAgICAgICAgIC4uLnRoaXMuY2FjaGUuaW1nLFxyXG4gICAgICAgICAgICAuLi50aGlzLmNhY2hlLnNjcmlwdHMsXHJcbiAgICAgICAgICAgIC4uLnRoaXMuY2FjaGUuaHRtbCxcclxuICAgICAgICBdLmNvbmNhdCh0aGlzLmNhY2hlLmh0bWwpLmZvckVhY2goKGFzc2V0KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnRleHQuYWRkV2F0Y2hGaWxlKGFzc2V0KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2VuZXJhdGVCdW5kbGUoY29udGV4dDogUGx1Z2luQ29udGV4dCwgYnVuZGxlOiBPdXRwdXRCdW5kbGUpIHtcclxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5zcmNEaXIpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIltodG1sXSBvcHRpb25zLnNyY0RpciBub3QgaW5pdGlhbGl6ZWRcIik7IH1cclxuICAgICAgICBjb25zdCBjaHVua3MgPSBPYmplY3QudmFsdWVzKGJ1bmRsZSkuZmlsdGVyKGlzQ2h1bmspO1xyXG5cclxuICAgICAgICB0aGlzLmNhY2hlLmh0bWwkLm1hcCgkID0+IHRoaXMucmVwbGFjZUltcG9ydFNjcmlwdFBhdGgoJCwgY2h1bmtzLCB0aGlzLm9wdGlvbnMuc3JjRGlyISwgdGhpcy5vcHRpb25zLmJyb3dzZXJQb2x5ZmlsbCkpXHJcbiAgICAgICAgICAgIC5tYXAoJCA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBmb3JtYXRIdG1sKCQpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZU5hbWUgPSByZWxhdGl2ZSh0aGlzLm9wdGlvbnMuc3JjRGlyISwgJC5maWxlUGF0aCk7XHJcbiAgICAgICAgICAgICAgICBjb250ZXh0LmVtaXRGaWxlKHtcclxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFzc2V0XCIsXHJcbiAgICAgICAgICAgICAgICAgICAgc291cmNlLFxyXG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIE91dHB1dCBhc3NldCBmaWxlcyBpbiBodG1sXHJcbiAgICAgKiBjc3MsIGltZywgc2NyaXB0KG5vdCBsb2NhbCBpbXBvcnQpXHJcbiAgICAgKi9cclxuICAgIHB1YmxpYyBhc3luYyBlbWl0RmlsZXMoY29udGV4dDogUGx1Z2luQ29udGV4dCkge1xyXG4gICAgICAgIGNvbnN0IGFzc2V0cyA9IFtcclxuICAgICAgICAgICAgLi4udGhpcy5jYWNoZS5jc3MsXHJcbiAgICAgICAgICAgIC4uLnRoaXMuY2FjaGUuaW1nLFxyXG4gICAgICAgICAgICAuLi50aGlzLmNhY2hlLnNjcmlwdHMsXHJcbiAgICAgICAgXTtcclxuICAgICAgICBjb25zdCBlbWl0dGluZyA9IGFzc2V0cy5tYXAoYXN5bmMgKGFzc2V0KSA9PiB7XHJcbiAgICAgICAgICAgIC8vIFJlYWQgdGhlc2UgZmlsZXMgYXMgQnVmZmVyc1xyXG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBhd2FpdCByZWFkRmlsZShhc3NldCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lID0gcmVsYXRpdmUodGhpcy5vcHRpb25zLnNyY0RpciEsIGFzc2V0KTtcclxuICAgICAgICAgICAgY29udGV4dC5lbWl0RmlsZSh7XHJcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFzc2V0XCIsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2UsIC8vIEJ1ZmZlclxyXG4gICAgICAgICAgICAgICAgZmlsZU5hbWUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGVtaXR0aW5nKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgY2xlYXJDYWNoZUJ5SWQoaWQ6IHN0cmluZykge1xyXG4gICAgICAgIGlmIChpZC5lbmRzV2l0aChcIi5odG1sXCIpIHx8IGlkLmVuZHNXaXRoKFwibWFuaWZlc3QuanNvblwiKSkge1xyXG4gICAgICAgICAgICAvLyBEdW1wIGNhY2hlIGlmIGh0bWwgZmlsZSBvciBtYW5pZmVzdCBjaGFuZ2VzXHJcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuaHRtbCQgPSBbXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSByZXBsYWNlSW1wb3J0U2NyaXB0UGF0aChcclxuICAgICAgICAkOiBDaGVlcmlvRmlsZSxcclxuICAgICAgICBjaHVua3M6IE91dHB1dENodW5rW10sXHJcbiAgICAgICAgc3JjRGlyOiBzdHJpbmcsXHJcbiAgICAgICAgYnJvd3NlclBvbHlmaWxsPzogYm9vbGVhbiB8IHsgZXhlY3V0ZVNjcmlwdDogYm9vbGVhbiB9LFxyXG4gICAgKSB7XHJcbiAgICAgICAgZ2V0U2NyaXB0RWxlbXMoJClcclxuICAgICAgICAgICAgLmF0dHIoXCJ0eXBlXCIsIFwibW9kdWxlXCIpXHJcbiAgICAgICAgICAgIC5hdHRyKFwic3JjXCIsIChpLCB2YWx1ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZVBhdGggPSBkaXJuYW1lKCQuZmlsZVBhdGgpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY2h1bmtOYW1lID0gZ2V0T3V0cHV0RmlsZW5hbWVGcm9tQ2h1bmsocmVzb2x2ZShiYXNlUGF0aCwgdmFsdWUgYXMgdW5rbm93biBhcyBzdHJpbmcpLCBjaHVua3MpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbGF0aXZlKGJhc2VQYXRoLCByZXNvbHZlKHNyY0RpciwgY2h1bmtOYW1lKSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICBpZiAoYnJvd3NlclBvbHlmaWxsKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGhlYWQgPSAkKFwiaGVhZFwiKTtcclxuICAgICAgICAgICAgaWYgKFxyXG4gICAgICAgICAgICAgICAgYnJvd3NlclBvbHlmaWxsID09PSB0cnVlIHx8XHJcbiAgICAgICAgICAgICAgICAodHlwZW9mIGJyb3dzZXJQb2x5ZmlsbCA9PT0gXCJvYmplY3RcIiAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGJyb3dzZXJQb2x5ZmlsbC5leGVjdXRlU2NyaXB0KVxyXG4gICAgICAgICAgICApIHtcclxuICAgICAgICAgICAgICAgIGhlYWQucHJlcGVuZChcclxuICAgICAgICAgICAgICAgICAgICAnPHNjcmlwdCBzcmM9XCIvYXNzZXRzL2Jyb3dzZXItcG9seWZpbGwtZXhlY3V0ZVNjcmlwdC5qc1wiPjwvc2NyaXB0PicsXHJcbiAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBoZWFkLnByZXBlbmQoXHJcbiAgICAgICAgICAgICAgICAnPHNjcmlwdCBzcmM9XCIvYXNzZXRzL2Jyb3dzZXItcG9seWZpbGwuanNcIj48L3NjcmlwdD4nLFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuICQ7XHJcbiAgICB9XHJcbn1cclxuIiwiLyogLS0tLS0tLS0tLS0tLS0tLS0tLSBGSUxFTkFNRVMgLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuZXhwb3J0IGNvbnN0IGJhY2tncm91bmRQYWdlUmVsb2FkZXIgPSBcImJhY2tncm91bmQtcGFnZS1yZWxvYWRlci5qc1wiO1xyXG5leHBvcnQgY29uc3QgY29udGVudFNjcmlwdFJlbG9hZGVyID0gXCJjb250ZW50LXNjcmlwdC1yZWxvYWRlci5qc1wiO1xyXG5leHBvcnQgY29uc3QgdGltZXN0YW1wRmlsZW5hbWUgPSBcInRpbWVzdGFtcC5qc29uXCI7XHJcblxyXG4vKiAtLS0tLS0tLS0tLS0tLS0tLS0gUExBQ0VIT0xERVJTIC0tLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG5leHBvcnQgY29uc3QgdGltZXN0YW1wUGF0aFBsYWNlaG9sZGVyID0gXCIlVElNRVNUQU1QX1BBVEglXCI7XHJcbmV4cG9ydCBjb25zdCBsb2FkTWVzc2FnZVBsYWNlaG9sZGVyID0gXCIlTE9BRF9NRVNTQUdFJVwiO1xyXG5leHBvcnQgY29uc3QgY3RTY3JpcHRQYXRoUGxhY2Vob2xkZXIgPSBcIiVDT05URU5UX1NDUklQVF9QQVRIJVwiO1xyXG5leHBvcnQgY29uc3QgdW5yZWdpc3RlclNlcnZpY2VXb3JrZXJzUGxhY2Vob2xkZXIgPSBcIiVVTlJFR0lTVEVSX1NFUlZJQ0VfV09SS0VSUyVcIjtcclxuZXhwb3J0IGNvbnN0IGV4ZWN1dGVTY3JpcHRQbGFjZWhvbGRlciA9IFwiJUVYRUNVVEVfU0NSSVBUJVwiO1xyXG4iLCJpbXBvcnQgeyBjb2RlIGFzIGJnQ2xpZW50Q29kZSB9IGZyb20gXCJjb2RlIC4vY2xpZW50L2JhY2tncm91bmQudHNcIjtcclxuaW1wb3J0IHsgY29kZSBhcyBjdENsaWVudENvZGUgfSBmcm9tIFwiY29kZSAuL2NsaWVudC9jb250ZW50LnRzXCI7XHJcbmltcG9ydCB7IG91dHB1dEpzb24gfSBmcm9tIFwiZnMtZXh0cmFcIjtcclxuaW1wb3J0IHsgam9pbiB9IGZyb20gXCJwYXRoXCI7XHJcbmltcG9ydCB7IFBsdWdpbiB9IGZyb20gXCJyb2xsdXBcIjtcclxuaW1wb3J0IHsgdXBkYXRlTWFuaWZlc3QgfSBmcm9tIFwiLi4vdXRpbHMvaGVscGVyc1wiO1xyXG5pbXBvcnQge1xyXG4gICAgYmFja2dyb3VuZFBhZ2VSZWxvYWRlcixcclxuICAgIGNvbnRlbnRTY3JpcHRSZWxvYWRlcixcclxuICAgIHRpbWVzdGFtcFBhdGhQbGFjZWhvbGRlcixcclxuICAgIGxvYWRNZXNzYWdlUGxhY2Vob2xkZXIsXHJcbiAgICB0aW1lc3RhbXBGaWxlbmFtZSxcclxuICAgIGN0U2NyaXB0UGF0aFBsYWNlaG9sZGVyLFxyXG4gICAgZXhlY3V0ZVNjcmlwdFBsYWNlaG9sZGVyLFxyXG4gICAgdW5yZWdpc3RlclNlcnZpY2VXb3JrZXJzUGxhY2Vob2xkZXIsXHJcbn0gZnJvbSBcIi4vQ09OU1RBTlRTXCI7XHJcblxyXG5leHBvcnQgdHlwZSBTaW1wbGVSZWxvYWRlclBsdWdpbiA9IFBpY2s8XHJcbiAgICBSZXF1aXJlZDxQbHVnaW4+LFxyXG4gICAgXCJuYW1lXCIgfCBcImdlbmVyYXRlQnVuZGxlXCIgfCBcIndyaXRlQnVuZGxlXCJcclxuPlxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTaW1wbGVSZWxvYWRlck9wdGlvbnMge1xyXG4gICAgZXhlY3V0ZVNjcmlwdD86IGJvb2xlYW5cclxuICAgIHVucmVnaXN0ZXJTZXJ2aWNlV29ya2Vycz86IGJvb2xlYW5cclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBTaW1wbGVSZWxvYWRlckNhY2hlIHtcclxuICAgIGJnU2NyaXB0UGF0aD86IHN0cmluZ1xyXG4gICAgY3RTY3JpcHRQYXRoPzogc3RyaW5nXHJcbiAgICB0aW1lc3RhbXBQYXRoPzogc3RyaW5nXHJcbiAgICBvdXRwdXREaXI/OiBzdHJpbmdcclxuICAgIGxvYWRNZXNzYWdlPzogc3RyaW5nXHJcbn1cclxuXHJcbi8vIFVzZWQgZm9yIHRlc3RpbmdcclxuZXhwb3J0IGNvbnN0IF9pbnRlcm5hbENhY2hlOiBTaW1wbGVSZWxvYWRlckNhY2hlID0ge307XHJcblxyXG5leHBvcnQgY29uc3Qgc2ltcGxlUmVsb2FkZXIgPSAoXHJcbiAgICB7XHJcbiAgICAgICAgZXhlY3V0ZVNjcmlwdCA9IHRydWUsXHJcbiAgICAgICAgdW5yZWdpc3RlclNlcnZpY2VXb3JrZXJzID0gdHJ1ZSxcclxuICAgIH0gPSB7fSBhcyBTaW1wbGVSZWxvYWRlck9wdGlvbnMsXHJcbiAgICBjYWNoZSA9IHt9IGFzIFNpbXBsZVJlbG9hZGVyQ2FjaGUsXHJcbik6IFNpbXBsZVJlbG9hZGVyUGx1Z2luIHwgdW5kZWZpbmVkID0+IHtcclxuICAgIGlmICghcHJvY2Vzcy5lbnYuUk9MTFVQX1dBVENIKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5hbWU6IFwiY2hyb21lLWV4dGVuc2lvbi1zaW1wbGUtcmVsb2FkZXJcIixcclxuXHJcbiAgICAgICAgZ2VuZXJhdGVCdW5kbGUoeyBkaXIgfSwgYnVuZGxlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgICAgICBjb25zdCB0aW1lID0gYCR7ZGF0ZVxyXG4gICAgICAgICAgICAgICAgLmdldEZ1bGxZZWFyKClcclxuICAgICAgICAgICAgICAgIC50b1N0cmluZygpXHJcbiAgICAgICAgICAgICAgICAucGFkU3RhcnQoMiwgXCIwXCIpfS0keyhkYXRlLmdldE1vbnRoKCkgKyAxKVxyXG4gICAgICAgICAgICAgICAgICAgIC50b1N0cmluZygpXHJcbiAgICAgICAgICAgICAgICAgICAgLnBhZFN0YXJ0KDIsIFwiMFwiKX0tJHtkYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC5nZXREYXRlKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgLnBhZFN0YXJ0KDIsIFwiMFwiKX0gJHtkYXRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0SG91cnMoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRvU3RyaW5nKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wYWRTdGFydCgyLCBcIjBcIil9OiR7ZGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5nZXRNaW51dGVzKClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAudG9TdHJpbmcoKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wYWRTdGFydCgyLCBcIjBcIil9OiR7ZGF0ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZ2V0U2Vjb25kcygpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50b1N0cmluZygpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5wYWRTdGFydCgyLCBcIjBcIil9YDtcclxuXHJcbiAgICAgICAgICAgIGNhY2hlLm91dHB1dERpciA9IGRpcjtcclxuICAgICAgICAgICAgY2FjaGUubG9hZE1lc3NhZ2UgPSBbXHJcbiAgICAgICAgICAgICAgICBcIkRFVkVMT1BNRU5UIGJ1aWxkIHdpdGggc2ltcGxlIGF1dG8tcmVsb2FkZXJcIixcclxuICAgICAgICAgICAgICAgIGBbJHt0aW1lfV0gd2FpdGluZyBmb3IgY2hhbmdlcy4uLmAsXHJcbiAgICAgICAgICAgIF0uam9pbihcIlxcblwiKTtcclxuXHJcbiAgICAgICAgICAgIC8qIC0tLS0tLS0tLS0tLS0tLSBFTUlUIENMSUVOVCBGSUxFUyAtLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGVtaXQgPSAoXHJcbiAgICAgICAgICAgICAgICBuYW1lOiBzdHJpbmcsXHJcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHN0cmluZyxcclxuICAgICAgICAgICAgICAgIGlzRmlsZU5hbWU/OiBib29sZWFuLFxyXG4gICAgICAgICAgICApID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gdGhpcy5lbWl0RmlsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhc3NldFwiLFxyXG4gICAgICAgICAgICAgICAgICAgIFtpc0ZpbGVOYW1lID8gXCJmaWxlTmFtZVwiIDogXCJuYW1lXCJdOiBuYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEZpbGVOYW1lKGlkKTtcclxuICAgICAgICAgICAgfTtcclxuXHJcbiAgICAgICAgICAgIGNhY2hlLnRpbWVzdGFtcFBhdGggPSBlbWl0KFxyXG4gICAgICAgICAgICAgICAgdGltZXN0YW1wRmlsZW5hbWUsXHJcbiAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShEYXRlLm5vdygpKSxcclxuICAgICAgICAgICAgICAgIHRydWUsXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICBjYWNoZS5jdFNjcmlwdFBhdGggPSBlbWl0KFxyXG4gICAgICAgICAgICAgICAgY29udGVudFNjcmlwdFJlbG9hZGVyLFxyXG4gICAgICAgICAgICAgICAgY3RDbGllbnRDb2RlLnJlcGxhY2UoXHJcbiAgICAgICAgICAgICAgICAgICAgbG9hZE1lc3NhZ2VQbGFjZWhvbGRlcixcclxuICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShjYWNoZS5sb2FkTWVzc2FnZSksXHJcbiAgICAgICAgICAgICAgICApLFxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgY2FjaGUuYmdTY3JpcHRQYXRoID0gZW1pdChcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRQYWdlUmVsb2FkZXIsXHJcbiAgICAgICAgICAgICAgICBiZ0NsaWVudENvZGVcclxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSh0aW1lc3RhbXBQYXRoUGxhY2Vob2xkZXIsIGNhY2hlLnRpbWVzdGFtcFBhdGgpXHJcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRNZXNzYWdlUGxhY2Vob2xkZXIsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGNhY2hlLmxvYWRNZXNzYWdlKSxcclxuICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0U2NyaXB0UGF0aFBsYWNlaG9sZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShjYWNoZS5jdFNjcmlwdFBhdGgpLFxyXG4gICAgICAgICAgICAgICAgICAgIClcclxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZShcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZVNjcmlwdFBsYWNlaG9sZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShleGVjdXRlU2NyaXB0KSxcclxuICAgICAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVucmVnaXN0ZXJTZXJ2aWNlV29ya2Vyc1BsYWNlaG9sZGVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh1bnJlZ2lzdGVyU2VydmljZVdvcmtlcnMpLFxyXG4gICAgICAgICAgICAgICAgICAgICksXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGV4cG9ydGVkIGNhY2hlXHJcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oX2ludGVybmFsQ2FjaGUsIGNhY2hlKTtcclxuXHJcbiAgICAgICAgICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0gVVBEQVRFIE1BTklGRVNUIC0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbiAgICAgICAgICAgIHVwZGF0ZU1hbmlmZXN0KFxyXG4gICAgICAgICAgICAgICAgKG1hbmlmZXN0KSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgLyogLS0tLS0tLS0tLS0tLS0tLS0tIERFU0NSSVBUSU9OIC0tLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBtYW5pZmVzdC5kZXNjcmlwdGlvbiA9IGNhY2hlLmxvYWRNZXNzYWdlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAvKiAtLS0tLS0tLS0tLS0tLS0tIEJBQ0tHUk9VTkQgUEFHRSAtLS0tLS0tLS0tLS0tLS0tICovXHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghbWFuaWZlc3QuYmFja2dyb3VuZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtYW5pZmVzdC5iYWNrZ3JvdW5kID0ge307XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICBtYW5pZmVzdC5iYWNrZ3JvdW5kLnBlcnNpc3RlbnQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNjcmlwdHM6IGJnU2NyaXB0cyA9IFtdIH0gPSBtYW5pZmVzdC5iYWNrZ3JvdW5kO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2FjaGUuYmdTY3JpcHRQYXRoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hbmlmZXN0LmJhY2tncm91bmQuc2NyaXB0cyA9IFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlLmJnU2NyaXB0UGF0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmJnU2NyaXB0cyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYGNhY2hlLmJnU2NyaXB0UGF0aCBpcyAke3R5cGVvZiBjYWNoZS5iZ1NjcmlwdFBhdGh9YCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0gQ09OVEVOVCBTQ1JJUFRTIC0tLS0tLS0tLS0tLS0tLS0gKi9cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBjb250ZW50X3NjcmlwdHM6IGN0U2NyaXB0cyB9ID0gbWFuaWZlc3Q7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZS5jdFNjcmlwdFBhdGgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbWFuaWZlc3QuY29udGVudF9zY3JpcHRzID0gY3RTY3JpcHRzPy5tYXAoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoeyBqcyA9IFtdLCAuLi5yZXN0IH0pID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganM6IFtjYWNoZS5jdFNjcmlwdFBhdGghLCAuLi5qc10sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucmVzdCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgY2FjaGUuY3RTY3JpcHRQYXRoIGlzICR7dHlwZW9mIGNhY2hlLmN0U2NyaXB0UGF0aH1gLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hbmlmZXN0O1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGJ1bmRsZSxcclxuICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IsXHJcbiAgICAgICAgICAgICk7XHJcblxyXG4gICAgICAgICAgICAvLyBXZSdsbCB3cml0ZSB0aGlzIGZpbGUgb3Vyc2VsdmVzLCB3ZSBqdXN0IG5lZWQgYSBzYWZlIHBhdGggdG8gd3JpdGUgdGhlIHRpbWVzdGFtcFxyXG4gICAgICAgICAgICBkZWxldGUgYnVuZGxlW2NhY2hlLnRpbWVzdGFtcFBhdGhdO1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIC8qIC0tLS0tLS0tLS0tLS0tIFdSSVRFIFRJTUVTVEFNUCBGSUxFIC0tLS0tLS0tLS0tLS0gKi9cclxuICAgICAgICBhc3luYyB3cml0ZUJ1bmRsZSgpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGF3YWl0IG91dHB1dEpzb24oXHJcbiAgICAgICAgICAgICAgICAgICAgam9pbihjYWNoZS5vdXRwdXREaXIhLCBjYWNoZS50aW1lc3RhbXBQYXRoISksXHJcbiAgICAgICAgICAgICAgICAgICAgRGF0ZS5ub3coKSxcclxuICAgICAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlcnIubWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXJyb3IoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGBVbmFibGUgdG8gdXBkYXRlIHRpbWVzdGFtcCBmaWxlOlxcblxcdCR7ZXJyLm1lc3NhZ2V9YCxcclxuICAgICAgICAgICAgICAgICAgICApO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yKFwiVW5hYmxlIHRvIHVwZGF0ZSB0aW1lc3RhbXAgZmlsZVwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICB9O1xyXG59O1xyXG4iLCJpbXBvcnQgeyBqb2luIH0gZnJvbSBcInBhdGhcIjtcclxuaW1wb3J0IHsgcmVhZEpTT05TeW5jIH0gZnJvbSBcImZzLWV4dHJhXCI7XHJcbmltcG9ydCB7IFJlc29sdmVkQ29uZmlnIH0gZnJvbSBcInZpdGVcIjtcclxuaW1wb3J0IGh0bWxJbnB1dHMgZnJvbSBcIi4vaHRtbC1pbnB1dHNcIjtcclxuaW1wb3J0IG1hbmlmZXN0SW5wdXQgZnJvbSBcIi4vbWFuaWZlc3QtaW5wdXRcIjtcclxuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSBcIi4vdXRpbHMvbG9nZ2VyXCI7XHJcbmltcG9ydCB7IHZhbGlkYXRlTmFtZXMgYXMgdiB9IGZyb20gXCIuL3ZhbGlkYXRlLW5hbWVzXCI7XHJcbmltcG9ydCB7XHJcbiAgICBDaHJvbWVFeHRlbnNpb25PcHRpb25zLFxyXG4gICAgQ2hyb21lRXh0ZW5zaW9uUGx1Z2luLFxyXG4gICAgSHRtbElucHV0c09wdGlvbnMsXHJcbiAgICBOb3JtYWxpemVkQ2hyb21lRXh0ZW5zaW9uT3B0aW9ucyxcclxufSBmcm9tIFwiLi9wbHVnaW4tb3B0aW9uc1wiO1xyXG5pbXBvcnQgeyBNYW5pZmVzdFByb2Nlc3NvciB9IGZyb20gXCIuL3Byb2Nlc3NvcnMvbWFuaWZlc3RcIjtcclxuaW1wb3J0IHsgQ2hyb21lRXh0ZW5zaW9uTWFuaWZlc3QgfSBmcm9tIFwiLi9tYW5pZmVzdFwiO1xyXG5pbXBvcnQgeyBIdG1sUHJvY2Vzc29yIH0gZnJvbSBcIi4vcHJvY2Vzc29ycy9odG1sXCI7XHJcbmltcG9ydCBzbGFzaCBmcm9tIFwic2xhc2hcIjtcclxuXHJcbmV4cG9ydCB7IHNpbXBsZVJlbG9hZGVyIH0gZnJvbSBcIi4vcGx1Z2luLXJlbG9hZGVyLXNpbXBsZVwiO1xyXG5cclxuZXhwb3J0IGNvbnN0IHN0dWJDaHVua05hbWUgPSBcInN0dWJfX2VtcHR5LWNocm9tZS1leHRlbnNpb24tbWFuaWZlc3RcIjtcclxuXHJcbmV4cG9ydCBjb25zdCBjaHJvbWVFeHRlbnNpb24gPSAoXHJcbiAgICBvcHRpb25zID0ge30gYXMgQ2hyb21lRXh0ZW5zaW9uT3B0aW9ucyxcclxuKTogQ2hyb21lRXh0ZW5zaW9uUGx1Z2luID0+IHtcclxuICAgIC8qIC0tLS0tLS0tLS0tLS0tLSBMT0FEIFBBQ0tBR0UuSlNPTiAtLS0tLS0tLS0tLS0tLS0gKi9cclxuICAgIHRyeSB7XHJcbiAgICAgICAgY29uc3QgcGFja2FnZUpzb25QYXRoID0gam9pbihwcm9jZXNzLmN3ZCgpLCBcInBhY2thZ2UuanNvblwiKTtcclxuICAgICAgICBvcHRpb25zLnBrZyA9IG9wdGlvbnMucGtnIHx8IHJlYWRKU09OU3luYyhwYWNrYWdlSnNvblBhdGgpO1xyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHsgfVxyXG5cclxuICAgIC8qIC0tLS0tLS0tLS0tLS0tLS0tIFNFVFVQIFBMVUdJTlMgLS0tLS0tLS0tLS0tLS0tLS0gKi9cclxuICAgIGNvbnN0IG5vcm1hbGl6ZWRPcHRpb25zID0geyAuLi5vcHRpb25zIH0gYXMgTm9ybWFsaXplZENocm9tZUV4dGVuc2lvbk9wdGlvbnM7XHJcbiAgICBjb25zdCBtYW5pZmVzdDIgPSBtYW5pZmVzdElucHV0KG9wdGlvbnMpO1xyXG4gICAgY29uc3QgaHRtbDIgPSBodG1sSW5wdXRzKG5vcm1hbGl6ZWRPcHRpb25zIGFzIEh0bWxJbnB1dHNPcHRpb25zKTtcclxuICAgIGNvbnN0IG1hbmlmZXN0UHJvY2Vzc29yID0gbmV3IE1hbmlmZXN0UHJvY2Vzc29yKG5vcm1hbGl6ZWRPcHRpb25zKTtcclxuICAgIGNvbnN0IGh0bWxQcm9jZXNzb3IgPSBuZXcgSHRtbFByb2Nlc3Nvcihub3JtYWxpemVkT3B0aW9ucyk7XHJcbiAgICBjb25zdCB2YWxpZGF0ZSA9IHYoKTtcclxuICAgIGxldCBtYW5pZmVzdDogQ2hyb21lRXh0ZW5zaW9uTWFuaWZlc3QgfCB1bmRlZmluZWQ7XHJcbiAgICBsZXQgdml0ZUNvbmZpZzogUmVzb2x2ZWRDb25maWc7XHJcblxyXG4gICAgLyogLS0tLS0tLS0tLS0tLS0tLS0gUkVUVVJOIFBMVUdJTiAtLS0tLS0tLS0tLS0tLS0tLSAqL1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBuYW1lOiBcImNocm9tZS1leHRlbnNpb25cIixcclxuICAgICAgICAvLyBGb3IgdGVzdGluZ1xyXG4gICAgICAgIF9wbHVnaW5zOiB7IG1hbmlmZXN0OiBtYW5pZmVzdDIsIGh0bWw6IGh0bWwyLCB2YWxpZGF0ZSB9LFxyXG4gICAgICAgIGNvbmZpZ1Jlc29sdmVkKGNvbmZpZykge1xyXG4gICAgICAgICAgICB2aXRlQ29uZmlnID0gY29uZmlnO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYXN5bmMgb3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIC8vIERvIG5vdCByZWxvYWQgbWFuaWZlc3Qgd2l0aG91dCBjaGFuZ2VzXHJcbiAgICAgICAgICAgIGlmICghbWFuaWZlc3RQcm9jZXNzb3IubWFuaWZlc3QpIHtcclxuICAgICAgICAgICAgICAgIG1hbmlmZXN0ID0gbWFuaWZlc3RQcm9jZXNzb3IubG9hZChvcHRpb25zKTtcclxuICAgICAgICAgICAgICAgIG9wdGlvbnMuaW5wdXQgPSBtYW5pZmVzdFByb2Nlc3Nvci5yZXNvbHZlSW5wdXQob3B0aW9ucy5pbnB1dCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gcmVzb2x2ZSBzY3JpcHRzIGFuZCBhc3NldHMgaW4gaHRtbFxyXG4gICAgICAgICAgICBvcHRpb25zLmlucHV0ID0gaHRtbFByb2Nlc3Nvci5yZXNvbHZlSW5wdXQob3B0aW9ucy5pbnB1dCk7XHJcbiAgICAgICAgICAgIGxvZ2dlci5sb2dJbnB1dEZpbGVzKG9wdGlvbnMuaW5wdXQpO1xyXG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFzeW5jIGJ1aWxkU3RhcnQoKSB7XHJcbiAgICAgICAgICAgIG1hbmlmZXN0UHJvY2Vzc29yLmFkZFdhdGNoRmlsZXModGhpcyk7XHJcbiAgICAgICAgICAgIGh0bWxQcm9jZXNzb3IuYWRkV2F0Y2hGaWxlcyh0aGlzKTtcclxuICAgICAgICAgICAgYXdhaXQgbWFuaWZlc3RQcm9jZXNzb3IuZW1pdEZpbGVzKHRoaXMpO1xyXG4gICAgICAgICAgICBhd2FpdCBodG1sUHJvY2Vzc29yLmVtaXRGaWxlcyh0aGlzKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJlc29sdmVJZChzb3VyY2UpIHtcclxuICAgICAgICAgICAgaWYgKHNvdXJjZSA9PT0gc3R1YkNodW5rTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNvdXJjZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxvYWQoaWQpIHtcclxuICAgICAgICAgICAgaWYgKGlkID09PSBzdHViQ2h1bmtOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBjb2RlOiBgY29uc29sZS5sb2coXCIke3N0dWJDaHVua05hbWV9XCIpYCB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdHJhbnNmb3JtKGNvZGUsIGlkLCBzc3IpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG1hbmlmZXN0UHJvY2Vzc29yLnRyYW5zZm9ybSh0aGlzLCBjb2RlLCBpZCwgc3NyKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHdhdGNoQ2hhbmdlKGlkKSB7XHJcbiAgICAgICAgICAgIG1hbmlmZXN0UHJvY2Vzc29yLmNsZWFyQ2FjaGVCeUlkKGlkKTtcclxuICAgICAgICAgICAgaHRtbFByb2Nlc3Nvci5jbGVhckNhY2hlQnlJZChpZCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICByZXNvbHZlRmlsZVVybCh7IHJlZmVyZW5jZUlkLCBmaWxlTmFtZSB9KSB7XHJcbiAgICAgICAgICAgIGlmIChtYW5pZmVzdFByb2Nlc3Nvci5pc0R5bmFtaWNJbXBvcnRlZENvbnRlbnRTY3JpcHQocmVmZXJlbmNlSWQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gYFwiJHtzbGFzaChmaWxlTmFtZSl9XCJgO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb3V0cHV0T3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgY2h1bmtGaWxlTmFtZXM6IFwiW25hbWVdLltoYXNoXS5qc1wiLFxyXG4gICAgICAgICAgICAgICAgYXNzZXRGaWxlTmFtZXM6IFwiW25hbWVdLltoYXNoXS5bZXh0XVwiLFxyXG4gICAgICAgICAgICAgICAgZW50cnlGaWxlTmFtZXM6IFwiW25hbWVdLmpzXCJcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFzeW5jIGdlbmVyYXRlQnVuZGxlKG9wdGlvbnMsIGJ1bmRsZSwgaXNXcml0ZSkge1xyXG4gICAgICAgICAgICBhd2FpdCBtYW5pZmVzdFByb2Nlc3Nvci5nZW5lcmF0ZUJ1bmRsZSh0aGlzLCBidW5kbGUpO1xyXG4gICAgICAgICAgICBhd2FpdCBodG1sUHJvY2Vzc29yLmdlbmVyYXRlQnVuZGxlKHRoaXMsIGJ1bmRsZSk7XHJcbiAgICAgICAgICAgIC8vIGF3YWl0IHZhbGlkYXRlLmdlbmVyYXRlQnVuZGxlLmNhbGwodGhpcywgb3B0aW9ucywgYnVuZGxlLCBpc1dyaXRlKTtcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufTtcclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBVUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUlBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXVDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FDcUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4SkE7QUFDQTtBQUNBOzs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3R0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyUUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQ2xLQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBOzs7Ozs7O21nQkNTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzNMQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7In0=
