import { InputOption, InputOptions, OutputBundle, PluginContext } from "rollup";
import { ChromeExtensionManifest } from "../manifest";
import { ManifestInputPluginCache, NormalizedChromeExtensionOptions } from "../plugin-options";
import { ContentScriptProcessor } from "./content-script/content-script";
import { PermissionProcessor } from "./permission";
import { BackgroundProcesser } from "./background/background";
export declare const explorer: {
    readonly search: (searchFrom?: string | undefined) => import("cosmiconfig/dist/types").CosmiconfigResult;
    readonly load: (filepath: string) => import("cosmiconfig/dist/types").CosmiconfigResult;
    readonly clearLoadCache: () => void;
    readonly clearSearchCache: () => void;
    readonly clearCaches: () => void;
};
export declare type ExtendManifest = Partial<ChromeExtensionManifest> | ((manifest: ChromeExtensionManifest) => ChromeExtensionManifest);
export declare type ChromeExtensionConfigurationInfo = {
    filepath: string;
    config: ChromeExtensionManifest;
    isEmpty?: true;
};
export declare class ManifestProcessor {
    private options;
    cache: ManifestInputPluginCache;
    manifest?: ChromeExtensionManifest;
    contentScriptProcessor: ContentScriptProcessor;
    permissionProcessor: PermissionProcessor;
    backgroundProcessor: BackgroundProcesser;
    constructor(options?: NormalizedChromeExtensionOptions);
    /**
     * Load content from manifest.json
     * @param options: rollup input options
     */
    load(options: InputOptions): ChromeExtensionManifest;
    /**
     * Resolve input files for rollup
     * @param input: Input not in manifest.json but specify by user
     * @returns
     */
    resolveInput(input?: InputOption): {
        [entryAlias: string]: string;
    };
    /**
     * Add watch files
     * @param context Rollup Plugin Context
     */
    addWatchFiles(context: PluginContext): void;
    emitFiles(context: PluginContext): Promise<void>;
    clearCacheById(id: string): void;
    generateBundle(context: PluginContext, bundle: OutputBundle): Promise<void>;
    private resolveManifestPath;
    private validateManifestContent;
    private validateManifest;
    private applyExternalManifestConfiguration;
    private readAssetAsBuffer;
    private generateManifest;
}
